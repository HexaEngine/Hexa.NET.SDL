// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{
		/// <summary>
		/// Allocate uninitialized memory.<br/>
		/// The allocated memory returned by this function must be freed with<br/>
		/// SDL_free().<br/>
		/// If `size` is 0, it will be set to 1.<br/>
		/// If the allocation is successful, the returned pointer is guaranteed to be<br/>
		/// aligned to either the *fundamental alignment* (`alignof(max_align_t)` in<br/>
		/// C11 and later) or `2 * sizeof(void *)`, whichever is smaller. Use<br/>
		/// SDL_aligned_alloc() if you need to allocate memory aligned to an alignment<br/>
		/// greater than this guarantee.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_malloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MallocNative([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, void*>)funcTable[0])(size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nint>)funcTable[0])(size);
			#endif
		}

		/// <summary>
		/// Allocate uninitialized memory.<br/>
		/// The allocated memory returned by this function must be freed with<br/>
		/// SDL_free().<br/>
		/// If `size` is 0, it will be set to 1.<br/>
		/// If the allocation is successful, the returned pointer is guaranteed to be<br/>
		/// aligned to either the *fundamental alignment* (`alignof(max_align_t)` in<br/>
		/// C11 and later) or `2 * sizeof(void *)`, whichever is smaller. Use<br/>
		/// SDL_aligned_alloc() if you need to allocate memory aligned to an alignment<br/>
		/// greater than this guarantee.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_malloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Malloc([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = MallocNative(size);
			return ret;
		}

		/// <summary>
		/// Allocate a zero-initialized array.<br/>
		/// The memory returned by this function must be freed with SDL_free().<br/>
		/// If either of `nmemb` or `size` is 0, they will both be set to 1.<br/>
		/// If the allocation is successful, the returned pointer is guaranteed to be<br/>
		/// aligned to either the *fundamental alignment* (`alignof(max_align_t)` in<br/>
		/// C11 and later) or `2 * sizeof(void *)`, whichever is smaller.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_calloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* CallocNative([NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, nuint, void*>)funcTable[1])(nmemb, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nuint, nint>)funcTable[1])(nmemb, size);
			#endif
		}

		/// <summary>
		/// Allocate a zero-initialized array.<br/>
		/// The memory returned by this function must be freed with SDL_free().<br/>
		/// If either of `nmemb` or `size` is 0, they will both be set to 1.<br/>
		/// If the allocation is successful, the returned pointer is guaranteed to be<br/>
		/// aligned to either the *fundamental alignment* (`alignof(max_align_t)` in<br/>
		/// C11 and later) or `2 * sizeof(void *)`, whichever is smaller.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_calloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Calloc([NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = CallocNative(nmemb, size);
			return ret;
		}

		/// <summary>
		/// Change the size of allocated memory.<br/>
		/// The memory returned by this function must be freed with SDL_free().<br/>
		/// If `size` is 0, it will be set to 1. Note that this is unlike some other C<br/>
		/// runtime `realloc` implementations, which may treat `realloc(mem, 0)` the<br/>
		/// same way as `free(mem)`.<br/>
		/// If `mem` is NULL, the behavior of this function is equivalent to<br/>
		/// SDL_malloc(). Otherwise, the function can have one of three possible<br/>
		/// outcomes:<br/>
		/// - If it returns the same pointer as `mem`, it means that `mem` was resized<br/>
		/// in place without freeing.<br/>
		/// - If it returns a different non-NULL pointer, it means that `mem` was freed<br/>
		/// and cannot be dereferenced anymore.<br/>
		/// - If it returns NULL (indicating failure), then `mem` will remain valid and<br/>
		/// must still be freed with SDL_free().<br/>
		/// If the allocation is successfully resized, the returned pointer is<br/>
		/// guaranteed to be aligned to either the *fundamental alignment*<br/>
		/// (`alignof(max_align_t)` in C11 and later) or `2 * sizeof(void *)`,<br/>
		/// whichever is smaller.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_realloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* ReallocNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, void*>)funcTable[2])(mem, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[2])((nint)mem, size);
			#endif
		}

		/// <summary>
		/// Change the size of allocated memory.<br/>
		/// The memory returned by this function must be freed with SDL_free().<br/>
		/// If `size` is 0, it will be set to 1. Note that this is unlike some other C<br/>
		/// runtime `realloc` implementations, which may treat `realloc(mem, 0)` the<br/>
		/// same way as `free(mem)`.<br/>
		/// If `mem` is NULL, the behavior of this function is equivalent to<br/>
		/// SDL_malloc(). Otherwise, the function can have one of three possible<br/>
		/// outcomes:<br/>
		/// - If it returns the same pointer as `mem`, it means that `mem` was resized<br/>
		/// in place without freeing.<br/>
		/// - If it returns a different non-NULL pointer, it means that `mem` was freed<br/>
		/// and cannot be dereferenced anymore.<br/>
		/// - If it returns NULL (indicating failure), then `mem` will remain valid and<br/>
		/// must still be freed with SDL_free().<br/>
		/// If the allocation is successfully resized, the returned pointer is<br/>
		/// guaranteed to be aligned to either the *fundamental alignment*<br/>
		/// (`alignof(max_align_t)` in C11 and later) or `2 * sizeof(void *)`,<br/>
		/// whichever is smaller.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_realloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Realloc([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = ReallocNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Change the size of allocated memory.<br/>
		/// The memory returned by this function must be freed with SDL_free().<br/>
		/// If `size` is 0, it will be set to 1. Note that this is unlike some other C<br/>
		/// runtime `realloc` implementations, which may treat `realloc(mem, 0)` the<br/>
		/// same way as `free(mem)`.<br/>
		/// If `mem` is NULL, the behavior of this function is equivalent to<br/>
		/// SDL_malloc(). Otherwise, the function can have one of three possible<br/>
		/// outcomes:<br/>
		/// - If it returns the same pointer as `mem`, it means that `mem` was resized<br/>
		/// in place without freeing.<br/>
		/// - If it returns a different non-NULL pointer, it means that `mem` was freed<br/>
		/// and cannot be dereferenced anymore.<br/>
		/// - If it returns NULL (indicating failure), then `mem` will remain valid and<br/>
		/// must still be freed with SDL_free().<br/>
		/// If the allocation is successfully resized, the returned pointer is<br/>
		/// guaranteed to be aligned to either the *fundamental alignment*<br/>
		/// (`alignof(max_align_t)` in C11 and later) or `2 * sizeof(void *)`,<br/>
		/// whichever is smaller.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_realloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Realloc([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] nint mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = ReallocNative((void*)mem, size);
			return ret;
		}

		/// <summary>
		/// Free allocated memory.<br/>
		/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
		/// anymore.<br/>
		/// If `mem` is NULL, this function does nothing.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[3])(mem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[3])((nint)mem);
			#endif
		}

		/// <summary>
		/// Free allocated memory.<br/>
		/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
		/// anymore.<br/>
		/// If `mem` is NULL, this function does nothing.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Free([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem)
		{
			FreeNative(mem);
		}

		/// <summary>
		/// Free allocated memory.<br/>
		/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
		/// anymore.<br/>
		/// If `mem` is NULL, this function does nothing.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Free([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] nint mem)
		{
			FreeNative((void*)mem);
		}

		/// <summary>
		/// Get the original set of SDL memory functions.<br/>
		/// This is what SDL_malloc and friends will use by default, if there has been<br/>
		/// no call to SDL_SetMemoryFunctions. This is not necessarily using the C<br/>
		/// runtime's `malloc` functions behind the scenes! Different platforms and<br/>
		/// build configurations might do any number of unexpected things.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetOriginalMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetOriginalMemoryFunctionsNative([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func *")] delegate*<nuint, void*>* mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func *")] delegate*<nuint, nuint, void*>* callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func *")] delegate*<void*, nuint, void*>* reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func *")] delegate*<void*, void>* freeFunc)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*>*, delegate*<nuint, nuint, void*>*, delegate*<void*, nuint, void*>*, delegate*<void*, void>*, void>)funcTable[4])(mallocFunc, callocFunc, reallocFunc, freeFunc);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[4])((nint)mallocFunc, (nint)callocFunc, (nint)reallocFunc, (nint)freeFunc);
			#endif
		}

		/// <summary>
		/// Get the original set of SDL memory functions.<br/>
		/// This is what SDL_malloc and friends will use by default, if there has been<br/>
		/// no call to SDL_SetMemoryFunctions. This is not necessarily using the C<br/>
		/// runtime's `malloc` functions behind the scenes! Different platforms and<br/>
		/// build configurations might do any number of unexpected things.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetOriginalMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetOriginalMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func *")] delegate*<nuint, void*>* mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func *")] delegate*<nuint, nuint, void*>* callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func *")] delegate*<void*, nuint, void*>* reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func *")] delegate*<void*, void>* freeFunc)
		{
			GetOriginalMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
		}

		/// <summary>
		/// Get the current set of SDL memory functions.<br/>
		/// <br/>
		/// <br/>
		/// This does not hold a lock, so do not call this in the<br/>
		/// unlikely event of a background thread calling<br/>
		/// SDL_SetMemoryFunctions simultaneously.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMemoryFunctionsNative([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func *")] delegate*<nuint, void*>* mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func *")] delegate*<nuint, nuint, void*>* callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func *")] delegate*<void*, nuint, void*>* reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func *")] delegate*<void*, void>* freeFunc)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*>*, delegate*<nuint, nuint, void*>*, delegate*<void*, nuint, void*>*, delegate*<void*, void>*, void>)funcTable[5])(mallocFunc, callocFunc, reallocFunc, freeFunc);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[5])((nint)mallocFunc, (nint)callocFunc, (nint)reallocFunc, (nint)freeFunc);
			#endif
		}

		/// <summary>
		/// Get the current set of SDL memory functions.<br/>
		/// <br/>
		/// <br/>
		/// This does not hold a lock, so do not call this in the<br/>
		/// unlikely event of a background thread calling<br/>
		/// SDL_SetMemoryFunctions simultaneously.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func *")] delegate*<nuint, void*>* mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func *")] delegate*<nuint, nuint, void*>* callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func *")] delegate*<void*, nuint, void*>* reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func *")] delegate*<void*, void>* freeFunc)
		{
			GetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetMemoryFunctionsNative([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<nuint, void*>, delegate*<nuint, nuint, void*>, delegate*<void*, nuint, void*>, delegate*<void*, void>, byte>)funcTable[6])(mallocFunc, callocFunc, reallocFunc, freeFunc);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[6])((nint)mallocFunc, (nint)callocFunc, (nint)reallocFunc, (nint)freeFunc);
			#endif
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, reallocFunc, freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] delegate*<void*, void> freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), freeFunc);
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] delegate*<void*, nuint, void*> reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), reallocFunc, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] delegate*<nuint, nuint, void*> callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), callocFunc, (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] delegate*<nuint, void*> mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative(mallocFunc, (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set.<br/>
		/// It is not safe to call this function once any allocations have been made,<br/>
		/// as future calls to SDL_free will use the new allocator, even if they came<br/>
		/// from an SDL_malloc made with the old one!<br/>
		/// If used, usually this needs to be the first call made into the SDL library,<br/>
		/// if not the very first thing done at program startup time.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but one<br/>
		/// should not replace the memory functions once any allocations<br/>
		/// are made!<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			byte ret = SetMemoryFunctionsNative((delegate*<nuint, void*>)Utils.GetFunctionPointerForDelegate(mallocFunc), (delegate*<nuint, nuint, void*>)Utils.GetFunctionPointerForDelegate(callocFunc), (delegate*<void*, nuint, void*>)Utils.GetFunctionPointerForDelegate(reallocFunc), (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc));
			return ret != 0;
		}

		/// <summary>
		/// Allocate memory aligned to a specific alignment.<br/>
		/// The memory returned by this function must be freed with SDL_aligned_free(),<br/>
		/// _not_ SDL_free().<br/>
		/// If `alignment` is less than the size of `void *`, it will be increased to<br/>
		/// match that.<br/>
		/// The returned memory address will be a multiple of the alignment value, and<br/>
		/// the size of the memory allocated will be a multiple of the alignment value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_aligned_alloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* AlignedAllocNative([NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "size_t")] nuint alignment, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, nuint, void*>)funcTable[7])(alignment, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nuint, nint>)funcTable[7])(alignment, size);
			#endif
		}

		/// <summary>
		/// Allocate memory aligned to a specific alignment.<br/>
		/// The memory returned by this function must be freed with SDL_aligned_free(),<br/>
		/// _not_ SDL_free().<br/>
		/// If `alignment` is less than the size of `void *`, it will be increased to<br/>
		/// match that.<br/>
		/// The returned memory address will be a multiple of the alignment value, and<br/>
		/// the size of the memory allocated will be a multiple of the alignment value.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_aligned_alloc")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* AlignedAlloc([NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "size_t")] nuint alignment, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = AlignedAllocNative(alignment, size);
			return ret;
		}

		/// <summary>
		/// Free memory allocated by SDL_aligned_alloc().<br/>
		/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
		/// anymore.<br/>
		/// If `mem` is NULL, this function does nothing.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_aligned_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlignedFreeNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[8])(mem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[8])((nint)mem);
			#endif
		}

		/// <summary>
		/// Free memory allocated by SDL_aligned_alloc().<br/>
		/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
		/// anymore.<br/>
		/// If `mem` is NULL, this function does nothing.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_aligned_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AlignedFree([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem)
		{
			AlignedFreeNative(mem);
		}

		/// <summary>
		/// Free memory allocated by SDL_aligned_alloc().<br/>
		/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
		/// anymore.<br/>
		/// If `mem` is NULL, this function does nothing.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_aligned_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AlignedFree([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] nint mem)
		{
			AlignedFreeNative((void*)mem);
		}

		/// <summary>
		/// Get the number of outstanding (unfreed) allocations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAllocations")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumAllocationsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[9])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[9])();
			#endif
		}

		/// <summary>
		/// Get the number of outstanding (unfreed) allocations.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAllocations")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumAllocations()
		{
			int ret = GetNumAllocationsNative();
			return ret;
		}

		/// <summary>
		/// Get the process environment.<br/>
		/// This is initialized at application start and is not affected by setenv()<br/>
		/// and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and<br/>
		/// SDL_UnsetEnvironmentVariable() if you want to modify this environment, or<br/>
		/// SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist<br/>
		/// in the C runtime environment after SDL_Quit().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironment")]
		[return: NativeName(NativeNameType.Type, "SDL_Environment *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEnvironment* GetEnvironmentNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEnvironment*>)funcTable[10])();
			#else
			return (SDLEnvironment*)((delegate* unmanaged[Cdecl]<nint>)funcTable[10])();
			#endif
		}

		/// <summary>
		/// Get the process environment.<br/>
		/// This is initialized at application start and is not affected by setenv()<br/>
		/// and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and<br/>
		/// SDL_UnsetEnvironmentVariable() if you want to modify this environment, or<br/>
		/// SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist<br/>
		/// in the C runtime environment after SDL_Quit().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironment")]
		[return: NativeName(NativeNameType.Type, "SDL_Environment *")]
		public static SDLEnvironmentPtr GetEnvironment()
		{
			SDLEnvironmentPtr ret = GetEnvironmentNative();
			return ret;
		}

		/// <summary>
		/// Create a set of environment variables<br/>
		/// <br/>
		/// <br/>
		/// If `populated` is false, it is safe to call this function<br/>
		/// from any thread, otherwise it is safe if no other threads are<br/>
		/// calling setenv() or unsetenv()<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateEnvironment")]
		[return: NativeName(NativeNameType.Type, "SDL_Environment *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEnvironment* CreateEnvironmentNative([NativeName(NativeNameType.Param, "populated")] [NativeName(NativeNameType.Type, "bool")] byte populated)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, SDLEnvironment*>)funcTable[11])(populated);
			#else
			return (SDLEnvironment*)((delegate* unmanaged[Cdecl]<byte, nint>)funcTable[11])(populated);
			#endif
		}

		/// <summary>
		/// Create a set of environment variables<br/>
		/// <br/>
		/// <br/>
		/// If `populated` is false, it is safe to call this function<br/>
		/// from any thread, otherwise it is safe if no other threads are<br/>
		/// calling setenv() or unsetenv()<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateEnvironment")]
		[return: NativeName(NativeNameType.Type, "SDL_Environment *")]
		public static SDLEnvironmentPtr CreateEnvironment([NativeName(NativeNameType.Param, "populated")] [NativeName(NativeNameType.Type, "bool")] bool populated)
		{
			SDLEnvironmentPtr ret = CreateEnvironmentNative(populated ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetEnvironmentVariableNative([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironment* env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEnvironment*, byte*, byte*>)funcTable[12])(env, name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[12])((nint)env, (nint)name);
			#endif
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)env, name);
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)env, name));
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)penv, name);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)penv, name));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)env, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)env, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = &name)
				{
					byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = &name)
				{
					string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = name)
				{
					byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = name)
				{
					string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = GetEnvironmentVariableNative((SDLEnvironment*)penv, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetEnvironmentVariableS([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(GetEnvironmentVariableNative((SDLEnvironment*)penv, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get all variables in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariables")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GetEnvironmentVariablesNative([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironment* env)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEnvironment*, byte**>)funcTable[13])(env);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[13])((nint)env);
			#endif
		}

		/// <summary>
		/// Get all variables in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariables")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GetEnvironmentVariables([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env)
		{
			byte** ret = GetEnvironmentVariablesNative((SDLEnvironment*)env);
			return ret;
		}

		/// <summary>
		/// Get all variables in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEnvironmentVariables")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GetEnvironmentVariables([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte** ret = GetEnvironmentVariablesNative((SDLEnvironment*)penv);
				return ret;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetEnvironmentVariableNative([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironment* env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] byte overwrite)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEnvironment*, byte*, byte*, byte, byte>)funcTable[14])(env, name, value, overwrite);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, byte>)funcTable[14])((nint)env, (nint)name, (nint)value, overwrite);
			#endif
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, name, value, overwrite ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, name, value, overwrite ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname, value, overwrite ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname, value, overwrite ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, pStr0, value, overwrite ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = &name)
				{
					byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname, value, overwrite ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = name)
				{
					byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname, value, overwrite ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, pStr0, value, overwrite ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (byte* pvalue = &value)
			{
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, name, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (byte* pvalue = value)
			{
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, name, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, name, pStr0, overwrite ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, name, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, name, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (value != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(value);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, name, pStr0, overwrite ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetEnvironmentVariableNative((SDLEnvironment*)env, pStr0, pStr1, overwrite ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = &name)
				{
					fixed (byte* pvalue = &value)
					{
						byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = name)
				{
					fixed (byte* pvalue = value)
					{
						byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname, (byte*)pvalue, overwrite ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "bool")] bool overwrite)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (value != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(value);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = SetEnvironmentVariableNative((SDLEnvironment*)penv, pStr0, pStr1, overwrite ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnsetEnvironmentVariableNative([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironment* env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEnvironment*, byte*, byte>)funcTable[15])(env, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[15])((nint)env, (nint)name);
			#endif
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)env, name);
			return ret != 0;
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)penv, name);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)env, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)env, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = &name)
				{
					byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				fixed (byte* pname = name)
				{
					byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)penv, (byte*)pname);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnsetEnvironmentVariable")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UnsetEnvironmentVariable([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = UnsetEnvironmentVariableNative((SDLEnvironment*)penv, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Destroy a set of environment variables.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the environment is no longer in use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyEnvironment")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyEnvironmentNative([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironment* env)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLEnvironment*, void>)funcTable[16])(env);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[16])((nint)env);
			#endif
		}

		/// <summary>
		/// Destroy a set of environment variables.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the environment is no longer in use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyEnvironment")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyEnvironment([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] SDLEnvironmentPtr env)
		{
			DestroyEnvironmentNative((SDLEnvironment*)env);
		}

		/// <summary>
		/// Destroy a set of environment variables.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the environment is no longer in use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyEnvironment")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyEnvironment([NativeName(NativeNameType.Param, "env")] [NativeName(NativeNameType.Type, "SDL_Environment *")] ref SDLEnvironment env)
		{
			fixed (SDLEnvironment* penv = &env)
			{
				DestroyEnvironmentNative((SDLEnvironment*)penv);
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetenvNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[17])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[17])((nint)name);
			#endif
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* Getenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte* ret = GetenvNative(name);
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(GetenvNative(name));
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* Getenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetenvNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetenvNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* Getenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetenvNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetenvNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* Getenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetenvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetenvNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetenvUnsafeNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[18])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[18])((nint)name);
			#endif
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte* ret = GetenvUnsafeNative(name);
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvUnsafeS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(GetenvUnsafeNative(name));
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetenvUnsafeNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvUnsafeS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetenvUnsafeNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetenvUnsafeNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvUnsafeS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetenvUnsafeNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetenvUnsafeNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the value of a variable in the environment.<br/>
		/// This function bypasses SDL's cached copy of the environment and is not<br/>
		/// thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using SDL_getenv()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_getenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetenvUnsafeS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetenvUnsafeNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetenvUnsafeNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, int>)funcTable[19])(name, value, overwrite);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[19])((nint)name, (nint)value, overwrite);
			#endif
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			int ret = SetenvUnsafeNative(name, value, overwrite);
			return ret;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetenvUnsafeNative((byte*)pname, value, overwrite);
				return ret;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pname = name)
			{
				int ret = SetenvUnsafeNative((byte*)pname, value, overwrite);
				return ret;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetenvUnsafeNative(pStr0, value, overwrite);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pvalue = &value)
			{
				int ret = SetenvUnsafeNative(name, (byte*)pvalue, overwrite);
				return ret;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pvalue = value)
			{
				int ret = SetenvUnsafeNative(name, (byte*)pvalue, overwrite);
				return ret;
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetenvUnsafeNative(name, pStr0, overwrite);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					int ret = SetenvUnsafeNative((byte*)pname, (byte*)pvalue, overwrite);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					int ret = SetenvUnsafeNative((byte*)pname, (byte*)pvalue, overwrite);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the value of a variable in the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_SetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_setenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SetenvUnsafeNative(pStr0, pStr1, overwrite);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_UnsetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_unsetenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UnsetenvUnsafeNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[20])(name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[20])((nint)name);
			#endif
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_UnsetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_unsetenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UnsetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			int ret = UnsetenvUnsafeNative(name);
			return ret;
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_UnsetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_unsetenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UnsetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = UnsetenvUnsafeNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_UnsetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_unsetenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UnsetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = UnsetenvUnsafeNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Clear a variable from the environment.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, consider using<br/>
		/// SDL_UnsetEnvironmentVariable() instead.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_unsetenv_unsafe")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UnsetenvUnsafe([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = UnsetenvUnsafeNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Sort an array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QsortNative([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, nuint, nuint, delegate*<void*, void*, int>, void>)funcTable[21])(baseValue, nmemb, size, compare);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, nuint, nint, void>)funcTable[21])((nint)baseValue, nmemb, size, (nint)compare);
			#endif
		}

		/// <summary>
		/// Sort an array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Qsort([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			QsortNative(baseValue, nmemb, size, compare);
		}

		/// <summary>
		/// Sort an array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Qsort([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			QsortNative((void*)baseValue, nmemb, size, compare);
		}

		/// <summary>
		/// Sort an array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Qsort([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] SDLCompareCallback compare)
		{
			QsortNative(baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
		}

		/// <summary>
		/// Sort an array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Qsort([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] SDLCompareCallback compare)
		{
			QsortNative((void*)baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* BsearchNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, nuint, delegate*<void*, void*, int>, void*>)funcTable[22])(key, baseValue, nmemb, size, compare);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint, nint, nint>)funcTable[22])((nint)key, (nint)baseValue, nmemb, size, (nint)compare);
			#endif
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative(key, baseValue, nmemb, size, compare);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative((void*)key, baseValue, nmemb, size, compare);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative(key, (void*)baseValue, nmemb, size, compare);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] delegate*<void*, void*, int> compare)
		{
			void* ret = BsearchNative((void*)key, (void*)baseValue, nmemb, size, compare);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] SDLCompareCallback compare)
		{
			void* ret = BsearchNative(key, baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] SDLCompareCallback compare)
		{
			void* ret = BsearchNative((void*)key, baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] SDLCompareCallback compare)
		{
			void* ret = BsearchNative(key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *a, const void *b)<br/>
		/// {<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->n <br/>
		/// <<br/>
		/// B->n) {<br/>
		/// return -1;<br/>
		/// } else if (B->n <br/>
		/// <<br/>
		/// A->n) {<br/>
		/// return 1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* Bsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback")] SDLCompareCallback compare)
		{
			void* ret = BsearchNative((void*)key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare));
			return ret;
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QsortRNative([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, nuint, nuint, delegate*<void*, void*, void*, int>, void*, void>)funcTable[23])(baseValue, nmemb, size, compare, userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, nuint, nint, nint, void>)funcTable[23])((nint)baseValue, nmemb, size, (nint)compare, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			QsortRNative(baseValue, nmemb, size, compare, userdata);
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			QsortRNative((void*)baseValue, nmemb, size, compare, userdata);
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			QsortRNative(baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), userdata);
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			QsortRNative((void*)baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), userdata);
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			QsortRNative(baseValue, nmemb, size, compare, (void*)userdata);
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			QsortRNative((void*)baseValue, nmemb, size, compare, (void*)userdata);
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			QsortRNative(baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), (void*)userdata);
		}

		/// <summary>
		/// Sort an array, passing a userdata pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
		/// };<br/>
		/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_qsort_r")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QsortR([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			QsortRNative((void*)baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), (void*)userdata);
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* BsearchRNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, void*, nuint, nuint, delegate*<void*, void*, void*, int>, void*, void*>)funcTable[24])(key, baseValue, nmemb, size, compare, userdata);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint, nint, nint, nint>)funcTable[24])((nint)key, (nint)baseValue, nmemb, size, (nint)compare, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative(key, baseValue, nmemb, size, compare, userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative((void*)key, baseValue, nmemb, size, compare, userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative(key, (void*)baseValue, nmemb, size, compare, userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative((void*)key, (void*)baseValue, nmemb, size, compare, userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative(key, baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative((void*)key, baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative(key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			void* ret = BsearchRNative((void*)key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative(key, baseValue, nmemb, size, compare, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative((void*)key, baseValue, nmemb, size, compare, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative(key, (void*)baseValue, nmemb, size, compare, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] delegate*<void*, void*, void*, int> compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative((void*)key, (void*)baseValue, nmemb, size, compare, (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative(key, baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] nint key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative((void*)key, baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), (void*)userdata);
			return ret;
		}

		/// <summary>
		/// Perform a binary search on a previously sorted array, passing a userdata<br/>
		/// pointer to the compare function.<br/>
		/// For example:<br/>
		/// ```c<br/>
		/// typedef enum {<br/>
		/// sort_increasing,<br/>
		/// sort_decreasing,<br/>
		/// } sort_method;<br/>
		/// typedef struct {<br/>
		/// int key;<br/>
		/// const char *string;<br/>
		/// } data;<br/>
		/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
		/// {<br/>
		/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
		/// const data *A = (const data *)a;<br/>
		/// const data *B = (const data *)b;<br/>
		/// if (A->key <br/>
		/// <<br/>
		/// B->key) {<br/>
		/// return (method == sort_increasing) ? -1 : 1;<br/>
		/// } else if (B->key <br/>
		/// <<br/>
		/// A->key) {<br/>
		/// return (method == sort_increasing) ? 1 : -1;<br/>
		/// } else {<br/>
		/// return 0;<br/>
		/// }<br/>
		/// }<br/>
		/// data values[] = {<br/>
		/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
		/// };<br/>
		/// data key = { 2, NULL };<br/>
		/// data *result = SDL_bsearch_r(<br/>
		/// &key<br/>
		/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_bsearch_r")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BsearchR([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "void const *")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void const *")] nint baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "SDL_CompareCallback_r")] SDLCompareCallbackR compare, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			void* ret = BsearchRNative(key, (void*)baseValue, nmemb, size, (delegate*<void*, void*, void*, int>)Utils.GetFunctionPointerForDelegate(compare), (void*)userdata);
			return ret;
		}
	}
}
