// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, appevent, appquit);
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, appevent, appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, appquit);
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, appquit);
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, appquit);
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, appquit);
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, appinit, appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] delegate*<void*, SDLAppResult, void> appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, appiter, appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, appinit, appiter, appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, appiter, appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] delegate*<void*, SDLEvent*, SDLAppResult> appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), appevent, (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, appinit, appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] delegate*<void*, SDLAppResult> appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), appiter, (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] delegate*<void**, int, byte**, SDLAppResult> appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] ref byte* argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			fixed (byte** pargv = &argv)
			{
				int ret = EnterAppMainCallbacksNative(argc, (byte**)pargv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
				return ret;
			}
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RegisterAppNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, void*, byte>)funcTable[1280])(name, style, hInst);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, nint, byte>)funcTable[1280])((nint)name, style, (nint)hInst);
			#endif
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			byte ret = RegisterAppNative(name, style, hInst);
			return ret != 0;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			fixed (byte* pname = &name)
			{
				byte ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret != 0;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			fixed (byte* pname = name)
			{
				byte ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret != 0;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RegisterAppNative(pStr0, style, hInst);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] nint hInst)
		{
			byte ret = RegisterAppNative(name, style, (void*)hInst);
			return ret != 0;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] nint hInst)
		{
			fixed (byte* pname = &name)
			{
				byte ret = RegisterAppNative((byte*)pname, style, (void*)hInst);
				return ret != 0;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] nint hInst)
		{
			fixed (byte* pname = name)
			{
				byte ret = RegisterAppNative((byte*)pname, style, (void*)hInst);
				return ret != 0;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// If `name` is NULL, SDL currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` for<br/>
		/// the style, regardless of what is specified here.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] nint hInst)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RegisterAppNative(pStr0, style, (void*)hInst);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnregisterAppNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1281])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1281])();
			#endif
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnregisterApp()
		{
			UnregisterAppNative();
		}

		/// <summary>
		/// Callback from the application to let the suspend continue.<br/>
		/// This function is only needed for Xbox GDK support; all other platforms will<br/>
		/// do nothing and set an "unsupported" error message.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GDKSuspendComplete")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GDKSuspendCompleteNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1282])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1282])();
			#endif
		}

		/// <summary>
		/// Callback from the application to let the suspend continue.<br/>
		/// This function is only needed for Xbox GDK support; all other platforms will<br/>
		/// do nothing and set an "unsupported" error message.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GDKSuspendComplete")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GDKSuspendComplete()
		{
			GDKSuspendCompleteNative();
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WinMainNative([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] byte* szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nint, nint, byte*, int, int>)funcTable[1283])(hInst, hPrev, szCmdLine, sw);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)funcTable[1283])(hInst, hPrev, (nint)szCmdLine, sw);
			#endif
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WinMain([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] byte* szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			int ret = WinMainNative(hInst, hPrev, szCmdLine, sw);
			return ret;
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WinMain([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] ReadOnlySpan<byte> szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			fixed (byte* pszCmdLine = szCmdLine)
			{
				int ret = WinMainNative(hInst, hPrev, (byte*)pszCmdLine, sw);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WinMain([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] string szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szCmdLine != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szCmdLine);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szCmdLine, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = WinMainNative(hInst, hPrev, pStr0, sw);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestAssertNative([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[1284])(assertCondition, assertDescription);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[1284])(assertCondition, (nint)assertDescription);
			#endif
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			TestAssertNative(assertCondition, assertDescription);
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] in byte assertDescription)
		{
			fixed (byte* passertDescription = &assertDescription)
			{
				TestAssertNative(assertCondition, (byte*)passertDescription);
			}
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> assertDescription)
		{
			fixed (byte* passertDescription = assertDescription)
			{
				TestAssertNative(assertCondition, (byte*)passertDescription);
			}
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] string assertDescription)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (assertDescription != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(assertDescription);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(assertDescription, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestAssertNative(assertCondition, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestAssertCheckNative([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, int>)funcTable[1285])(assertCondition, assertDescription);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[1285])(assertCondition, (nint)assertDescription);
			#endif
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			int ret = TestAssertCheckNative(assertCondition, assertDescription);
			return ret;
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] in byte assertDescription)
		{
			fixed (byte* passertDescription = &assertDescription)
			{
				int ret = TestAssertCheckNative(assertCondition, (byte*)passertDescription);
				return ret;
			}
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> assertDescription)
		{
			fixed (byte* passertDescription = assertDescription)
			{
				int ret = TestAssertCheckNative(assertCondition, (byte*)passertDescription);
				return ret;
			}
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] string assertDescription)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (assertDescription != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(assertDescription);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(assertDescription, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TestAssertCheckNative(assertCondition, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestAssertPassNative([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1286])(assertDescription);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1286])((nint)assertDescription);
			#endif
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			TestAssertPassNative(assertDescription);
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] in byte assertDescription)
		{
			fixed (byte* passertDescription = &assertDescription)
			{
				TestAssertPassNative((byte*)passertDescription);
			}
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> assertDescription)
		{
			fixed (byte* passertDescription = assertDescription)
			{
				TestAssertPassNative((byte*)passertDescription);
			}
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] string assertDescription)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (assertDescription != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(assertDescription);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(assertDescription, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestAssertPassNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Resets the assert summary counters to zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_ResetAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestResetAssertSummaryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1287])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1287])();
			#endif
		}

		/// <summary>
		/// Resets the assert summary counters to zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_ResetAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestResetAssertSummary()
		{
			TestResetAssertSummaryNative();
		}

		/// <summary>
		/// Logs summary of all assertions (total, pass, fail) since last reset as INFO or ERROR.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogAssertSummaryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1288])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1288])();
			#endif
		}

		/// <summary>
		/// Logs summary of all assertions (total, pass, fail) since last reset as INFO or ERROR.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogAssertSummary()
		{
			TestLogAssertSummaryNative();
		}

		/// <summary>
		/// Converts the current assert summary state to a test result.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertSummaryToTestResult")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestAssertSummaryToTestResultNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1289])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1289])();
			#endif
		}

		/// <summary>
		/// Converts the current assert summary state to a test result.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertSummaryToTestResult")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertSummaryToTestResult()
		{
			int ret = TestAssertSummaryToTestResultNative();
			return ret;
		}

		/// <summary>
		/// Parse command line parameters and create common state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonCreateState")]
		[return: NativeName(NativeNameType.Type, "SDLTest_CommonState *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTestCommonState* TestCommonCreateStateNative([NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, uint, SDLTestCommonState*>)funcTable[1290])(argv, flags);
			#else
			return (SDLTestCommonState*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[1290])((nint)argv, flags);
			#endif
		}

		/// <summary>
		/// Parse command line parameters and create common state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonCreateState")]
		[return: NativeName(NativeNameType.Type, "SDLTest_CommonState *")]
		public static SDLTestCommonStatePtr TestCommonCreateState([NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] uint flags)
		{
			SDLTestCommonStatePtr ret = TestCommonCreateStateNative(argv, flags);
			return ret;
		}

		/// <summary>
		/// Parse command line parameters and create common state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonCreateState")]
		[return: NativeName(NativeNameType.Type, "SDLTest_CommonState *")]
		public static SDLTestCommonStatePtr TestCommonCreateState([NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] ref byte* argv, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] uint flags)
		{
			fixed (byte** pargv = &argv)
			{
				SDLTestCommonStatePtr ret = TestCommonCreateStateNative((byte**)pargv, flags);
				return ret;
			}
		}

		/// <summary>
		/// Free the common state object.<br/>
		/// You should call SDL_Quit() before calling this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDestroyState")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonDestroyStateNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, void>)funcTable[1291])(state);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1291])((nint)state);
			#endif
		}

		/// <summary>
		/// Free the common state object.<br/>
		/// You should call SDL_Quit() before calling this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDestroyState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDestroyState([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state)
		{
			TestCommonDestroyStateNative((SDLTestCommonState*)state);
		}

		/// <summary>
		/// Free the common state object.<br/>
		/// You should call SDL_Quit() before calling this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDestroyState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDestroyState([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonDestroyStateNative((SDLTestCommonState*)pstate);
			}
		}

		/// <summary>
		/// Process one common argument.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonArg")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestCommonArgNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, int, int>)funcTable[1292])(state, index);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[1292])((nint)state, index);
			#endif
		}

		/// <summary>
		/// Process one common argument.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonArg")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCommonArg([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			int ret = TestCommonArgNative((SDLTestCommonState*)state, index);
			return ret;
		}

		/// <summary>
		/// Process one common argument.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonArg")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCommonArg([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				int ret = TestCommonArgNative((SDLTestCommonState*)pstate, index);
				return ret;
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonLogUsageNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, byte*, byte**, void>)funcTable[1293])(state, argv0, options);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1293])((nint)state, (nint)argv0, (nint)options);
			#endif
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			TestCommonLogUsageNative((SDLTestCommonState*)state, argv0, options);
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonLogUsageNative((SDLTestCommonState*)pstate, argv0, options);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] in byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (byte* pargv0 = &argv0)
			{
				TestCommonLogUsageNative((SDLTestCommonState*)state, (byte*)pargv0, options);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (byte* pargv0 = argv0)
			{
				TestCommonLogUsageNative((SDLTestCommonState*)state, (byte*)pargv0, options);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argv0 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argv0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestCommonLogUsageNative((SDLTestCommonState*)state, pStr0, options);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] in byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = &argv0)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, options);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = argv0)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, options);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (argv0 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(argv0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestCommonLogUsageNative((SDLTestCommonState*)pstate, pStr0, options);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (byte** poptions = &options)
			{
				TestCommonLogUsageNative((SDLTestCommonState*)state, argv0, (byte**)poptions);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, argv0, (byte**)poptions);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] in byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (byte* pargv0 = &argv0)
			{
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)state, (byte*)pargv0, (byte**)poptions);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (byte* pargv0 = argv0)
			{
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)state, (byte*)pargv0, (byte**)poptions);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argv0 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argv0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** poptions = &options)
			{
				TestCommonLogUsageNative((SDLTestCommonState*)state, pStr0, (byte**)poptions);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] in byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = &argv0)
				{
					fixed (byte** poptions = &options)
					{
						TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, (byte**)poptions);
					}
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = argv0)
				{
					fixed (byte** poptions = &options)
					{
						TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, (byte**)poptions);
					}
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (argv0 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(argv0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, pStr0, (byte**)poptions);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Open test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCommonInitNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, byte>)funcTable[1294])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1294])((nint)state);
			#endif
		}

		/// <summary>
		/// Open test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonInit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state)
		{
			byte ret = TestCommonInitNative((SDLTestCommonState*)state);
			return ret != 0;
		}

		/// <summary>
		/// Open test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonInit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte ret = TestCommonInitNative((SDLTestCommonState*)pstate);
				return ret != 0;
			}
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCommonDefaultArgsNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, int, byte**, byte>)funcTable[1295])(state, argc, argv);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, byte>)funcTable[1295])((nint)state, argc, (nint)argv);
			#endif
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv)
		{
			byte ret = TestCommonDefaultArgsNative((SDLTestCommonState*)state, argc, argv);
			return ret != 0;
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte ret = TestCommonDefaultArgsNative((SDLTestCommonState*)pstate, argc, argv);
				return ret != 0;
			}
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] ref byte* argv)
		{
			fixed (byte** pargv = &argv)
			{
				byte ret = TestCommonDefaultArgsNative((SDLTestCommonState*)state, argc, (byte**)pargv);
				return ret != 0;
			}
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] ref byte* argv)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte** pargv = &argv)
				{
					byte ret = TestCommonDefaultArgsNative((SDLTestCommonState*)pstate, argc, (byte**)pargv);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Print the details of an event.<br/>
		/// This is automatically called by SDLTest_CommonEvent() as needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_PrintEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestPrintEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLEvent*, void>)funcTable[1296])(evnt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1296])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Print the details of an event.<br/>
		/// This is automatically called by SDLTest_CommonEvent() as needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_PrintEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestPrintEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEventPtr evnt)
		{
			TestPrintEventNative((SDLEvent*)evnt);
		}

		/// <summary>
		/// Print the details of an event.<br/>
		/// This is automatically called by SDLTest_CommonEvent() as needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_PrintEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestPrintEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] in SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				TestPrintEventNative((SDLEvent*)pevnt);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonEventNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, SDLEvent*, int*, void>)funcTable[1297])(state, evnt, done);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1297])((nint)state, (nint)evnt, (nint)done);
			#endif
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			TestCommonEventNative((SDLTestCommonState*)state, (SDLEvent*)evnt, done);
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonEventNative((SDLTestCommonState*)pstate, (SDLEvent*)evnt, done);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				TestCommonEventNative((SDLTestCommonState*)state, (SDLEvent*)pevnt, done);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (SDLEvent* pevnt = &evnt)
				{
					TestCommonEventNative((SDLTestCommonState*)pstate, (SDLEvent*)pevnt, done);
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (int* pdone = &done)
			{
				TestCommonEventNative((SDLTestCommonState*)state, (SDLEvent*)evnt, (int*)pdone);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEventPtr evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (int* pdone = &done)
				{
					TestCommonEventNative((SDLTestCommonState*)pstate, (SDLEvent*)evnt, (int*)pdone);
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				fixed (int* pdone = &done)
				{
					TestCommonEventNative((SDLTestCommonState*)state, (SDLEvent*)pevnt, (int*)pdone);
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (SDLEvent* pevnt = &evnt)
				{
					fixed (int* pdone = &done)
					{
						TestCommonEventNative((SDLTestCommonState*)pstate, (SDLEvent*)pevnt, (int*)pdone);
					}
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAppResult TestCommonEventMainCallbacksNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, SDLEvent*, SDLAppResult>)funcTable[1298])(state, evnt);
			#else
			return (SDLAppResult)((delegate* unmanaged[Cdecl]<nint, nint, SDLAppResult>)funcTable[1298])((nint)state, (nint)evnt);
			#endif
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEventPtr evnt)
		{
			SDLAppResult ret = TestCommonEventMainCallbacksNative((SDLTestCommonState*)state, (SDLEvent*)evnt);
			return ret;
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEventPtr evnt)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				SDLAppResult ret = TestCommonEventMainCallbacksNative((SDLTestCommonState*)pstate, (SDLEvent*)evnt);
				return ret;
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] in SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				SDLAppResult ret = TestCommonEventMainCallbacksNative((SDLTestCommonState*)state, (SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] in SDLEvent evnt)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (SDLEvent* pevnt = &evnt)
				{
					SDLAppResult ret = TestCommonEventMainCallbacksNative((SDLTestCommonState*)pstate, (SDLEvent*)pevnt);
					return ret;
				}
			}
		}

		/// <summary>
		/// Close test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonQuitNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, void>)funcTable[1299])(state);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1299])((nint)state);
			#endif
		}

		/// <summary>
		/// Close test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonQuit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonStatePtr state)
		{
			TestCommonQuitNative((SDLTestCommonState*)state);
		}

		/// <summary>
		/// Close test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonQuit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonQuitNative((SDLTestCommonState*)pstate);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonDrawWindowInfoNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLWindow*, float*, void>)funcTable[1300])(renderer, window, usedHeight);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1300])((nint)renderer, (nint)window, (nint)usedHeight);
			#endif
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			TestCommonDrawWindowInfoNative((SDLRenderer*)renderer, (SDLWindow*)window, usedHeight);
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, (SDLWindow*)window, usedHeight);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				TestCommonDrawWindowInfoNative((SDLRenderer*)renderer, (SDLWindow*)pwindow, usedHeight);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, (SDLWindow*)pwindow, usedHeight);
				}
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (float* pusedHeight = &usedHeight)
			{
				TestCommonDrawWindowInfoNative((SDLRenderer*)renderer, (SDLWindow*)window, (float*)pusedHeight);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pusedHeight = &usedHeight)
				{
					TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, (SDLWindow*)window, (float*)pusedHeight);
				}
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pusedHeight = &usedHeight)
				{
					TestCommonDrawWindowInfoNative((SDLRenderer*)renderer, (SDLWindow*)pwindow, (float*)pusedHeight);
				}
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (float* pusedHeight = &usedHeight)
					{
						TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, (SDLWindow*)pwindow, (float*)pusedHeight);
					}
				}
			}
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestCompareSurfacesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLSurface*, int, int>)funcTable[1301])(surface, referenceSurface, allowableError);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[1301])((nint)surface, (nint)referenceSurface, allowableError);
			#endif
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			int ret = TestCompareSurfacesNative((SDLSurface*)surface, (SDLSurface*)referenceSurface, allowableError);
			return ret;
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = TestCompareSurfacesNative((SDLSurface*)psurface, (SDLSurface*)referenceSurface, allowableError);
				return ret;
			}
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* preferenceSurface = &referenceSurface)
			{
				int ret = TestCompareSurfacesNative((SDLSurface*)surface, (SDLSurface*)preferenceSurface, allowableError);
				return ret;
			}
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLSurface* preferenceSurface = &referenceSurface)
				{
					int ret = TestCompareSurfacesNative((SDLSurface*)psurface, (SDLSurface*)preferenceSurface, allowableError);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfacesIgnoreTransparentPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestCompareSurfacesIgnoreTransparentPixelsNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLSurface*, int, int>)funcTable[1302])(surface, referenceSurface, allowableError);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[1302])((nint)surface, (nint)referenceSurface, allowableError);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfacesIgnoreTransparentPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfacesIgnoreTransparentPixels([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			int ret = TestCompareSurfacesIgnoreTransparentPixelsNative((SDLSurface*)surface, (SDLSurface*)referenceSurface, allowableError);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfacesIgnoreTransparentPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfacesIgnoreTransparentPixels([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = TestCompareSurfacesIgnoreTransparentPixelsNative((SDLSurface*)psurface, (SDLSurface*)referenceSurface, allowableError);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfacesIgnoreTransparentPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfacesIgnoreTransparentPixels([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurfacePtr surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* preferenceSurface = &referenceSurface)
			{
				int ret = TestCompareSurfacesIgnoreTransparentPixelsNative((SDLSurface*)surface, (SDLSurface*)preferenceSurface, allowableError);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfacesIgnoreTransparentPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfacesIgnoreTransparentPixels([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLSurface* preferenceSurface = &referenceSurface)
				{
					int ret = TestCompareSurfacesIgnoreTransparentPixelsNative((SDLSurface*)psurface, (SDLSurface*)preferenceSurface, allowableError);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compares 2 memory blocks for equality<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareMemory")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestCompareMemoryNative([NativeName(NativeNameType.Param, "actual")] [NativeName(NativeNameType.Type, "void const *")] void* actual, [NativeName(NativeNameType.Param, "size_actual")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeActual, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "void const *")] void* reference, [NativeName(NativeNameType.Param, "size_reference")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeReference)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, void*, nuint, int>)funcTable[1303])(actual, sizeActual, reference, sizeReference);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nuint, int>)funcTable[1303])((nint)actual, sizeActual, (nint)reference, sizeReference);
			#endif
		}

		/// <summary>
		/// Compares 2 memory blocks for equality<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareMemory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareMemory([NativeName(NativeNameType.Param, "actual")] [NativeName(NativeNameType.Type, "void const *")] void* actual, [NativeName(NativeNameType.Param, "size_actual")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeActual, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "void const *")] void* reference, [NativeName(NativeNameType.Param, "size_reference")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeReference)
		{
			int ret = TestCompareMemoryNative(actual, sizeActual, reference, sizeReference);
			return ret;
		}

		/// <summary>
		/// Compares 2 memory blocks for equality<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareMemory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareMemory([NativeName(NativeNameType.Param, "actual")] [NativeName(NativeNameType.Type, "void const *")] nint actual, [NativeName(NativeNameType.Param, "size_actual")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeActual, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "void const *")] void* reference, [NativeName(NativeNameType.Param, "size_reference")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeReference)
		{
			int ret = TestCompareMemoryNative((void*)actual, sizeActual, reference, sizeReference);
			return ret;
		}

		/// <summary>
		/// Compares 2 memory blocks for equality<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareMemory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareMemory([NativeName(NativeNameType.Param, "actual")] [NativeName(NativeNameType.Type, "void const *")] void* actual, [NativeName(NativeNameType.Param, "size_actual")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeActual, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "void const *")] nint reference, [NativeName(NativeNameType.Param, "size_reference")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeReference)
		{
			int ret = TestCompareMemoryNative(actual, sizeActual, (void*)reference, sizeReference);
			return ret;
		}

		/// <summary>
		/// Compares 2 memory blocks for equality<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareMemory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareMemory([NativeName(NativeNameType.Param, "actual")] [NativeName(NativeNameType.Type, "void const *")] nint actual, [NativeName(NativeNameType.Param, "size_actual")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeActual, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "void const *")] nint reference, [NativeName(NativeNameType.Param, "size_reference")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeReference)
		{
			int ret = TestCompareMemoryNative((void*)actual, sizeActual, (void*)reference, sizeReference);
			return ret;
		}

		/// <summary>
		/// Initialize the CRC context<br/>
		/// Note: The function initializes the crc table required for all crc calculations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32InitNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte>)funcTable[1304])(crcContext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1304])((nint)crcContext);
			#endif
		}

		/// <summary>
		/// Initialize the CRC context<br/>
		/// Note: The function initializes the crc table required for all crc calculations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Init([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext)
		{
			byte ret = TestCrc32InitNative((SDLTestCrc32Context*)crcContext);
			return ret != 0;
		}

		/// <summary>
		/// Initialize the CRC context<br/>
		/// Note: The function initializes the crc table required for all crc calculations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Init([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32InitNative((SDLTestCrc32Context*)pcrcContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte*, uint, uint*, byte>)funcTable[1305])(crcContext, inBuf, inLen, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, byte>)funcTable[1305])((nint)crcContext, (nint)inBuf, inLen, (nint)crc32);
			#endif
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)crcContext, inBuf, inLen, crc32);
			return ret != 0;
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, crc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)crcContext, (byte*)pinBuf, inLen, crc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, crc32);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)crcContext, inBuf, inLen, (uint*)pcrc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)crcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					fixed (uint* pcrc32 = &crc32)
					{
						byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcStartNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, uint*, byte>)funcTable[1306])(crcContext, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1306])((nint)crcContext, (nint)crc32);
			#endif
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcStartNative((SDLTestCrc32Context*)crcContext, crc32);
			return ret != 0;
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcStartNative((SDLTestCrc32Context*)pcrcContext, crc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcStartNative((SDLTestCrc32Context*)crcContext, (uint*)pcrc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcStartNative((SDLTestCrc32Context*)pcrcContext, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcEndNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, uint*, byte>)funcTable[1307])(crcContext, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1307])((nint)crcContext, (nint)crc32);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcEndNative((SDLTestCrc32Context*)crcContext, crc32);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcEndNative((SDLTestCrc32Context*)pcrcContext, crc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcEndNative((SDLTestCrc32Context*)crcContext, (uint*)pcrc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcEndNative((SDLTestCrc32Context*)pcrcContext, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcBufferNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte*, uint, uint*, byte>)funcTable[1308])(crcContext, inBuf, inLen, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, byte>)funcTable[1308])((nint)crcContext, (nint)inBuf, inLen, (nint)crc32);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)crcContext, inBuf, inLen, crc32);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, crc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)crcContext, (byte*)pinBuf, inLen, crc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, crc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)crcContext, inBuf, inLen, (uint*)pcrc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)crcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					fixed (uint* pcrc32 = &crc32)
					{
						byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// clean up CRC context<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Done")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32DoneNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte>)funcTable[1309])(crcContext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1309])((nint)crcContext);
			#endif
		}

		/// <summary>
		/// clean up CRC context<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Done")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Done([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32ContextPtr crcContext)
		{
			byte ret = TestCrc32DoneNative((SDLTestCrc32Context*)crcContext);
			return ret != 0;
		}

		/// <summary>
		/// clean up CRC context<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Done")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Done([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32DoneNative((SDLTestCrc32Context*)pcrcContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a string in the currently set font.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawCharacter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestDrawCharacterNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "Uint32")] uint c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, uint, byte>)funcTable[1310])(renderer, x, y, c);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, uint, byte>)funcTable[1310])((nint)renderer, x, y, c);
			#endif
		}

		/// <summary>
		/// Draw a string in the currently set font.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawCharacter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawCharacter([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "Uint32")] uint c)
		{
			byte ret = TestDrawCharacterNative((SDLRenderer*)renderer, x, y, c);
			return ret != 0;
		}

		/// <summary>
		/// Draw a string in the currently set font.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawCharacter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawCharacter([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "Uint32")] uint c)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = TestDrawCharacterNative((SDLRenderer*)prenderer, x, y, c);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestDrawStringNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] byte* s)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, byte*, byte>)funcTable[1311])(renderer, x, y, s);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, nint, byte>)funcTable[1311])((nint)renderer, x, y, (nint)s);
			#endif
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] byte* s)
		{
			byte ret = TestDrawStringNative((SDLRenderer*)renderer, x, y, s);
			return ret != 0;
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] byte* s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, s);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] in byte s)
		{
			fixed (byte* ps = &s)
			{
				byte ret = TestDrawStringNative((SDLRenderer*)renderer, x, y, (byte*)ps);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s)
		{
			fixed (byte* ps = s)
			{
				byte ret = TestDrawStringNative((SDLRenderer*)renderer, x, y, (byte*)ps);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] string s)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TestDrawStringNative((SDLRenderer*)renderer, x, y, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] in byte s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ps = &s)
				{
					byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, (byte*)ps);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ps = s)
				{
					byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, (byte*)ps);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] string s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (s != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(s);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(s, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowCreate")]
		[return: NativeName(NativeNameType.Type, "SDLTest_TextWindow *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTestTextWindow* TestTextWindowCreateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "float")] float w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, SDLTestTextWindow*>)funcTable[1312])(x, y, w, h);
			#else
			return (SDLTestTextWindow*)((delegate* unmanaged[Cdecl]<float, float, float, float, nint>)funcTable[1312])(x, y, w, h);
			#endif
		}

		/// <summary>
		/// Create a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowCreate")]
		[return: NativeName(NativeNameType.Type, "SDLTest_TextWindow *")]
		public static SDLTestTextWindowPtr TestTextWindowCreate([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "float")] float w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h)
		{
			SDLTestTextWindowPtr ret = TestTextWindowCreateNative(x, y, w, h);
			return ret;
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowDisplayNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, SDLRenderer*, void>)funcTable[1313])(textwin, renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1313])((nint)textwin, (nint)renderer);
			#endif
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer)
		{
			TestTextWindowDisplayNative((SDLTestTextWindow*)textwin, (SDLRenderer*)renderer);
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRendererPtr renderer)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowDisplayNative((SDLTestTextWindow*)ptextwin, (SDLRenderer*)renderer);
			}
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				TestTextWindowDisplayNative((SDLTestTextWindow*)textwin, (SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (SDLRenderer* prenderer = &renderer)
				{
					TestTextWindowDisplayNative((SDLTestTextWindow*)ptextwin, (SDLRenderer*)prenderer);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowAddTextNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, byte*, void>)funcTable[1314])(textwin, fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1314])((nint)textwin, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, fmt);
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, fmt);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] in byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestTextWindowAddTextNative((SDLTestTextWindow*)textwin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] in byte fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* pfmt = &fmt)
				{
					TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* pfmt = fmt)
				{
					TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowAddTextWithLengthNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, byte*, nuint, void>)funcTable[1315])(textwin, text, len);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[1315])((nint)textwin, (nint)text, len);
			#endif
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, text, len);
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, text, len);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] in byte text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (byte* ptext = &text)
			{
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, (byte*)ptext, len);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (byte* ptext = text)
			{
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, (byte*)ptext, len);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)textwin, pStr0, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] in byte text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* ptext = &text)
				{
					TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, (byte*)ptext, len);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* ptext = text)
				{
					TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, (byte*)ptext, len);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, pStr0, len);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Clear the text in a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowClearNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, void>)funcTable[1316])(textwin);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1316])((nint)textwin);
			#endif
		}

		/// <summary>
		/// Clear the text in a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowClear([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin)
		{
			TestTextWindowClearNative((SDLTestTextWindow*)textwin);
		}

		/// <summary>
		/// Clear the text in a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowClear([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowClearNative((SDLTestTextWindow*)ptextwin);
			}
		}

		/// <summary>
		/// Free the storage associated with a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDestroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowDestroyNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, void>)funcTable[1317])(textwin);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1317])((nint)textwin);
			#endif
		}

		/// <summary>
		/// Free the storage associated with a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDestroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDestroy([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindowPtr textwin)
		{
			TestTextWindowDestroyNative((SDLTestTextWindow*)textwin);
		}

		/// <summary>
		/// Free the storage associated with a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDestroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDestroy([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowDestroyNative((SDLTestTextWindow*)ptextwin);
			}
		}

		/// <summary>
		/// Cleanup textures used by font drawing functions.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CleanupTextDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCleanupTextDrawingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1318])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1318])();
			#endif
		}

		/// <summary>
		/// Cleanup textures used by font drawing functions.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CleanupTextDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCleanupTextDrawing()
		{
			TestCleanupTextDrawingNative();
		}

		/// <summary>
		/// Initializes the fuzzer for a test<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_FuzzerInit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestFuzzerInitNative([NativeName(NativeNameType.Param, "execKey")] [NativeName(NativeNameType.Type, "Uint64")] ulong execKey)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1319])(execKey);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1319])(execKey);
			#endif
		}

		/// <summary>
		/// Initializes the fuzzer for a test<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_FuzzerInit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestFuzzerInit([NativeName(NativeNameType.Param, "execKey")] [NativeName(NativeNameType.Type, "Uint64")] ulong execKey)
		{
			TestFuzzerInitNative(execKey);
		}

		/// <summary>
		/// Returns a random Uint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestRandomUint8Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1320])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1320])();
			#endif
		}

		/// <summary>
		/// Returns a random Uint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte TestRandomUint8()
		{
			byte ret = TestRandomUint8Native();
			return ret;
		}

		/// <summary>
		/// Returns a random Sint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint8")]
		[return: NativeName(NativeNameType.Type, "Sint8")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte TestRandomSint8Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte>)funcTable[1321])();
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<sbyte>)funcTable[1321])();
			#endif
		}

		/// <summary>
		/// Returns a random Sint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint8")]
		[return: NativeName(NativeNameType.Type, "Sint8")]
		public static sbyte TestRandomSint8()
		{
			sbyte ret = TestRandomSint8Native();
			return ret;
		}
	}
}
