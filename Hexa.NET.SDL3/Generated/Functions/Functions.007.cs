// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// This function does not fail; if mutex is NULL, it will return immediately<br/>
		/// having locked nothing. If the mutex is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			LockMutexNative(mutex);
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// This function does not fail; if mutex is NULL, it will return immediately<br/>
		/// having locked nothing. If the mutex is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				LockMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// This function returns true if passed a NULL mutex.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLMutex*, byte>)funcTable[236])(mutex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[236])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// This function returns true if passed a NULL mutex.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			byte ret = TryLockMutexNative(mutex);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// This function returns true if passed a NULL mutex.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				byte ret = TryLockMutexNative((SDLMutex*)pmutex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is illegal to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMutex*, void>)funcTable[237])(mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[237])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is illegal to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			UnlockMutexNative(mutex);
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is illegal to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				UnlockMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLMutex*, void>)funcTable[238])(mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[238])((nint)mutex);
			#endif
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			DestroyMutexNative(mutex);
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				DestroyMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Create a new read/write lock.<br/>
		/// A read/write lock is useful for situations where you have multiple threads<br/>
		/// trying to access a resource that is rarely updated. All threads requesting<br/>
		/// a read-only lock will be allowed to run in parallel; if a thread requests a<br/>
		/// write lock, it will be provided exclusive access. This makes it safe for<br/>
		/// multiple threads to use a resource at the same time if they promise not to<br/>
		/// change it, and when it has to be changed, the rwlock will serve as a<br/>
		/// gateway to make sure those changes can be made safely.<br/>
		/// In the right situation, a rwlock can be more efficient than a mutex, which<br/>
		/// only lets a single thread proceed at a time, even if it won't be modifying<br/>
		/// the data.<br/>
		/// All newly-created read/write locks begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not<br/>
		/// return while the rwlock is locked _for writing_ by another thread. See<br/>
		/// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt<br/>
		/// to lock without blocking.<br/>
		/// SDL read/write locks are only recursive for read-only locks! They are not<br/>
		/// guaranteed to be fair, or provide access in a FIFO manner! They are not<br/>
		/// guaranteed to favor writers. You may not lock a rwlock for both read-only<br/>
		/// and write access at the same time from the same thread (so you can't<br/>
		/// promote your read-only lock to a write lock without unlocking first).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRWLock")]
		[return: NativeName(NativeNameType.Type, "SDL_RWLock *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWLock* CreateRWLockNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*>)funcTable[239])();
			#else
			return (SDLRWLock*)((delegate* unmanaged[Cdecl]<nint>)funcTable[239])();
			#endif
		}

		/// <summary>
		/// Create a new read/write lock.<br/>
		/// A read/write lock is useful for situations where you have multiple threads<br/>
		/// trying to access a resource that is rarely updated. All threads requesting<br/>
		/// a read-only lock will be allowed to run in parallel; if a thread requests a<br/>
		/// write lock, it will be provided exclusive access. This makes it safe for<br/>
		/// multiple threads to use a resource at the same time if they promise not to<br/>
		/// change it, and when it has to be changed, the rwlock will serve as a<br/>
		/// gateway to make sure those changes can be made safely.<br/>
		/// In the right situation, a rwlock can be more efficient than a mutex, which<br/>
		/// only lets a single thread proceed at a time, even if it won't be modifying<br/>
		/// the data.<br/>
		/// All newly-created read/write locks begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not<br/>
		/// return while the rwlock is locked _for writing_ by another thread. See<br/>
		/// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt<br/>
		/// to lock without blocking.<br/>
		/// SDL read/write locks are only recursive for read-only locks! They are not<br/>
		/// guaranteed to be fair, or provide access in a FIFO manner! They are not<br/>
		/// guaranteed to favor writers. You may not lock a rwlock for both read-only<br/>
		/// and write access at the same time from the same thread (so you can't<br/>
		/// promote your read-only lock to a write lock without unlocking first).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRWLock")]
		[return: NativeName(NativeNameType.Type, "SDL_RWLock *")]
		public static SDLRWLock* CreateRWLock()
		{
			SDLRWLock* ret = CreateRWLockNative();
			return ret;
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockRWLockForReadingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[240])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[240])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			LockRWLockForReadingNative(rwlock);
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				LockRWLockForReadingNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockRWLockForWritingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[241])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[241])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			LockRWLockForWritingNative(rwlock);
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				LockRWLockForWritingNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockRWLockForReadingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*, byte>)funcTable[242])(rwlock);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[242])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			byte ret = TryLockRWLockForReadingNative(rwlock);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				byte ret = TryLockRWLockForReadingNative((SDLRWLock*)prwlock);
				return ret != 0;
			}
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryLockRWLockForWritingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*, byte>)funcTable[243])(rwlock);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[243])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			byte ret = TryLockRWLockForWritingNative(rwlock);
			return ret != 0;
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, then this function returns false immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function returns true if passed a NULL rwlock.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryLockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				byte ret = TryLockRWLockForWritingNative((SDLRWLock*)prwlock);
				return ret != 0;
			}
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockRWLockNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[244])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[244])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			UnlockRWLockNative(rwlock);
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				UnlockRWLockNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyRWLockNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[245])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[245])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			DestroyRWLockNative(rwlock);
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				DestroyRWLockNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_Semaphore *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSemaphore* CreateSemaphoreNative([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLSemaphore*>)funcTable[246])(initialValue);
			#else
			return (SDLSemaphore*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[246])(initialValue);
			#endif
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_Semaphore *")]
		public static SDLSemaphore* CreateSemaphore([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue)
		{
			SDLSemaphore* ret = CreateSemaphoreNative(initialValue);
			return ret;
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroySemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[247])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[247])((nint)sem);
			#endif
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			DestroySemaphoreNative(sem);
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				DestroySemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until the semaphore pointed to by<br/>
		/// `sem` has a positive value, and then atomically decrement the semaphore<br/>
		/// value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitSemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[248])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[248])((nint)sem);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until the semaphore pointed to by<br/>
		/// `sem` has a positive value, and then atomically decrement the semaphore<br/>
		/// value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			WaitSemaphoreNative(sem);
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until the semaphore pointed to by<br/>
		/// `sem` has a positive value, and then atomically decrement the semaphore<br/>
		/// value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				WaitSemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryWaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TryWaitSemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, byte>)funcTable[249])(sem);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[249])((nint)sem);
			#endif
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryWaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryWaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			byte ret = TryWaitSemaphoreNative(sem);
			return ret != 0;
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns false.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryWaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TryWaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				byte ret = TryWaitSemaphoreNative((SDLSemaphore*)psem);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the specified time has elapsed.<br/>
		/// If the call is successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphoreTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitSemaphoreTimeoutNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int, byte>)funcTable[250])(sem, timeoutMS);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[250])((nint)sem, timeoutMS);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the specified time has elapsed.<br/>
		/// If the call is successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphoreTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitSemaphoreTimeout([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			byte ret = WaitSemaphoreTimeoutNative(sem, timeoutMS);
			return ret != 0;
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the specified time has elapsed.<br/>
		/// If the call is successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphoreTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitSemaphoreTimeout([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				byte ret = WaitSemaphoreTimeoutNative((SDLSemaphore*)psem, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalSemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalSemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[251])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[251])((nint)sem);
			#endif
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalSemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			SignalSemaphoreNative(sem);
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalSemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				SignalSemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSemaphoreValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSemaphoreValueNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, uint>)funcTable[252])(sem);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[252])((nint)sem);
			#endif
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSemaphoreValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetSemaphoreValue([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			uint ret = GetSemaphoreValueNative(sem);
			return ret;
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSemaphoreValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetSemaphoreValue([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				uint ret = GetSemaphoreValueNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCondition")]
		[return: NativeName(NativeNameType.Type, "SDL_Condition *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCondition* CreateConditionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*>)funcTable[253])();
			#else
			return (SDLCondition*)((delegate* unmanaged[Cdecl]<nint>)funcTable[253])();
			#endif
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCondition")]
		[return: NativeName(NativeNameType.Type, "SDL_Condition *")]
		public static SDLCondition* CreateCondition()
		{
			SDLCondition* ret = CreateConditionNative();
			return ret;
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, void>)funcTable[254])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[254])((nint)cond);
			#endif
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			DestroyConditionNative(cond);
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				DestroyConditionNative((SDLCondition*)pcond);
			}
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, void>)funcTable[255])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[255])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			SignalConditionNative(cond);
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				SignalConditionNative((SDLCondition*)pcond);
			}
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BroadcastCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BroadcastConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, void>)funcTable[256])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[256])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BroadcastCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BroadcastCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			BroadcastConditionNative(cond);
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BroadcastCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BroadcastCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				BroadcastConditionNative((SDLCondition*)pcond);
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, SDLMutex*, void>)funcTable[257])(cond, mutex);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[257])((nint)cond, (nint)mutex);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			WaitConditionNative(cond, mutex);
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				WaitConditionNative((SDLCondition*)pcond, mutex);
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				WaitConditionNative(cond, (SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					WaitConditionNative((SDLCondition*)pcond, (SDLMutex*)pmutex);
				}
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitConditionTimeoutNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*, SDLMutex*, int, byte>)funcTable[258])(cond, mutex, timeoutMS);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[258])((nint)cond, (nint)mutex, timeoutMS);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			byte ret = WaitConditionTimeoutNative(cond, mutex, timeoutMS);
			return ret != 0;
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				byte ret = WaitConditionTimeoutNative((SDLCondition*)pcond, mutex, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				byte ret = WaitConditionTimeoutNative(cond, (SDLMutex*)pmutex, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					byte ret = WaitConditionTimeoutNative((SDLCondition*)pcond, (SDLMutex*)pmutex, timeoutMS);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Return whether initialization should be done.<br/>
		/// This function checks the passed in state and if initialization should be<br/>
		/// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.<br/>
		/// If another thread is already modifying this state, it will wait until<br/>
		/// that's done before returning.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShouldInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShouldInitNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] SDLInitState* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitState*, byte>)funcTable[259])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[259])((nint)state);
			#endif
		}

		/// <summary>
		/// Return whether initialization should be done.<br/>
		/// This function checks the passed in state and if initialization should be<br/>
		/// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.<br/>
		/// If another thread is already modifying this state, it will wait until<br/>
		/// that's done before returning.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShouldInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShouldInit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] SDLInitState* state)
		{
			byte ret = ShouldInitNative(state);
			return ret != 0;
		}

		/// <summary>
		/// Return whether initialization should be done.<br/>
		/// This function checks the passed in state and if initialization should be<br/>
		/// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.<br/>
		/// If another thread is already modifying this state, it will wait until<br/>
		/// that's done before returning.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the initialization.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShouldInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShouldInit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] ref SDLInitState state)
		{
			fixed (SDLInitState* pstate = &state)
			{
				byte ret = ShouldInitNative((SDLInitState*)pstate);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether cleanup should be done.<br/>
		/// This function checks the passed in state and if cleanup should be done,<br/>
		/// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the cleanup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShouldQuit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShouldQuitNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] SDLInitState* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitState*, byte>)funcTable[260])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[260])((nint)state);
			#endif
		}

		/// <summary>
		/// Return whether cleanup should be done.<br/>
		/// This function checks the passed in state and if cleanup should be done,<br/>
		/// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the cleanup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShouldQuit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShouldQuit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] SDLInitState* state)
		{
			byte ret = ShouldQuitNative(state);
			return ret != 0;
		}

		/// <summary>
		/// Return whether cleanup should be done.<br/>
		/// This function checks the passed in state and if cleanup should be done,<br/>
		/// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.<br/>
		/// If this function returns true, the calling code must call<br/>
		/// SDL_SetInitialized() to complete the cleanup.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShouldQuit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShouldQuit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] ref SDLInitState state)
		{
			fixed (SDLInitState* pstate = &state)
			{
				byte ret = ShouldQuitNative((SDLInitState*)pstate);
				return ret != 0;
			}
		}

		/// <summary>
		/// Finish an initialization state transition.<br/>
		/// This function sets the status of the passed in state to<br/>
		/// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows<br/>
		/// any threads waiting for the status to proceed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetInitialized")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetInitializedNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] SDLInitState* state, [NativeName(NativeNameType.Param, "initialized")] [NativeName(NativeNameType.Type, "bool")] byte initialized)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLInitState*, byte, void>)funcTable[261])(state, initialized);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[261])((nint)state, initialized);
			#endif
		}

		/// <summary>
		/// Finish an initialization state transition.<br/>
		/// This function sets the status of the passed in state to<br/>
		/// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows<br/>
		/// any threads waiting for the status to proceed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetInitialized")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetInitialized([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] SDLInitState* state, [NativeName(NativeNameType.Param, "initialized")] [NativeName(NativeNameType.Type, "bool")] bool initialized)
		{
			SetInitializedNative(state, initialized ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Finish an initialization state transition.<br/>
		/// This function sets the status of the passed in state to<br/>
		/// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows<br/>
		/// any threads waiting for the status to proceed.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetInitialized")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetInitialized([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDL_InitState *")] ref SDLInitState state, [NativeName(NativeNameType.Param, "initialized")] [NativeName(NativeNameType.Type, "bool")] bool initialized)
		{
			fixed (SDLInitState* pstate = &state)
			{
				SetInitializedNative((SDLInitState*)pstate, initialized ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLIOStream*>)funcTable[262])(file, mode);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[262])((nint)file, (nint)mode);
			#endif
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			SDLIOStream* ret = IOFromFileNative(file, mode);
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLIOStream* ret = IOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = file)
			{
				SDLIOStream* ret = IOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLIOStream* ret = IOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				SDLIOStream* ret = IOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ref byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLIOStream* ret = IOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfile = file)
			{
				fixed (byte* pmode = mode)
				{
					SDLIOStream* ret = IOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
		/// SDL_IOStream is using to access the filesystem.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to make sure the SDL_IOStream never writes to the memory<br/>
		/// buffer, you should use SDL_IOFromConstMem() with a read-only buffer of<br/>
		/// memory instead.<br/>
		/// The following properties will be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that<br/>
		/// was passed to this function.<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter<br/>
		/// that was passed to this function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, SDLIOStream*>)funcTable[263])(mem, size);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[263])((nint)mem, size);
			#endif
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to make sure the SDL_IOStream never writes to the memory<br/>
		/// buffer, you should use SDL_IOFromConstMem() with a read-only buffer of<br/>
		/// memory instead.<br/>
		/// The following properties will be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that<br/>
		/// was passed to this function.<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter<br/>
		/// that was passed to this function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			SDLIOStream* ret = IOFromMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this SDL_IOStream stream will report an error<br/>
		/// without writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_IOFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// The following properties will be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that<br/>
		/// was passed to this function.<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter<br/>
		/// that was passed to this function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromConstMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void const *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, SDLIOStream*>)funcTable[264])(mem, size);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[264])((nint)mem, size);
			#endif
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this SDL_IOStream stream will report an error<br/>
		/// without writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_IOFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// The following properties will be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that<br/>
		/// was passed to this function.<br/>
		/// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter<br/>
		/// that was passed to this function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromConstMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void const *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			SDLIOStream* ret = IOFromConstMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to create an SDL_IOStream that is backed by dynamically<br/>
		/// allocated memory.<br/>
		/// This supports the following properties to provide access to the memory and<br/>
		/// control over allocations:<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal<br/>
		/// memory of the stream. This can be set to NULL to transfer ownership of<br/>
		/// the memory to the application, which should free the memory with<br/>
		/// SDL_free(). If this is done, the next operation on the stream must be<br/>
		/// SDL_CloseIO().<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in<br/>
		/// multiples of this size, defaulting to 1024.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromDynamicMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromDynamicMemNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*>)funcTable[265])();
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint>)funcTable[265])();
			#endif
		}

		/// <summary>
		/// Use this function to create an SDL_IOStream that is backed by dynamically<br/>
		/// allocated memory.<br/>
		/// This supports the following properties to provide access to the memory and<br/>
		/// control over allocations:<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal<br/>
		/// memory of the stream. This can be set to NULL to transfer ownership of<br/>
		/// the memory to the application, which should free the memory with<br/>
		/// SDL_free(). If this is done, the next operation on the stream must be<br/>
		/// SDL_CloseIO().<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in<br/>
		/// multiples of this size, defaulting to 1024.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromDynamicMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromDynamicMem()
		{
			SDLIOStream* ret = IOFromDynamicMemNative();
			return ret;
		}

		/// <summary>
		/// Create a custom SDL_IOStream.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_IOStream implementation. If you just need an SDL_IOStream to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.<br/>
		/// This function makes a copy of `iface` and the caller does not need to keep<br/>
		/// it around after this call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenIO")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* OpenIONative([NativeName(NativeNameType.Param, "iface")] [NativeName(NativeNameType.Type, "SDL_IOStreamInterface const *")] SDLIOStreamInterface* iface, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStreamInterface*, void*, SDLIOStream*>)funcTable[266])(iface, userdata);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[266])((nint)iface, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Create a custom SDL_IOStream.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_IOStream implementation. If you just need an SDL_IOStream to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.<br/>
		/// This function makes a copy of `iface` and the caller does not need to keep<br/>
		/// it around after this call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenIO")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* OpenIO([NativeName(NativeNameType.Param, "iface")] [NativeName(NativeNameType.Type, "SDL_IOStreamInterface const *")] SDLIOStreamInterface* iface, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SDLIOStream* ret = OpenIONative(iface, userdata);
			return ret;
		}

		/// <summary>
		/// Create a custom SDL_IOStream.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_IOStream implementation. If you just need an SDL_IOStream to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.<br/>
		/// This function makes a copy of `iface` and the caller does not need to keep<br/>
		/// it around after this call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenIO")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* OpenIO([NativeName(NativeNameType.Param, "iface")] [NativeName(NativeNameType.Type, "SDL_IOStreamInterface const *")] ref SDLIOStreamInterface iface, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLIOStreamInterface* piface = &iface)
			{
				SDLIOStream* ret = OpenIONative((SDLIOStreamInterface*)piface, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Close and free an allocated SDL_IOStream structure.<br/>
		/// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_IOStream itself. This<br/>
		/// returns true on success, or false if the stream failed to flush to its<br/>
		/// output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream for any reason, this function<br/>
		/// reports an error, but the SDL_IOStream is still invalid once this function<br/>
		/// returns.<br/>
		/// This call flushes any buffered writes to the operating system, but there<br/>
		/// are no guarantees that those writes have gone to physical media; they might<br/>
		/// be in the OS's file cache, waiting to go to disk later. If it's absolutely<br/>
		/// crucial that writes go to disk immediately, so they are definitely stored<br/>
		/// even if the power fails before the file cache would have caught up, one<br/>
		/// should call SDL_FlushIO() before closing. Note that flushing takes time and<br/>
		/// makes the system and your app operate less efficiently, so do so sparingly.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CloseIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[267])(context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[267])((nint)context);
			#endif
		}

		/// <summary>
		/// Close and free an allocated SDL_IOStream structure.<br/>
		/// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_IOStream itself. This<br/>
		/// returns true on success, or false if the stream failed to flush to its<br/>
		/// output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream for any reason, this function<br/>
		/// reports an error, but the SDL_IOStream is still invalid once this function<br/>
		/// returns.<br/>
		/// This call flushes any buffered writes to the operating system, but there<br/>
		/// are no guarantees that those writes have gone to physical media; they might<br/>
		/// be in the OS's file cache, waiting to go to disk later. If it's absolutely<br/>
		/// crucial that writes go to disk immediately, so they are definitely stored<br/>
		/// even if the power fails before the file cache would have caught up, one<br/>
		/// should call SDL_FlushIO() before closing. Note that flushing takes time and<br/>
		/// makes the system and your app operate less efficiently, so do so sparingly.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			byte ret = CloseIONative(context);
			return ret != 0;
		}

		/// <summary>
		/// Close and free an allocated SDL_IOStream structure.<br/>
		/// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_IOStream itself. This<br/>
		/// returns true on success, or false if the stream failed to flush to its<br/>
		/// output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream for any reason, this function<br/>
		/// reports an error, but the SDL_IOStream is still invalid once this function<br/>
		/// returns.<br/>
		/// This call flushes any buffered writes to the operating system, but there<br/>
		/// are no guarantees that those writes have gone to physical media; they might<br/>
		/// be in the OS's file cache, waiting to go to disk later. If it's absolutely<br/>
		/// crucial that writes go to disk immediately, so they are definitely stored<br/>
		/// even if the power fails before the file cache would have caught up, one<br/>
		/// should call SDL_FlushIO() before closing. Note that flushing takes time and<br/>
		/// makes the system and your app operate less efficiently, so do so sparingly.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				byte ret = CloseIONative((SDLIOStream*)pcontext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the properties associated with an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIOPropertiesNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, uint>)funcTable[268])(context);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[268])((nint)context);
			#endif
		}

		/// <summary>
		/// Get the properties associated with an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetIOProperties([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			uint ret = GetIOPropertiesNative(context);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetIOProperties([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				uint ret = GetIOPropertiesNative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Query the stream status of an SDL_IOStream.<br/>
		/// This information can be useful to decide if a short read or write was due<br/>
		/// to an error, an EOF, or a non-blocking operation that isn't yet ready to<br/>
		/// complete.<br/>
		/// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or<br/>
		/// SDL_WriteIO call; don't expect it to change if you just call this query<br/>
		/// function in a tight loop.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStatus")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStatus GetIOStatusNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLIOStatus>)funcTable[269])(context);
			#else
			return (SDLIOStatus)((delegate* unmanaged[Cdecl]<nint, SDLIOStatus>)funcTable[269])((nint)context);
			#endif
		}

		/// <summary>
		/// Query the stream status of an SDL_IOStream.<br/>
		/// This information can be useful to decide if a short read or write was due<br/>
		/// to an error, an EOF, or a non-blocking operation that isn't yet ready to<br/>
		/// complete.<br/>
		/// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or<br/>
		/// SDL_WriteIO call; don't expect it to change if you just call this query<br/>
		/// function in a tight loop.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStatus")]
		public static SDLIOStatus GetIOStatus([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			SDLIOStatus ret = GetIOStatusNative(context);
			return ret;
		}

		/// <summary>
		/// Query the stream status of an SDL_IOStream.<br/>
		/// This information can be useful to decide if a short read or write was due<br/>
		/// to an error, an EOF, or a non-blocking operation that isn't yet ready to<br/>
		/// complete.<br/>
		/// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or<br/>
		/// SDL_WriteIO call; don't expect it to change if you just call this query<br/>
		/// function in a tight loop.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStatus")]
		public static SDLIOStatus GetIOStatus([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				SDLIOStatus ret = GetIOStatusNative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetIOSizeNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long>)funcTable[270])(context);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[270])((nint)context);
			#endif
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetIOSize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			long ret = GetIOSizeNative(context);
			return ret;
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetIOSize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				long ret = GetIOSizeNative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Seek within an SDL_IOStream data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `SDL_IO_SEEK_SET`: seek from the beginning of data<br/>
		/// - `SDL_IO_SEEK_CUR`: seek relative to current read point<br/>
		/// - `SDL_IO_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SeekIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long SeekIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "SDL_IOWhence")] SDLIOWhence whence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long, SDLIOWhence, long>)funcTable[271])(context, offset, whence);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long, SDLIOWhence, long>)funcTable[271])((nint)context, offset, whence);
			#endif
		}

		/// <summary>
		/// Seek within an SDL_IOStream data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `SDL_IO_SEEK_SET`: seek from the beginning of data<br/>
		/// - `SDL_IO_SEEK_CUR`: seek relative to current read point<br/>
		/// - `SDL_IO_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SeekIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SeekIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "SDL_IOWhence")] SDLIOWhence whence)
		{
			long ret = SeekIONative(context, offset, whence);
			return ret;
		}

		/// <summary>
		/// Seek within an SDL_IOStream data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `SDL_IO_SEEK_SET`: seek from the beginning of data<br/>
		/// - `SDL_IO_SEEK_CUR`: seek relative to current read point<br/>
		/// - `SDL_IO_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SeekIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SeekIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "SDL_IOWhence")] SDLIOWhence whence)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				long ret = SeekIONative((SDLIOStream*)pcontext, offset, whence);
				return ret;
			}
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_IOStream data stream.<br/>
		/// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's<br/>
		/// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to<br/>
		/// simplify application development.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TellIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long TellIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long>)funcTable[272])(context);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[272])((nint)context);
			#endif
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_IOStream data stream.<br/>
		/// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's<br/>
		/// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to<br/>
		/// simplify application development.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TellIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long TellIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			long ret = TellIONative(context);
			return ret;
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_IOStream data stream.<br/>
		/// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's<br/>
		/// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to<br/>
		/// simplify application development.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TellIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long TellIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				long ret = TellIONative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up `size` bytes from the data source to the area<br/>
		/// pointed at by `ptr`. This function may read less bytes than requested.<br/>
		/// This function will return zero when the data stream is completely read, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If zero is returned and<br/>
		/// the stream is not at EOF, SDL_GetIOStatus() will return a different error<br/>
		/// value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint ReadIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, void*, nuint, nuint>)funcTable[273])(context, ptr, size);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[273])((nint)context, (nint)ptr, size);
			#endif
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up `size` bytes from the data source to the area<br/>
		/// pointed at by `ptr`. This function may read less bytes than requested.<br/>
		/// This function will return zero when the data stream is completely read, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If zero is returned and<br/>
		/// the stream is not at EOF, SDL_GetIOStatus() will return a different error<br/>
		/// value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint ReadIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			nuint ret = ReadIONative(context, ptr, size);
			return ret;
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up `size` bytes from the data source to the area<br/>
		/// pointed at by `ptr`. This function may read less bytes than requested.<br/>
		/// This function will return zero when the data stream is completely read, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If zero is returned and<br/>
		/// the stream is not at EOF, SDL_GetIOStatus() will return a different error<br/>
		/// value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint ReadIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = ReadIONative((SDLIOStream*)pcontext, ptr, size);
				return ret;
			}
		}

		/// <summary>
		/// Write to an SDL_IOStream data stream.<br/>
		/// This function writes exactly `size` bytes from the area pointed at by `ptr`<br/>
		/// to the stream. If this fails for any reason, it'll return less than `size`<br/>
		/// to demonstrate how far the write progressed. On success, it returns `size`.<br/>
		/// On error, this function still attempts to write as much as possible, so it<br/>
		/// might return a positive value less than the requested write size.<br/>
		/// The caller can use SDL_GetIOStatus() to determine if the problem is<br/>
		/// recoverable, such as a non-blocking write that can simply be retried later,<br/>
		/// or a fatal error.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void const *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, void*, nuint, nuint>)funcTable[274])(context, ptr, size);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[274])((nint)context, (nint)ptr, size);
			#endif
		}

		/// <summary>
		/// Write to an SDL_IOStream data stream.<br/>
		/// This function writes exactly `size` bytes from the area pointed at by `ptr`<br/>
		/// to the stream. If this fails for any reason, it'll return less than `size`<br/>
		/// to demonstrate how far the write progressed. On success, it returns `size`.<br/>
		/// On error, this function still attempts to write as much as possible, so it<br/>
		/// might return a positive value less than the requested write size.<br/>
		/// The caller can use SDL_GetIOStatus() to determine if the problem is<br/>
		/// recoverable, such as a non-blocking write that can simply be retried later,<br/>
		/// or a fatal error.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint WriteIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void const *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			nuint ret = WriteIONative(context, ptr, size);
			return ret;
		}

		/// <summary>
		/// Write to an SDL_IOStream data stream.<br/>
		/// This function writes exactly `size` bytes from the area pointed at by `ptr`<br/>
		/// to the stream. If this fails for any reason, it'll return less than `size`<br/>
		/// to demonstrate how far the write progressed. On success, it returns `size`.<br/>
		/// On error, this function still attempts to write as much as possible, so it<br/>
		/// might return a positive value less than the requested write size.<br/>
		/// The caller can use SDL_GetIOStatus() to determine if the problem is<br/>
		/// recoverable, such as a non-blocking write that can simply be retried later,<br/>
		/// or a fatal error.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint WriteIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void const *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = WriteIONative((SDLIOStream*)pcontext, ptr, size);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint IOprintfNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte*, nuint>)funcTable[275])(context, fmt);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint>)funcTable[275])((nint)context, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			nuint ret = IOprintfNative(context, fmt);
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = IOprintfNative((SDLIOStream*)pcontext, fmt);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				nuint ret = IOprintfNative(context, (byte*)pfmt);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				nuint ret = IOprintfNative(context, (byte*)pfmt);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = IOprintfNative(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = &fmt)
				{
					nuint ret = IOprintfNative((SDLIOStream*)pcontext, (byte*)pfmt);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = fmt)
				{
					nuint ret = IOprintfNative((SDLIOStream*)pcontext, (byte*)pfmt);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				nuint ret = IOprintfNative((SDLIOStream*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint IOvprintfNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte*, nint, nuint>)funcTable[276])(context, fmt, ap);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint>)funcTable[276])((nint)context, (nint)fmt, ap);
			#endif
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			nuint ret = IOvprintfNative(context, fmt, ap);
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = IOvprintfNative((SDLIOStream*)pcontext, fmt, ap);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				nuint ret = IOvprintfNative(context, (byte*)pfmt, ap);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				nuint ret = IOvprintfNative(context, (byte*)pfmt, ap);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = IOvprintfNative(context, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = &fmt)
				{
					nuint ret = IOvprintfNative((SDLIOStream*)pcontext, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = fmt)
				{
					nuint ret = IOvprintfNative((SDLIOStream*)pcontext, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				nuint ret = IOvprintfNative((SDLIOStream*)pcontext, pStr0, ap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Flush any buffered data in the stream.<br/>
		/// This function makes sure that any buffered data is written to the stream.<br/>
		/// Normally this isn't necessary but if the stream is a pipe or socket it<br/>
		/// guarantees that any pending data is sent.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FlushIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[277])(context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[277])((nint)context);
			#endif
		}

		/// <summary>
		/// Flush any buffered data in the stream.<br/>
		/// This function makes sure that any buffered data is written to the stream.<br/>
		/// Normally this isn't necessary but if the stream is a pipe or socket it<br/>
		/// guarantees that any pending data is sent.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlushIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			byte ret = FlushIONative(context);
			return ret != 0;
		}

		/// <summary>
		/// Flush any buffered data in the stream.<br/>
		/// This function makes sure that any buffered data is written to the stream.<br/>
		/// Normally this isn't necessary but if the stream is a pipe or socket it<br/>
		/// guarantees that any pending data is sent.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool FlushIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				byte ret = FlushIONative((SDLIOStream*)pcontext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadFileIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, nuint*, byte, void*>)funcTable[278])(src, datasize, closeio);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, byte, nint>)funcTable[278])((nint)src, (nint)datasize, closeio);
			#endif
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			void* ret = LoadFileIONative(src, datasize, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				void* ret = LoadFileIONative((SDLIOStream*)psrc, datasize, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileIONative(src, (nuint*)pdatasize, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileIONative((SDLIOStream*)psrc, (nuint*)pdatasize, closeio ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint*, void*>)funcTable[279])(file, datasize);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[279])((nint)file, (nint)datasize);
			#endif
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			void* ret = LoadFileNative(file, datasize);
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			fixed (byte* pfile = &file)
			{
				void* ret = LoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			fixed (byte* pfile = file)
			{
				void* ret = LoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = LoadFileNative(pStr0, datasize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileNative(file, (nuint*)pdatasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			fixed (byte* pfile = &file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileNative((byte*)pfile, (nuint*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			fixed (byte* pfile = file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileNative((byte*)pfile, (nuint*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileNative(pStr0, (nuint*)pdatasize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Save all the data into an SDL data stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveFileIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, void*, nuint, byte, byte>)funcTable[280])(src, data, datasize, closeio);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nuint, byte, byte>)funcTable[280])((nint)src, (nint)data, datasize, closeio);
			#endif
		}

		/// <summary>
		/// Save all the data into an SDL data stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			byte ret = SaveFileIONative(src, data, datasize, closeio ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Save all the data into an SDL data stream.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = SaveFileIONative((SDLIOStream*)psrc, data, datasize, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save all the data into a file path.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, nuint, byte>)funcTable[281])(file, data, datasize);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nuint, byte>)funcTable[281])((nint)file, (nint)data, datasize);
			#endif
		}

		/// <summary>
		/// Save all the data into a file path.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize)
		{
			byte ret = SaveFileNative(file, data, datasize);
			return ret != 0;
		}

		/// <summary>
		/// Save all the data into a file path.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SaveFileNative((byte*)pfile, data, datasize);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save all the data into a file path.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SaveFileNative((byte*)pfile, data, datasize);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save all the data into a file path.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t")] nuint datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveFileNative(pStr0, data, datasize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadU8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte*, byte>)funcTable[282])(src, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[282])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* value)
		{
			byte ret = ReadU8Native(src, value);
			return ret != 0;
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = ReadU8Native((SDLIOStream*)psrc, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				byte ret = ReadU8Native(src, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = ReadU8Native((SDLIOStream*)psrc, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadS8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] sbyte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, sbyte*, byte>)funcTable[283])(src, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[283])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] sbyte* value)
		{
			byte ret = ReadS8Native(src, value);
			return ret != 0;
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] sbyte* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = ReadS8Native((SDLIOStream*)psrc, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] ref sbyte value)
		{
			fixed (sbyte* pvalue = &value)
			{
				byte ret = ReadS8Native(src, (sbyte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] ref sbyte value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (sbyte* pvalue = &value)
				{
					byte ret = ReadS8Native((SDLIOStream*)psrc, (sbyte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadU16LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ushort*, byte>)funcTable[284])(src, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[284])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			byte ret = ReadU16LENative(src, value);
			return ret != 0;
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = ReadU16LENative((SDLIOStream*)psrc, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort value)
		{
			fixed (ushort* pvalue = &value)
			{
				byte ret = ReadU16LENative(src, (ushort*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (ushort* pvalue = &value)
				{
					byte ret = ReadU16LENative((SDLIOStream*)psrc, (ushort*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadS16LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, short*, byte>)funcTable[285])(src, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[285])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			byte ret = ReadS16LENative(src, value);
			return ret != 0;
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = ReadS16LENative((SDLIOStream*)psrc, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] ref short value)
		{
			fixed (short* pvalue = &value)
			{
				byte ret = ReadS16LENative(src, (short*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// This function will return false when the data stream is completely read,<br/>
		/// and SDL_GetIOStatus() will return SDL_IO_STATUS_EOF. If false is returned<br/>
		/// and the stream is not at EOF, SDL_GetIOStatus() will return a different<br/>
		/// error value and SDL_GetError() will offer a human-readable message.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] ref short value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (short* pvalue = &value)
				{
					byte ret = ReadS16LENative((SDLIOStream*)psrc, (short*)pvalue);
					return ret != 0;
				}
			}
		}
	}
}
