// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = SetErrorVNative((byte*)pfmt, ap);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetErrorV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetErrorV([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetErrorVNative(pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set an error indicating that memory allocation failed.<br/>
		/// This function does not do any memory allocation.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OutOfMemory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte OutOfMemoryNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[199])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[199])();
			#endif
		}

		/// <summary>
		/// Set an error indicating that memory allocation failed.<br/>
		/// This function does not do any memory allocation.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OutOfMemory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool OutOfMemory()
		{
			byte ret = OutOfMemoryNative();
			return ret != 0;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned value is a thread-local string which will remain valid until<br/>
		/// the current thread's error string is changed. The caller should make a copy<br/>
		/// if the value is needed after the next SDL API call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[200])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[200])();
			#endif
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned value is a thread-local string which will remain valid until<br/>
		/// the current thread's error string is changed. The caller should make a copy<br/>
		/// if the value is needed after the next SDL API call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetError()
		{
			byte* ret = GetErrorNative();
			return ret;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned value is a thread-local string which will remain valid until<br/>
		/// the current thread's error string is changed. The caller should make a copy<br/>
		/// if the value is needed after the next SDL API call.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetErrorS()
		{
			string ret = Utils.DecodeStringUTF8(GetErrorNative());
			return ret;
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[201])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[201])();
			#endif
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearError()
		{
			byte ret = ClearErrorNative();
			return ret != 0;
		}

		/// <summary>
		/// Get the global SDL properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGlobalPropertiesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[202])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[202])();
			#endif
		}

		/// <summary>
		/// Get the global SDL properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetGlobalProperties()
		{
			uint ret = GetGlobalPropertiesNative();
			return ret;
		}

		/// <summary>
		/// Create a group of properties.<br/>
		/// All properties are automatically destroyed when SDL_Quit() is called.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreatePropertiesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[203])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[203])();
			#endif
		}

		/// <summary>
		/// Create a group of properties.<br/>
		/// All properties are automatically destroyed when SDL_Quit() is called.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint CreateProperties()
		{
			uint ret = CreatePropertiesNative();
			return ret;
		}

		/// <summary>
		/// Copy a group of properties.<br/>
		/// Copy all the properties from one group of properties to another, with the<br/>
		/// exception of properties requiring cleanup (set using<br/>
		/// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any<br/>
		/// property that already exists on `dst` will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread. This<br/>
		/// function acquires simultaneous mutex locks on both the source<br/>
		/// and destination property sets.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CopyPropertiesNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint src, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, byte>)funcTable[204])(src, dst);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, uint, byte>)funcTable[204])(src, dst);
			#endif
		}

		/// <summary>
		/// Copy a group of properties.<br/>
		/// Copy all the properties from one group of properties to another, with the<br/>
		/// exception of properties requiring cleanup (set using<br/>
		/// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any<br/>
		/// property that already exists on `dst` will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread. This<br/>
		/// function acquires simultaneous mutex locks on both the source<br/>
		/// and destination property sets.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyProperties([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint src, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dst)
		{
			byte ret = CopyPropertiesNative(src, dst);
			return ret != 0;
		}

		/// <summary>
		/// Lock a group of properties.<br/>
		/// Obtain a multi-threaded lock for these properties. Other threads will wait<br/>
		/// while trying to lock these properties until they are unlocked. Properties<br/>
		/// must be unlocked before they are destroyed.<br/>
		/// The lock is automatically taken when setting individual properties, this<br/>
		/// function is only needed when you want to set several properties atomically<br/>
		/// or want to guarantee that properties being queried aren't freed in another<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LockPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[205])(props);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[205])(props);
			#endif
		}

		/// <summary>
		/// Lock a group of properties.<br/>
		/// Obtain a multi-threaded lock for these properties. Other threads will wait<br/>
		/// while trying to lock these properties until they are unlocked. Properties<br/>
		/// must be unlocked before they are destroyed.<br/>
		/// The lock is automatically taken when setting individual properties, this<br/>
		/// function is only needed when you want to set several properties atomically<br/>
		/// or want to guarantee that properties being queried aren't freed in another<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LockProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			byte ret = LockPropertiesNative(props);
			return ret != 0;
		}

		/// <summary>
		/// Unlock a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[206])(props);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[206])(props);
			#endif
		}

		/// <summary>
		/// Unlock a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			UnlockPropertiesNative(props);
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetPointerPropertyWithCleanupNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, delegate*<void*, void*, void>, void*, byte>)funcTable[207])(props, name, value, cleanup, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, byte>)funcTable[207])(props, (nint)name, (nint)value, (nint)cleanup, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, value, cleanup, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, value, cleanup, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, (void*)value, cleanup, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, cleanup, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, cleanup, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, (void*)value, cleanup, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, value, cleanup, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, value, cleanup, (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, (void*)value, cleanup, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, cleanup, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, cleanup, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] delegate*<void*, void*, void> cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, (void*)value, cleanup, (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = SetPointerPropertyWithCleanupNative(props, name, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyWithCleanupNative(props, pStr0, (void*)value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetPointerPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, byte>)funcTable[208])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[208])(props, (nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			byte ret = SetPointerPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value)
		{
			byte ret = SetPointerPropertyNative(props, name, (void*)value);
			return ret != 0;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetPointerPropertyNative(props, (byte*)pname, (void*)value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetPointerPropertyNative(props, (byte*)pname, (void*)value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] nint value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetPointerPropertyNative(props, pStr0, (void*)value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetStringPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, byte>)funcTable[209])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[209])(props, (nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte ret = SetStringPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetStringPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetStringPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetStringPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value)
		{
			fixed (byte* pvalue = &value)
			{
				byte ret = SetStringPropertyNative(props, name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pvalue = value)
			{
				byte ret = SetStringPropertyNative(props, name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetStringPropertyNative(props, name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] in byte value)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = SetStringPropertyNative(props, (byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetStringPropertyNative(props, (byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetNumberPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, byte>)funcTable[210])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, long, byte>)funcTable[210])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			byte ret = SetNumberPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetNumberPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetFloatPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, byte>)funcTable[211])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, float, byte>)funcTable[211])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			byte ret = SetFloatPropertyNative(props, name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetFloatPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetBooleanPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte, byte>)funcTable[212])(props, name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte, byte>)funcTable[212])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			byte ret = SetBooleanPropertyNative(props, name, value ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetBooleanPropertyNative(props, (byte*)pname, value ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetBooleanPropertyNative(props, (byte*)pname, value ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "bool")] bool value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetBooleanPropertyNative(props, pStr0, value ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte>)funcTable[213])(props, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte>)funcTable[213])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = HasPropertyNative(props, name);
			return ret != 0;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = HasPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = HasPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = HasPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPropertyType GetPropertyTypeNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, SDLPropertyType>)funcTable[214])(props, name);
			#else
			return (SDLPropertyType)((delegate* unmanaged[Cdecl]<uint, nint, SDLPropertyType>)funcTable[214])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			SDLPropertyType ret = GetPropertyTypeNative(props, name);
			return ret;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLPropertyType ret = GetPropertyTypeNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetPointerPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, void*>)funcTable[215])(props, name, defaultValue);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[215])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			void* ret = GetPointerPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			fixed (byte* pname = name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetPointerPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] nint defaultValue)
		{
			void* ret = GetPointerPropertyNative(props, name, (void*)defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] nint defaultValue)
		{
			fixed (byte* pname = &name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, (void*)defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] nint defaultValue)
		{
			fixed (byte* pname = name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, (void*)defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] nint defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetPointerPropertyNative(props, pStr0, (void*)defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, byte*>)funcTable[216])(props, name, defaultValue);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[216])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* ret = GetStringPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, defaultValue));
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, defaultValue));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetNumberPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, long>)funcTable[217])(props, name, defaultValue);
			#else
			return (long)((delegate* unmanaged[Cdecl]<uint, nint, long, long>)funcTable[217])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			long ret = GetNumberPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			fixed (byte* pname = &name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			fixed (byte* pname = name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = GetNumberPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFloatPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, float>)funcTable[218])(props, name, defaultValue);
			#else
			return (float)((delegate* unmanaged[Cdecl]<uint, nint, float, float>)funcTable[218])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			float ret = GetFloatPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			fixed (byte* pname = &name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			fixed (byte* pname = name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			float ret = GetFloatPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetBooleanPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] byte defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte, byte>)funcTable[219])(props, name, defaultValue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte, byte>)funcTable[219])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			byte ret = GetBooleanPropertyNative(props, name, defaultValue ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GetBooleanPropertyNative(props, pStr0, defaultValue ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClearPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte>)funcTable[220])(props, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte>)funcTable[220])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = ClearPropertyNative(props, name);
			return ret != 0;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ClearPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = ClearPropertyNative(props, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ClearPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EnumeratePropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] delegate*<void*, uint, byte*, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void*, uint, byte*, void>, void*, byte>)funcTable[221])(props, callback, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, nint, byte>)funcTable[221])(props, (nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] delegate*<void*, uint, byte*, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = EnumeratePropertiesNative(props, callback, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] SDLEnumeratePropertiesCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = EnumeratePropertiesNative(props, (delegate*<void*, uint, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			return ret != 0;
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] delegate*<void*, uint, byte*, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = EnumeratePropertiesNative(props, callback, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] SDLEnumeratePropertiesCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = EnumeratePropertiesNative(props, (delegate*<void*, uint, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[222])(props);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[222])(props);
			#endif
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			DestroyPropertiesNative(props);
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadRuntimeNative([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, int>, byte*, void*, delegate*<void>, delegate*<void>, SDLThread*>)funcTable[223])(fn, name, data, pfnBeginThread, pfnEndThread);
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint>)funcTable[223])((nint)fn, (nint)name, (nint)data, (nint)pfnBeginThread, (nint)pfnEndThread);
			#endif
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, name, (void*)data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, (void*)data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, pStr0, (void*)data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, (void*)data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, name, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, pStr0, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, name, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, pStr0, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, (void*)data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, name, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, pStr0, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, name, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative(fn, (byte*)pname, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] delegate*<void*, int> fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative(fn, pStr0, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), (byte*)pname, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThreadPtr CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] nint data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] delegate*<void> pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThreadPtr ret = CreateThreadRuntimeNative((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), pStr0, (void*)data, pfnBeginThread, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
