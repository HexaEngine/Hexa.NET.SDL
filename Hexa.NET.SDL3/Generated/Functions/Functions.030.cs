// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		public static SDLTrayEntry** GetTrayEntries([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				SDLTrayEntry** ret = GetTrayEntriesNative((SDLTrayMenu*)pmenu, count);
				return ret;
			}
		}

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		public static SDLTrayEntry** GetTrayEntries([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLTrayEntry** ret = GetTrayEntriesNative(menu, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Returns a list of entries in the menu, in order.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntries")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry const * *")]
		public static SDLTrayEntry** GetTrayEntries([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				fixed (int* pcount = &count)
				{
					SDLTrayEntry** ret = GetTrayEntriesNative((SDLTrayMenu*)pmenu, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Removes a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveTrayEntryNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTrayEntry*, void>)funcTable[1178])(entry);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1178])((nint)entry);
			#endif
		}

		/// <summary>
		/// Removes a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveTrayEntry([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			RemoveTrayEntryNative(entry);
		}

		/// <summary>
		/// Removes a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveTrayEntry([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				RemoveTrayEntryNative((SDLTrayEntry*)pentry);
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayEntry* InsertTrayEntryAtNative([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayMenu*, int, byte*, SDLTrayEntryFlags, SDLTrayEntry*>)funcTable[1179])(menu, pos, label, flags);
			#else
			return (SDLTrayEntry*)((delegate* unmanaged[Cdecl]<nint, int, nint, SDLTrayEntryFlags, nint>)funcTable[1179])((nint)menu, pos, (nint)label, flags);
			#endif
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			SDLTrayEntry* ret = InsertTrayEntryAtNative(menu, pos, label, flags);
			return ret;
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				SDLTrayEntry* ret = InsertTrayEntryAtNative((SDLTrayMenu*)pmenu, pos, label, flags);
				return ret;
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ref byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				SDLTrayEntry* ret = InsertTrayEntryAtNative(menu, pos, (byte*)plabel, flags);
				return ret;
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			fixed (byte* plabel = label)
			{
				SDLTrayEntry* ret = InsertTrayEntryAtNative(menu, pos, (byte*)plabel, flags);
				return ret;
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] string label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTrayEntry* ret = InsertTrayEntryAtNative(menu, pos, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ref byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				fixed (byte* plabel = &label)
				{
					SDLTrayEntry* ret = InsertTrayEntryAtNative((SDLTrayMenu*)pmenu, pos, (byte*)plabel, flags);
					return ret;
				}
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				fixed (byte* plabel = label)
				{
					SDLTrayEntry* ret = InsertTrayEntryAtNative((SDLTrayMenu*)pmenu, pos, (byte*)plabel, flags);
					return ret;
				}
			}
		}

		/// <summary>
		/// Insert a tray entry at a given position.<br/>
		/// If label is NULL, the entry will be a separator. Many functions won't work<br/>
		/// for an entry that is a separator.<br/>
		/// An entry does not need to be destroyed; it will be destroyed with the tray.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertTrayEntryAt")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* InsertTrayEntryAt([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu, [NativeName(NativeNameType.Param, "pos")] [NativeName(NativeNameType.Type, "int")] int pos, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] string label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_TrayEntryFlags")] SDLTrayEntryFlags flags)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTrayEntry* ret = InsertTrayEntryAtNative((SDLTrayMenu*)pmenu, pos, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTrayEntryLabelNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTrayEntry*, byte*, void>)funcTable[1180])(entry, label);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1180])((nint)entry, (nint)label);
			#endif
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label)
		{
			SetTrayEntryLabelNative(entry, label);
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] byte* label)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				SetTrayEntryLabelNative((SDLTrayEntry*)pentry, label);
			}
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				SetTrayEntryLabelNative(entry, (byte*)plabel);
			}
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				SetTrayEntryLabelNative(entry, (byte*)plabel);
			}
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTrayEntryLabelNative(entry, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ref byte label)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				fixed (byte* plabel = &label)
				{
					SetTrayEntryLabelNative((SDLTrayEntry*)pentry, (byte*)plabel);
				}
			}
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> label)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				fixed (byte* plabel = label)
				{
					SetTrayEntryLabelNative((SDLTrayEntry*)pentry, (byte*)plabel);
				}
			}
		}

		/// <summary>
		/// Sets the label of an entry.<br/>
		/// An entry cannot change between a separator and an ordinary entry; that is,<br/>
		/// it is not possible to set a non-NULL label on an entry that has a NULL<br/>
		/// label (separators), or to set a NULL label to an entry that has a non-NULL<br/>
		/// label. The function will silently fail if that happens.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry, [NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "char const *")] string label)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetTrayEntryLabelNative((SDLTrayEntry*)pentry, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Gets the label of an entry.<br/>
		/// If the returned value is NULL, the entry is a separator.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTrayEntryLabelNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayEntry*, byte*>)funcTable[1181])(entry);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1181])((nint)entry);
			#endif
		}

		/// <summary>
		/// Gets the label of an entry.<br/>
		/// If the returned value is NULL, the entry is a separator.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			byte* ret = GetTrayEntryLabelNative(entry);
			return ret;
		}

		/// <summary>
		/// Gets the label of an entry.<br/>
		/// If the returned value is NULL, the entry is a separator.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetTrayEntryLabelS([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			string ret = Utils.DecodeStringUTF8(GetTrayEntryLabelNative(entry));
			return ret;
		}

		/// <summary>
		/// Gets the label of an entry.<br/>
		/// If the returned value is NULL, the entry is a separator.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetTrayEntryLabel([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				byte* ret = GetTrayEntryLabelNative((SDLTrayEntry*)pentry);
				return ret;
			}
		}

		/// <summary>
		/// Gets the label of an entry.<br/>
		/// If the returned value is NULL, the entry is a separator.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryLabel")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetTrayEntryLabelS([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				string ret = Utils.DecodeStringUTF8(GetTrayEntryLabelNative((SDLTrayEntry*)pentry));
				return ret;
			}
		}

		/// <summary>
		/// Sets whether or not an entry is checked.<br/>
		/// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryChecked")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTrayEntryCheckedNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "checked")] [NativeName(NativeNameType.Type, "bool")] byte @checked)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTrayEntry*, byte, void>)funcTable[1182])(entry, @checked);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[1182])((nint)entry, @checked);
			#endif
		}

		/// <summary>
		/// Sets whether or not an entry is checked.<br/>
		/// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryChecked")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryChecked([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "checked")] [NativeName(NativeNameType.Type, "bool")] bool @checked)
		{
			SetTrayEntryCheckedNative(entry, @checked ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether or not an entry is checked.<br/>
		/// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryChecked")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryChecked([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry, [NativeName(NativeNameType.Param, "checked")] [NativeName(NativeNameType.Type, "bool")] bool @checked)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				SetTrayEntryCheckedNative((SDLTrayEntry*)pentry, @checked ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Gets whether or not an entry is checked.<br/>
		/// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryChecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTrayEntryCheckedNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayEntry*, byte>)funcTable[1183])(entry);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1183])((nint)entry);
			#endif
		}

		/// <summary>
		/// Gets whether or not an entry is checked.<br/>
		/// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryChecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTrayEntryChecked([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			byte ret = GetTrayEntryCheckedNative(entry);
			return ret != 0;
		}

		/// <summary>
		/// Gets whether or not an entry is checked.<br/>
		/// The entry must have been created with the SDL_TRAYENTRY_CHECKBOX flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryChecked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTrayEntryChecked([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				byte ret = GetTrayEntryCheckedNative((SDLTrayEntry*)pentry);
				return ret != 0;
			}
		}

		/// <summary>
		/// Sets whether or not an entry is enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTrayEntryEnabledNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTrayEntry*, byte, void>)funcTable[1184])(entry, enabled);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[1184])((nint)entry, enabled);
			#endif
		}

		/// <summary>
		/// Sets whether or not an entry is enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryEnabled([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			SetTrayEntryEnabledNative(entry, enabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Sets whether or not an entry is enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryEnabled([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				SetTrayEntryEnabledNative((SDLTrayEntry*)pentry, enabled ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Gets whether or not an entry is enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTrayEntryEnabledNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayEntry*, byte>)funcTable[1185])(entry);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1185])((nint)entry);
			#endif
		}

		/// <summary>
		/// Gets whether or not an entry is enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTrayEntryEnabled([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			byte ret = GetTrayEntryEnabledNative(entry);
			return ret != 0;
		}

		/// <summary>
		/// Gets whether or not an entry is enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetTrayEntryEnabled([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				byte ret = GetTrayEntryEnabledNative((SDLTrayEntry*)pentry);
				return ret != 0;
			}
		}

		/// <summary>
		/// Sets a callback to be invoked when the entry is selected.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTrayEntryCallbackNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TrayCallback")] SDLTrayCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTrayEntry*, delegate*<void*, SDLTrayEntry*, void>, void*, void>)funcTable[1186])(entry, (delegate*<void*, SDLTrayEntry*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1186])((nint)entry, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Sets a callback to be invoked when the entry is selected.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryCallback([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TrayCallback")] SDLTrayCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetTrayEntryCallbackNative(entry, callback, userdata);
		}

		/// <summary>
		/// Sets a callback to be invoked when the entry is selected.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTrayEntryCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTrayEntryCallback([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TrayCallback")] SDLTrayCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				SetTrayEntryCallbackNative((SDLTrayEntry*)pentry, callback, userdata);
			}
		}

		/// <summary>
		/// Simulate a click on a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClickTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClickTrayEntryNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTrayEntry*, void>)funcTable[1187])(entry);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1187])((nint)entry);
			#endif
		}

		/// <summary>
		/// Simulate a click on a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClickTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ClickTrayEntry([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			ClickTrayEntryNative(entry);
		}

		/// <summary>
		/// Simulate a click on a tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClickTrayEntry")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ClickTrayEntry([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				ClickTrayEntryNative((SDLTrayEntry*)pentry);
			}
		}

		/// <summary>
		/// Destroys a tray object.<br/>
		/// This also destroys all associated menus and entries.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyTray")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyTrayNative([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTray* tray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTray*, void>)funcTable[1188])(tray);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1188])((nint)tray);
			#endif
		}

		/// <summary>
		/// Destroys a tray object.<br/>
		/// This also destroys all associated menus and entries.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyTray")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyTray([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] SDLTray* tray)
		{
			DestroyTrayNative(tray);
		}

		/// <summary>
		/// Destroys a tray object.<br/>
		/// This also destroys all associated menus and entries.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyTray")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyTray([NativeName(NativeNameType.Param, "tray")] [NativeName(NativeNameType.Type, "SDL_Tray *")] ref SDLTray tray)
		{
			fixed (SDLTray* ptray = &tray)
			{
				DestroyTrayNative((SDLTray*)ptray);
			}
		}

		/// <summary>
		/// Gets the menu containing a certain tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryParent")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayMenu* GetTrayEntryParentNative([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayEntry*, SDLTrayMenu*>)funcTable[1189])(entry);
			#else
			return (SDLTrayMenu*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1189])((nint)entry);
			#endif
		}

		/// <summary>
		/// Gets the menu containing a certain tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryParent")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenu* GetTrayEntryParent([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] SDLTrayEntry* entry)
		{
			SDLTrayMenu* ret = GetTrayEntryParentNative(entry);
			return ret;
		}

		/// <summary>
		/// Gets the menu containing a certain tray entry.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayEntryParent")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayMenu *")]
		public static SDLTrayMenu* GetTrayEntryParent([NativeName(NativeNameType.Param, "entry")] [NativeName(NativeNameType.Type, "SDL_TrayEntry *")] ref SDLTrayEntry entry)
		{
			fixed (SDLTrayEntry* pentry = &entry)
			{
				SDLTrayMenu* ret = GetTrayEntryParentNative((SDLTrayEntry*)pentry);
				return ret;
			}
		}

		/// <summary>
		/// Gets the entry for which the menu is a submenu, if the current menu is a<br/>
		/// submenu.<br/>
		/// Either this function or SDL_GetTrayMenuParentTray() will return non-NULL<br/>
		/// for any given menu.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenuParentEntry")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTrayEntry* GetTrayMenuParentEntryNative([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayMenu*, SDLTrayEntry*>)funcTable[1190])(menu);
			#else
			return (SDLTrayEntry*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1190])((nint)menu);
			#endif
		}

		/// <summary>
		/// Gets the entry for which the menu is a submenu, if the current menu is a<br/>
		/// submenu.<br/>
		/// Either this function or SDL_GetTrayMenuParentTray() will return non-NULL<br/>
		/// for any given menu.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenuParentEntry")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* GetTrayMenuParentEntry([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu)
		{
			SDLTrayEntry* ret = GetTrayMenuParentEntryNative(menu);
			return ret;
		}

		/// <summary>
		/// Gets the entry for which the menu is a submenu, if the current menu is a<br/>
		/// submenu.<br/>
		/// Either this function or SDL_GetTrayMenuParentTray() will return non-NULL<br/>
		/// for any given menu.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenuParentEntry")]
		[return: NativeName(NativeNameType.Type, "SDL_TrayEntry *")]
		public static SDLTrayEntry* GetTrayMenuParentEntry([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				SDLTrayEntry* ret = GetTrayMenuParentEntryNative((SDLTrayMenu*)pmenu);
				return ret;
			}
		}

		/// <summary>
		/// Gets the tray for which this menu is the first-level menu, if the current<br/>
		/// menu isn't a submenu.<br/>
		/// Either this function or SDL_GetTrayMenuParentEntry() will return non-NULL<br/>
		/// for any given menu.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenuParentTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTray* GetTrayMenuParentTrayNative([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTrayMenu*, SDLTray*>)funcTable[1191])(menu);
			#else
			return (SDLTray*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1191])((nint)menu);
			#endif
		}

		/// <summary>
		/// Gets the tray for which this menu is the first-level menu, if the current<br/>
		/// menu isn't a submenu.<br/>
		/// Either this function or SDL_GetTrayMenuParentEntry() will return non-NULL<br/>
		/// for any given menu.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenuParentTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTray* GetTrayMenuParentTray([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] SDLTrayMenu* menu)
		{
			SDLTray* ret = GetTrayMenuParentTrayNative(menu);
			return ret;
		}

		/// <summary>
		/// Gets the tray for which this menu is the first-level menu, if the current<br/>
		/// menu isn't a submenu.<br/>
		/// Either this function or SDL_GetTrayMenuParentEntry() will return non-NULL<br/>
		/// for any given menu.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called on the thread that created the<br/>
		/// tray.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTrayMenuParentTray")]
		[return: NativeName(NativeNameType.Type, "SDL_Tray *")]
		public static SDLTray* GetTrayMenuParentTray([NativeName(NativeNameType.Param, "menu")] [NativeName(NativeNameType.Type, "SDL_TrayMenu *")] ref SDLTrayMenu menu)
		{
			fixed (SDLTrayMenu* pmenu = &menu)
			{
				SDLTray* ret = GetTrayMenuParentTrayNative((SDLTrayMenu*)pmenu);
				return ret;
			}
		}

		/// <summary>
		/// Update the trays.<br/>
		/// This is called automatically by the event loop and is only needed if you're<br/>
		/// using trays but aren't handling SDL events.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTrays")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateTraysNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1192])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1192])();
			#endif
		}

		/// <summary>
		/// Update the trays.<br/>
		/// This is called automatically by the event loop and is only needed if you're<br/>
		/// using trays but aren't handling SDL events.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTrays")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateTrays()
		{
			UpdateTraysNative();
		}

		/// <summary>
		/// Get the version of SDL that is linked against your program.<br/>
		/// If you are linking to SDL dynamically, then it is possible that the current<br/>
		/// version will be different than the version you compiled against. This<br/>
		/// function returns the current version, while SDL_VERSION is the version you<br/>
		/// compiled with.<br/>
		/// This function may be called safely at any time, even before SDL_Init().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetVersion")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1193])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1193])();
			#endif
		}

		/// <summary>
		/// Get the version of SDL that is linked against your program.<br/>
		/// If you are linking to SDL dynamically, then it is possible that the current<br/>
		/// version will be different than the version you compiled against. This<br/>
		/// function returns the current version, while SDL_VERSION is the version you<br/>
		/// compiled with.<br/>
		/// This function may be called safely at any time, even before SDL_Init().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetVersion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetVersion()
		{
			int ret = GetVersionNative();
			return ret;
		}

		/// <summary>
		/// Get the code revision of SDL that is linked against your program.<br/>
		/// This value is the revision of the code you are linked with and may be<br/>
		/// different from the code you are compiling with, which is found in the<br/>
		/// constant SDL_REVISION.<br/>
		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
		/// exact revision of the SDL library in use, and is only useful in comparing<br/>
		/// against other revisions. It is NOT an incrementing number.<br/>
		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
		/// will return an empty string.<br/>
		/// You shouldn't use this function for anything but logging it for debugging<br/>
		/// purposes. The string is not intended to be reliable in any way.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRevision")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetRevisionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[1194])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1194])();
			#endif
		}

		/// <summary>
		/// Get the code revision of SDL that is linked against your program.<br/>
		/// This value is the revision of the code you are linked with and may be<br/>
		/// different from the code you are compiling with, which is found in the<br/>
		/// constant SDL_REVISION.<br/>
		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
		/// exact revision of the SDL library in use, and is only useful in comparing<br/>
		/// against other revisions. It is NOT an incrementing number.<br/>
		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
		/// will return an empty string.<br/>
		/// You shouldn't use this function for anything but logging it for debugging<br/>
		/// purposes. The string is not intended to be reliable in any way.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRevision")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetRevision()
		{
			byte* ret = GetRevisionNative();
			return ret;
		}

		/// <summary>
		/// Get the code revision of SDL that is linked against your program.<br/>
		/// This value is the revision of the code you are linked with and may be<br/>
		/// different from the code you are compiling with, which is found in the<br/>
		/// constant SDL_REVISION.<br/>
		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
		/// exact revision of the SDL library in use, and is only useful in comparing<br/>
		/// against other revisions. It is NOT an incrementing number.<br/>
		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
		/// will return an empty string.<br/>
		/// You shouldn't use this function for anything but logging it for debugging<br/>
		/// purposes. The string is not intended to be reliable in any way.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRevision")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetRevisionS()
		{
			string ret = Utils.DecodeStringUTF8(GetRevisionNative());
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglChooseConfigNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, int*, EGLConfig*, int, int*, uint>)funcTable[1195])(dpy, attribList, configs, configSize, numConfig);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, nint, nint, int, nint, uint>)funcTable[1195])(dpy, (nint)attribList, (nint)configs, configSize, (nint)numConfig);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			uint ret = EglChooseConfigNative(dpy, attribList, configs, configSize, numConfig);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				uint ret = EglChooseConfigNative(dpy, (int*)pattribList, configs, configSize, numConfig);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] ref EGLConfig configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			fixed (EGLConfig* pconfigs = &configs)
			{
				uint ret = EglChooseConfigNative(dpy, attribList, (EGLConfig*)pconfigs, configSize, numConfig);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] ref EGLConfig configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (EGLConfig* pconfigs = &configs)
				{
					uint ret = EglChooseConfigNative(dpy, (int*)pattribList, (EGLConfig*)pconfigs, configSize, numConfig);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] ref int numConfig)
		{
			fixed (int* pnumConfig = &numConfig)
			{
				uint ret = EglChooseConfigNative(dpy, attribList, configs, configSize, (int*)pnumConfig);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] ref int numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglChooseConfigNative(dpy, (int*)pattribList, configs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] ref EGLConfig configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] ref int numConfig)
		{
			fixed (EGLConfig* pconfigs = &configs)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglChooseConfigNative(dpy, attribList, (EGLConfig*)pconfigs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "eglChooseConfig")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglChooseConfig([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] ref EGLConfig configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] ref int numConfig)
		{
			fixed (int* pattribList = &attribList)
			{
				fixed (EGLConfig* pconfigs = &configs)
				{
					fixed (int* pnumConfig = &numConfig)
					{
						uint ret = EglChooseConfigNative(dpy, (int*)pattribList, (EGLConfig*)pconfigs, configSize, (int*)pnumConfig);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "eglCopyBuffers")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglCopyBuffersNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "EGLNativePixmapType")] nint target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, nint, uint>)funcTable[1196])(dpy, surface, target);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, nint, uint>)funcTable[1196])(dpy, surface, target);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCopyBuffers")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglCopyBuffers([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "EGLNativePixmapType")] nint target)
		{
			uint ret = EglCopyBuffersNative(dpy, surface, target);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreateContext")]
		[return: NativeName(NativeNameType.Type, "EGLContext")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLContext EglCreateContextNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "share_context")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext shareContext, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, EGLContext, int*, EGLContext>)funcTable[1197])(dpy, config, shareContext, attribList);
			#else
			return (EGLContext)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, EGLContext, nint, EGLContext>)funcTable[1197])(dpy, config, shareContext, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreateContext")]
		[return: NativeName(NativeNameType.Type, "EGLContext")]
		public static EGLContext EglCreateContext([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "share_context")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext shareContext, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			EGLContext ret = EglCreateContextNative(dpy, config, shareContext, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreateContext")]
		[return: NativeName(NativeNameType.Type, "EGLContext")]
		public static EGLContext EglCreateContext([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "share_context")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext shareContext, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				EGLContext ret = EglCreateContextNative(dpy, config, shareContext, (int*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglCreatePbufferSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface EglCreatePbufferSurfaceNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, int*, EGLSurface>)funcTable[1198])(dpy, config, attribList);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, nint, EGLSurface>)funcTable[1198])(dpy, config, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreatePbufferSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePbufferSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			EGLSurface ret = EglCreatePbufferSurfaceNative(dpy, config, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreatePbufferSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePbufferSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				EGLSurface ret = EglCreatePbufferSurfaceNative(dpy, config, (int*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglCreatePixmapSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface EglCreatePixmapSurfaceNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "pixmap")] [NativeName(NativeNameType.Type, "EGLNativePixmapType")] nint pixmap, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, nint, int*, EGLSurface>)funcTable[1199])(dpy, config, pixmap, attribList);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, nint, nint, EGLSurface>)funcTable[1199])(dpy, config, pixmap, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreatePixmapSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePixmapSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "pixmap")] [NativeName(NativeNameType.Type, "EGLNativePixmapType")] nint pixmap, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			EGLSurface ret = EglCreatePixmapSurfaceNative(dpy, config, pixmap, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreatePixmapSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePixmapSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "pixmap")] [NativeName(NativeNameType.Type, "EGLNativePixmapType")] nint pixmap, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				EGLSurface ret = EglCreatePixmapSurfaceNative(dpy, config, pixmap, (int*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglCreateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface EglCreateWindowSurfaceNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "win")] [NativeName(NativeNameType.Type, "EGLNativeWindowType")] nint win, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, nint, int*, EGLSurface>)funcTable[1200])(dpy, config, win, attribList);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, nint, nint, EGLSurface>)funcTable[1200])(dpy, config, win, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreateWindowSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "win")] [NativeName(NativeNameType.Type, "EGLNativeWindowType")] nint win, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			EGLSurface ret = EglCreateWindowSurfaceNative(dpy, config, win, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreateWindowSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "win")] [NativeName(NativeNameType.Type, "EGLNativeWindowType")] nint win, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				EGLSurface ret = EglCreateWindowSurfaceNative(dpy, config, win, (int*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglDestroyContext")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroyContextNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLContext, uint>)funcTable[1201])(dpy, ctx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLContext, uint>)funcTable[1201])(dpy, ctx);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglDestroyContext")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglDestroyContext([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx)
		{
			uint ret = EglDestroyContextNative(dpy, ctx);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglDestroySurface")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroySurfaceNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, uint>)funcTable[1202])(dpy, surface);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, uint>)funcTable[1202])(dpy, surface);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglDestroySurface")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglDestroySurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface)
		{
			uint ret = EglDestroySurfaceNative(dpy, surface);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetConfigAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglGetConfigAttribNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, int, int*, uint>)funcTable[1203])(dpy, config, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, int, nint, uint>)funcTable[1203])(dpy, config, attribute, (nint)value);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetConfigAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetConfigAttrib([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] int* value)
		{
			uint ret = EglGetConfigAttribNative(dpy, config, attribute, value);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetConfigAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetConfigAttrib([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglGetConfigAttribNative(dpy, config, attribute, (int*)pvalue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglGetConfigs")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglGetConfigsNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig*, int, int*, uint>)funcTable[1204])(dpy, configs, configSize, numConfig);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, nint, int, nint, uint>)funcTable[1204])(dpy, (nint)configs, configSize, (nint)numConfig);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetConfigs")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetConfigs([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			uint ret = EglGetConfigsNative(dpy, configs, configSize, numConfig);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetConfigs")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetConfigs([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] ref EGLConfig configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] int* numConfig)
		{
			fixed (EGLConfig* pconfigs = &configs)
			{
				uint ret = EglGetConfigsNative(dpy, (EGLConfig*)pconfigs, configSize, numConfig);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglGetConfigs")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetConfigs([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] EGLConfig* configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] ref int numConfig)
		{
			fixed (int* pnumConfig = &numConfig)
			{
				uint ret = EglGetConfigsNative(dpy, configs, configSize, (int*)pnumConfig);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglGetConfigs")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetConfigs([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "configs")] [NativeName(NativeNameType.Type, "EGLConfig *")] ref EGLConfig configs, [NativeName(NativeNameType.Param, "config_size")] [NativeName(NativeNameType.Type, "EGLint")] int configSize, [NativeName(NativeNameType.Param, "num_config")] [NativeName(NativeNameType.Type, "EGLint *")] ref int numConfig)
		{
			fixed (EGLConfig* pconfigs = &configs)
			{
				fixed (int* pnumConfig = &numConfig)
				{
					uint ret = EglGetConfigsNative(dpy, (EGLConfig*)pconfigs, configSize, (int*)pnumConfig);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "eglGetCurrentDisplay")]
		[return: NativeName(NativeNameType.Type, "EGLDisplay")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLDisplay EglGetCurrentDisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay>)funcTable[1205])();
			#else
			return (EGLDisplay)((delegate* unmanaged[Cdecl]<EGLDisplay>)funcTable[1205])();
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetCurrentDisplay")]
		[return: NativeName(NativeNameType.Type, "EGLDisplay")]
		public static EGLDisplay EglGetCurrentDisplay()
		{
			EGLDisplay ret = EglGetCurrentDisplayNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetCurrentSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface EglGetCurrentSurfaceNative([NativeName(NativeNameType.Param, "readdraw")] [NativeName(NativeNameType.Type, "EGLint")] int readdraw)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, EGLSurface>)funcTable[1206])(readdraw);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<int, EGLSurface>)funcTable[1206])(readdraw);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetCurrentSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglGetCurrentSurface([NativeName(NativeNameType.Param, "readdraw")] [NativeName(NativeNameType.Type, "EGLint")] int readdraw)
		{
			EGLSurface ret = EglGetCurrentSurfaceNative(readdraw);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetDisplay")]
		[return: NativeName(NativeNameType.Type, "EGLDisplay")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLDisplay EglGetDisplayNative([NativeName(NativeNameType.Param, "display_id")] [NativeName(NativeNameType.Type, "EGLNativeDisplayType")] nint displayId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nint, EGLDisplay>)funcTable[1207])(displayId);
			#else
			return (EGLDisplay)((delegate* unmanaged[Cdecl]<nint, EGLDisplay>)funcTable[1207])(displayId);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetDisplay")]
		[return: NativeName(NativeNameType.Type, "EGLDisplay")]
		public static EGLDisplay EglGetDisplay([NativeName(NativeNameType.Param, "display_id")] [NativeName(NativeNameType.Type, "EGLNativeDisplayType")] nint displayId)
		{
			EGLDisplay ret = EglGetDisplayNative(displayId);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetError")]
		[return: NativeName(NativeNameType.Type, "EGLint")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EglGetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1208])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1208])();
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetError")]
		[return: NativeName(NativeNameType.Type, "EGLint")]
		public static int EglGetError()
		{
			int ret = EglGetErrorNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "__eglMustCastToProperFunctionPointerType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> EglGetProcAddressNative([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "char const *")] byte* procname)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[1209])(procname);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1209])((nint)procname);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "__eglMustCastToProperFunctionPointerType")]
		public static delegate*<void> EglGetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "char const *")] byte* procname)
		{
			delegate*<void> ret = EglGetProcAddressNative(procname);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "__eglMustCastToProperFunctionPointerType")]
		public static delegate*<void> EglGetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "char const *")] ref byte procname)
		{
			fixed (byte* pprocname = &procname)
			{
				delegate*<void> ret = EglGetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "__eglMustCastToProperFunctionPointerType")]
		public static delegate*<void> EglGetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> procname)
		{
			fixed (byte* pprocname = procname)
			{
				delegate*<void> ret = EglGetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "__eglMustCastToProperFunctionPointerType")]
		public static delegate*<void> EglGetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "char const *")] string procname)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (procname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(procname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(procname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = EglGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglInitialize")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglInitializeNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "major")] [NativeName(NativeNameType.Type, "EGLint *")] int* major, [NativeName(NativeNameType.Param, "minor")] [NativeName(NativeNameType.Type, "EGLint *")] int* minor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, int*, int*, uint>)funcTable[1210])(dpy, major, minor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, nint, nint, uint>)funcTable[1210])(dpy, (nint)major, (nint)minor);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglInitialize")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglInitialize([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "major")] [NativeName(NativeNameType.Type, "EGLint *")] int* major, [NativeName(NativeNameType.Param, "minor")] [NativeName(NativeNameType.Type, "EGLint *")] int* minor)
		{
			uint ret = EglInitializeNative(dpy, major, minor);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglInitialize")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglInitialize([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "major")] [NativeName(NativeNameType.Type, "EGLint *")] ref int major, [NativeName(NativeNameType.Param, "minor")] [NativeName(NativeNameType.Type, "EGLint *")] int* minor)
		{
			fixed (int* pmajor = &major)
			{
				uint ret = EglInitializeNative(dpy, (int*)pmajor, minor);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglInitialize")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglInitialize([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "major")] [NativeName(NativeNameType.Type, "EGLint *")] int* major, [NativeName(NativeNameType.Param, "minor")] [NativeName(NativeNameType.Type, "EGLint *")] ref int minor)
		{
			fixed (int* pminor = &minor)
			{
				uint ret = EglInitializeNative(dpy, major, (int*)pminor);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglInitialize")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglInitialize([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "major")] [NativeName(NativeNameType.Type, "EGLint *")] ref int major, [NativeName(NativeNameType.Param, "minor")] [NativeName(NativeNameType.Type, "EGLint *")] ref int minor)
		{
			fixed (int* pmajor = &major)
			{
				fixed (int* pminor = &minor)
				{
					uint ret = EglInitializeNative(dpy, (int*)pmajor, (int*)pminor);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "eglMakeCurrent")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglMakeCurrentNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "draw")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface draw, [NativeName(NativeNameType.Param, "read")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface read, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, EGLSurface, EGLContext, uint>)funcTable[1211])(dpy, draw, read, ctx);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, EGLSurface, EGLContext, uint>)funcTable[1211])(dpy, draw, read, ctx);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglMakeCurrent")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglMakeCurrent([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "draw")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface draw, [NativeName(NativeNameType.Param, "read")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface read, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx)
		{
			uint ret = EglMakeCurrentNative(dpy, draw, read, ctx);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglQueryContext")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglQueryContextNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLContext, int, int*, uint>)funcTable[1212])(dpy, ctx, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLContext, int, nint, uint>)funcTable[1212])(dpy, ctx, attribute, (nint)value);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglQueryContext")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglQueryContext([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] int* value)
		{
			uint ret = EglQueryContextNative(dpy, ctx, attribute, value);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglQueryContext")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglQueryContext([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQueryContextNative(dpy, ctx, attribute, (int*)pvalue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglQueryString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* EglQueryStringNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "EGLint")] int name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, int, byte*>)funcTable[1213])(dpy, name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<EGLDisplay, int, nint>)funcTable[1213])(dpy, name);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglQueryString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* EglQueryString([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "EGLint")] int name)
		{
			byte* ret = EglQueryStringNative(dpy, name);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglQueryString")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string EglQueryStringS([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "EGLint")] int name)
		{
			string ret = Utils.DecodeStringUTF8(EglQueryStringNative(dpy, name));
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglQuerySurface")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglQuerySurfaceNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, int*, uint>)funcTable[1214])(dpy, surface, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, nint, uint>)funcTable[1214])(dpy, surface, attribute, (nint)value);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglQuerySurface")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglQuerySurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] int* value)
		{
			uint ret = EglQuerySurfaceNative(dpy, surface, attribute, value);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglQuerySurface")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglQuerySurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint *")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				uint ret = EglQuerySurfaceNative(dpy, surface, attribute, (int*)pvalue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglSwapBuffers")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglSwapBuffersNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, uint>)funcTable[1215])(dpy, surface);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, uint>)funcTable[1215])(dpy, surface);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglSwapBuffers")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglSwapBuffers([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface)
		{
			uint ret = EglSwapBuffersNative(dpy, surface);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglTerminate")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglTerminateNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, uint>)funcTable[1216])(dpy);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, uint>)funcTable[1216])(dpy);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglTerminate")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglTerminate([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy)
		{
			uint ret = EglTerminateNative(dpy);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglWaitGL")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitGLNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1217])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1217])();
			#endif
		}

		[NativeName(NativeNameType.Func, "eglWaitGL")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglWaitGL()
		{
			uint ret = EglWaitGLNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglWaitNative")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitNativeNative([NativeName(NativeNameType.Param, "engine")] [NativeName(NativeNameType.Type, "EGLint")] int engine)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[1218])(engine);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[1218])(engine);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglWaitNative")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglWaitNative([NativeName(NativeNameType.Param, "engine")] [NativeName(NativeNameType.Type, "EGLint")] int engine)
		{
			uint ret = EglWaitNativeNative(engine);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglBindTexImage")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglBindTexImageNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLint")] int buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, uint>)funcTable[1219])(dpy, surface, buffer);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, uint>)funcTable[1219])(dpy, surface, buffer);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglBindTexImage")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglBindTexImage([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLint")] int buffer)
		{
			uint ret = EglBindTexImageNative(dpy, surface, buffer);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglReleaseTexImage")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglReleaseTexImageNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLint")] int buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, uint>)funcTable[1220])(dpy, surface, buffer);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, uint>)funcTable[1220])(dpy, surface, buffer);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglReleaseTexImage")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglReleaseTexImage([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLint")] int buffer)
		{
			uint ret = EglReleaseTexImageNative(dpy, surface, buffer);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglSurfaceAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglSurfaceAttribNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint")] int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, int, uint>)funcTable[1221])(dpy, surface, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSurface, int, int, uint>)funcTable[1221])(dpy, surface, attribute, value);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglSurfaceAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglSurfaceAttrib([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "EGLSurface")] EGLSurface surface, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLint")] int value)
		{
			uint ret = EglSurfaceAttribNative(dpy, surface, attribute, value);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglSwapInterval")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglSwapIntervalNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "EGLint")] int interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, int, uint>)funcTable[1222])(dpy, interval);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, int, uint>)funcTable[1222])(dpy, interval);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglSwapInterval")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglSwapInterval([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "EGLint")] int interval)
		{
			uint ret = EglSwapIntervalNative(dpy, interval);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglBindAPI")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglBindAPINative([NativeName(NativeNameType.Param, "api")] [NativeName(NativeNameType.Type, "EGLenum")] uint api)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[1223])(api);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[1223])(api);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglBindAPI")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglBindAPI([NativeName(NativeNameType.Param, "api")] [NativeName(NativeNameType.Type, "EGLenum")] uint api)
		{
			uint ret = EglBindAPINative(api);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglQueryAPI")]
		[return: NativeName(NativeNameType.Type, "EGLenum")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglQueryAPINative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1224])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1224])();
			#endif
		}

		[NativeName(NativeNameType.Func, "eglQueryAPI")]
		[return: NativeName(NativeNameType.Type, "EGLenum")]
		public static uint EglQueryAPI()
		{
			uint ret = EglQueryAPINative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreatePbufferFromClientBuffer")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface EglCreatePbufferFromClientBufferNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "buftype")] [NativeName(NativeNameType.Type, "EGLenum")] uint buftype, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLClientBuffer")] EGLClientBuffer buffer, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, uint, EGLClientBuffer, EGLConfig, int*, EGLSurface>)funcTable[1225])(dpy, buftype, buffer, config, attribList);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<EGLDisplay, uint, EGLClientBuffer, EGLConfig, nint, EGLSurface>)funcTable[1225])(dpy, buftype, buffer, config, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreatePbufferFromClientBuffer")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePbufferFromClientBuffer([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "buftype")] [NativeName(NativeNameType.Type, "EGLenum")] uint buftype, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLClientBuffer")] EGLClientBuffer buffer, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] int* attribList)
		{
			EGLSurface ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, buffer, config, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreatePbufferFromClientBuffer")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePbufferFromClientBuffer([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "buftype")] [NativeName(NativeNameType.Type, "EGLenum")] uint buftype, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLClientBuffer")] EGLClientBuffer buffer, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLint const *")] ref int attribList)
		{
			fixed (int* pattribList = &attribList)
			{
				EGLSurface ret = EglCreatePbufferFromClientBufferNative(dpy, buftype, buffer, config, (int*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglReleaseThread")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglReleaseThreadNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1226])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1226])();
			#endif
		}

		[NativeName(NativeNameType.Func, "eglReleaseThread")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglReleaseThread()
		{
			uint ret = EglReleaseThreadNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglWaitClient")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitClientNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1227])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1227])();
			#endif
		}

		[NativeName(NativeNameType.Func, "eglWaitClient")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglWaitClient()
		{
			uint ret = EglWaitClientNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "EGLContext")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLContext EglGetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLContext>)funcTable[1228])();
			#else
			return (EGLContext)((delegate* unmanaged[Cdecl]<EGLContext>)funcTable[1228])();
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "EGLContext")]
		public static EGLContext EglGetCurrentContext()
		{
			EGLContext ret = EglGetCurrentContextNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreateSync")]
		[return: NativeName(NativeNameType.Type, "EGLSync")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSync EglCreateSyncNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "EGLenum")] uint type, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, uint, nint*, EGLSync>)funcTable[1229])(dpy, type, attribList);
			#else
			return (EGLSync)((delegate* unmanaged[Cdecl]<EGLDisplay, uint, nint, EGLSync>)funcTable[1229])(dpy, type, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreateSync")]
		[return: NativeName(NativeNameType.Type, "EGLSync")]
		public static EGLSync EglCreateSync([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "EGLenum")] uint type, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			EGLSync ret = EglCreateSyncNative(dpy, type, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreateSync")]
		[return: NativeName(NativeNameType.Type, "EGLSync")]
		public static EGLSync EglCreateSync([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "EGLenum")] uint type, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] ref nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				EGLSync ret = EglCreateSyncNative(dpy, type, (nint*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglDestroySync")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroySyncNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, uint>)funcTable[1230])(dpy, sync);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, uint>)funcTable[1230])(dpy, sync);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglDestroySync")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglDestroySync([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync)
		{
			uint ret = EglDestroySyncNative(dpy, sync);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglClientWaitSync")]
		[return: NativeName(NativeNameType.Type, "EGLint")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EglClientWaitSyncNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "EGLint")] int flags, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "EGLTime")] ulong timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, int, ulong, int>)funcTable[1231])(dpy, sync, flags, timeout);
			#else
			return (int)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, int, ulong, int>)funcTable[1231])(dpy, sync, flags, timeout);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglClientWaitSync")]
		[return: NativeName(NativeNameType.Type, "EGLint")]
		public static int EglClientWaitSync([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "EGLint")] int flags, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "EGLTime")] ulong timeout)
		{
			int ret = EglClientWaitSyncNative(dpy, sync, flags, timeout);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetSyncAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglGetSyncAttribNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLAttrib *")] nint* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, int, nint*, uint>)funcTable[1232])(dpy, sync, attribute, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, int, nint, uint>)funcTable[1232])(dpy, sync, attribute, (nint)value);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetSyncAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetSyncAttrib([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLAttrib *")] nint* value)
		{
			uint ret = EglGetSyncAttribNative(dpy, sync, attribute, value);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetSyncAttrib")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglGetSyncAttrib([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync, [NativeName(NativeNameType.Param, "attribute")] [NativeName(NativeNameType.Type, "EGLint")] int attribute, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "EGLAttrib *")] ref nint value)
		{
			fixed (nint* pvalue = &value)
			{
				uint ret = EglGetSyncAttribNative(dpy, sync, attribute, (nint*)pvalue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglCreateImage")]
		[return: NativeName(NativeNameType.Type, "EGLImage")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLImage EglCreateImageNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "EGLenum")] uint target, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLClientBuffer")] EGLClientBuffer buffer, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLContext, uint, EGLClientBuffer, nint*, EGLImage>)funcTable[1233])(dpy, ctx, target, buffer, attribList);
			#else
			return (EGLImage)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLContext, uint, EGLClientBuffer, nint, EGLImage>)funcTable[1233])(dpy, ctx, target, buffer, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreateImage")]
		[return: NativeName(NativeNameType.Type, "EGLImage")]
		public static EGLImage EglCreateImage([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "EGLenum")] uint target, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLClientBuffer")] EGLClientBuffer buffer, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			EGLImage ret = EglCreateImageNative(dpy, ctx, target, buffer, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreateImage")]
		[return: NativeName(NativeNameType.Type, "EGLImage")]
		public static EGLImage EglCreateImage([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "ctx")] [NativeName(NativeNameType.Type, "EGLContext")] EGLContext ctx, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "EGLenum")] uint target, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "EGLClientBuffer")] EGLClientBuffer buffer, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] ref nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				EGLImage ret = EglCreateImageNative(dpy, ctx, target, buffer, (nint*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglDestroyImage")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglDestroyImageNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "EGLImage")] EGLImage image)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLImage, uint>)funcTable[1234])(dpy, image);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLImage, uint>)funcTable[1234])(dpy, image);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglDestroyImage")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglDestroyImage([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "EGLImage")] EGLImage image)
		{
			uint ret = EglDestroyImageNative(dpy, image);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetPlatformDisplay")]
		[return: NativeName(NativeNameType.Type, "EGLDisplay")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLDisplay EglGetPlatformDisplayNative([NativeName(NativeNameType.Param, "platform")] [NativeName(NativeNameType.Type, "EGLenum")] uint platform, [NativeName(NativeNameType.Param, "native_display")] [NativeName(NativeNameType.Type, "void *")] void* nativeDisplay, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, void*, nint*, EGLDisplay>)funcTable[1235])(platform, nativeDisplay, attribList);
			#else
			return (EGLDisplay)((delegate* unmanaged[Cdecl]<uint, nint, nint, EGLDisplay>)funcTable[1235])(platform, (nint)nativeDisplay, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglGetPlatformDisplay")]
		[return: NativeName(NativeNameType.Type, "EGLDisplay")]
		public static EGLDisplay EglGetPlatformDisplay([NativeName(NativeNameType.Param, "platform")] [NativeName(NativeNameType.Type, "EGLenum")] uint platform, [NativeName(NativeNameType.Param, "native_display")] [NativeName(NativeNameType.Type, "void *")] void* nativeDisplay, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			EGLDisplay ret = EglGetPlatformDisplayNative(platform, nativeDisplay, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglGetPlatformDisplay")]
		[return: NativeName(NativeNameType.Type, "EGLDisplay")]
		public static EGLDisplay EglGetPlatformDisplay([NativeName(NativeNameType.Param, "platform")] [NativeName(NativeNameType.Type, "EGLenum")] uint platform, [NativeName(NativeNameType.Param, "native_display")] [NativeName(NativeNameType.Type, "void *")] void* nativeDisplay, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] ref nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				EGLDisplay ret = EglGetPlatformDisplayNative(platform, nativeDisplay, (nint*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglCreatePlatformWindowSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface EglCreatePlatformWindowSurfaceNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "native_window")] [NativeName(NativeNameType.Type, "void *")] void* nativeWindow, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, void*, nint*, EGLSurface>)funcTable[1236])(dpy, config, nativeWindow, attribList);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, nint, nint, EGLSurface>)funcTable[1236])(dpy, config, (nint)nativeWindow, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreatePlatformWindowSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePlatformWindowSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "native_window")] [NativeName(NativeNameType.Type, "void *")] void* nativeWindow, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			EGLSurface ret = EglCreatePlatformWindowSurfaceNative(dpy, config, nativeWindow, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreatePlatformWindowSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePlatformWindowSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "native_window")] [NativeName(NativeNameType.Type, "void *")] void* nativeWindow, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] ref nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				EGLSurface ret = EglCreatePlatformWindowSurfaceNative(dpy, config, nativeWindow, (nint*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglCreatePlatformPixmapSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface EglCreatePlatformPixmapSurfaceNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "native_pixmap")] [NativeName(NativeNameType.Type, "void *")] void* nativePixmap, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, void*, nint*, EGLSurface>)funcTable[1237])(dpy, config, nativePixmap, attribList);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLConfig, nint, nint, EGLSurface>)funcTable[1237])(dpy, config, (nint)nativePixmap, (nint)attribList);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglCreatePlatformPixmapSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePlatformPixmapSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "native_pixmap")] [NativeName(NativeNameType.Type, "void *")] void* nativePixmap, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] nint* attribList)
		{
			EGLSurface ret = EglCreatePlatformPixmapSurfaceNative(dpy, config, nativePixmap, attribList);
			return ret;
		}

		[NativeName(NativeNameType.Func, "eglCreatePlatformPixmapSurface")]
		[return: NativeName(NativeNameType.Type, "EGLSurface")]
		public static EGLSurface EglCreatePlatformPixmapSurface([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "config")] [NativeName(NativeNameType.Type, "EGLConfig")] EGLConfig config, [NativeName(NativeNameType.Param, "native_pixmap")] [NativeName(NativeNameType.Type, "void *")] void* nativePixmap, [NativeName(NativeNameType.Param, "attrib_list")] [NativeName(NativeNameType.Type, "EGLAttrib const *")] ref nint attribList)
		{
			fixed (nint* pattribList = &attribList)
			{
				EGLSurface ret = EglCreatePlatformPixmapSurfaceNative(dpy, config, nativePixmap, (nint*)pattribList);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "eglWaitSync")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint EglWaitSyncNative([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "EGLint")] int flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, int, uint>)funcTable[1238])(dpy, sync, flags);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<EGLDisplay, EGLSync, int, uint>)funcTable[1238])(dpy, sync, flags);
			#endif
		}

		[NativeName(NativeNameType.Func, "eglWaitSync")]
		[return: NativeName(NativeNameType.Type, "EGLBoolean")]
		public static uint EglWaitSync([NativeName(NativeNameType.Param, "dpy")] [NativeName(NativeNameType.Type, "EGLDisplay")] EGLDisplay dpy, [NativeName(NativeNameType.Param, "sync")] [NativeName(NativeNameType.Type, "EGLSync")] EGLSync sync, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "EGLint")] int flags)
		{
			uint ret = EglWaitSyncNative(dpy, sync, flags);
			return ret;
		}

		/// <summary>
		/// An app-supplied function for program entry.<br/>
		/// Apps do not directly create this function; they should create a standard<br/>
		/// ANSI-C `main` function instead. If SDL needs to insert some startup code<br/>
		/// before `main` runs, or the platform doesn't actually _use_ a function<br/>
		/// called "main", SDL will do some macro magic to redefine `main` to<br/>
		/// `SDL_main` and provide its own `main`.<br/>
		/// Apps should include `SDL_main.h` in the same file as their `main` function,<br/>
		/// and they should not use that symbol for anything else in that file, as it<br/>
		/// might get redefined.<br/>
		/// This function is only provided by the app if it isn't using<br/>
		/// SDL_MAIN_USE_CALLBACKS.<br/>
		/// Program startup is a surprisingly complex topic. Please see<br/>
		/// [README/main-functions](README/main-functions), (or<br/>
		/// docs/README-main-functions.md in the source tree) for a more detailed<br/>
		/// explanation.<br/>
		/// <br/>
		/// <br/>
		/// This is the program entry point.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MainNative([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte**, int>)funcTable[1239])(argc, argv);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[1239])(argc, (nint)argv);
			#endif
		}

		/// <summary>
		/// An app-supplied function for program entry.<br/>
		/// Apps do not directly create this function; they should create a standard<br/>
		/// ANSI-C `main` function instead. If SDL needs to insert some startup code<br/>
		/// before `main` runs, or the platform doesn't actually _use_ a function<br/>
		/// called "main", SDL will do some macro magic to redefine `main` to<br/>
		/// `SDL_main` and provide its own `main`.<br/>
		/// Apps should include `SDL_main.h` in the same file as their `main` function,<br/>
		/// and they should not use that symbol for anything else in that file, as it<br/>
		/// might get redefined.<br/>
		/// This function is only provided by the app if it isn't using<br/>
		/// SDL_MAIN_USE_CALLBACKS.<br/>
		/// Program startup is a surprisingly complex topic. Please see<br/>
		/// [README/main-functions](README/main-functions), (or<br/>
		/// docs/README-main-functions.md in the source tree) for a more detailed<br/>
		/// explanation.<br/>
		/// <br/>
		/// <br/>
		/// This is the program entry point.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Main([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv)
		{
			int ret = MainNative(argc, argv);
			return ret;
		}

		/// <summary>
		/// An app-supplied function for program entry.<br/>
		/// Apps do not directly create this function; they should create a standard<br/>
		/// ANSI-C `main` function instead. If SDL needs to insert some startup code<br/>
		/// before `main` runs, or the platform doesn't actually _use_ a function<br/>
		/// called "main", SDL will do some macro magic to redefine `main` to<br/>
		/// `SDL_main` and provide its own `main`.<br/>
		/// Apps should include `SDL_main.h` in the same file as their `main` function,<br/>
		/// and they should not use that symbol for anything else in that file, as it<br/>
		/// might get redefined.<br/>
		/// This function is only provided by the app if it isn't using<br/>
		/// SDL_MAIN_USE_CALLBACKS.<br/>
		/// Program startup is a surprisingly complex topic. Please see<br/>
		/// [README/main-functions](README/main-functions), (or<br/>
		/// docs/README-main-functions.md in the source tree) for a more detailed<br/>
		/// explanation.<br/>
		/// <br/>
		/// <br/>
		/// This is the program entry point.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Main([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = MainNative(argc, pStrArray0);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMainReady")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMainReadyNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1240])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1240])();
			#endif
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMainReady")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetMainReady()
		{
			SetMainReadyNative();
		}

		/// <summary>
		/// Initializes and launches an SDL application, by doing platform-specific<br/>
		/// initialization before calling your mainFunction and cleanups after it<br/>
		/// returns, if that is needed for a specific platform, otherwise it just calls<br/>
		/// mainFunction.<br/>
		/// You can use this if you want to use your own main() implementation without<br/>
		/// using SDL_main (like when using SDL_MAIN_HANDLED). When using this, you do<br/>
		/// *not* need SDL_SetMainReady().<br/>
		/// <br/>
		/// <br/>
		/// Generally this is called once, near startup, from the<br/>
		/// process's initial thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RunAppNative([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "mainFunction")] [NativeName(NativeNameType.Type, "SDL_main_func")] SDLMainFunc mainFunction, [NativeName(NativeNameType.Param, "reserved")] [NativeName(NativeNameType.Type, "void *")] void* reserved)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte**, delegate*<int, byte**, int>, void*, int>)funcTable[1241])(argc, argv, (delegate*<int, byte**, int>)Utils.GetFunctionPointerForDelegate(mainFunction), reserved);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, nint, nint, int>)funcTable[1241])(argc, (nint)argv, (nint)Utils.GetFunctionPointerForDelegate(mainFunction), (nint)reserved);
			#endif
		}

		/// <summary>
		/// Initializes and launches an SDL application, by doing platform-specific<br/>
		/// initialization before calling your mainFunction and cleanups after it<br/>
		/// returns, if that is needed for a specific platform, otherwise it just calls<br/>
		/// mainFunction.<br/>
		/// You can use this if you want to use your own main() implementation without<br/>
		/// using SDL_main (like when using SDL_MAIN_HANDLED). When using this, you do<br/>
		/// *not* need SDL_SetMainReady().<br/>
		/// <br/>
		/// <br/>
		/// Generally this is called once, near startup, from the<br/>
		/// process's initial thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RunApp([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "mainFunction")] [NativeName(NativeNameType.Type, "SDL_main_func")] SDLMainFunc mainFunction, [NativeName(NativeNameType.Param, "reserved")] [NativeName(NativeNameType.Type, "void *")] void* reserved)
		{
			int ret = RunAppNative(argc, argv, mainFunction, reserved);
			return ret;
		}

		/// <summary>
		/// Initializes and launches an SDL application, by doing platform-specific<br/>
		/// initialization before calling your mainFunction and cleanups after it<br/>
		/// returns, if that is needed for a specific platform, otherwise it just calls<br/>
		/// mainFunction.<br/>
		/// You can use this if you want to use your own main() implementation without<br/>
		/// using SDL_main (like when using SDL_MAIN_HANDLED). When using this, you do<br/>
		/// *not* need SDL_SetMainReady().<br/>
		/// <br/>
		/// <br/>
		/// Generally this is called once, near startup, from the<br/>
		/// process's initial thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int RunApp([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "mainFunction")] [NativeName(NativeNameType.Type, "SDL_main_func")] SDLMainFunc mainFunction, [NativeName(NativeNameType.Param, "reserved")] [NativeName(NativeNameType.Type, "void *")] void* reserved)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = RunAppNative(argc, pStrArray0, mainFunction, reserved);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EnterAppMainCallbacksNative([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte**, delegate*<void**, int, byte**, SDLAppResult>, delegate*<void*, SDLAppResult>, delegate*<void*, SDLEvent*, SDLAppResult>, delegate*<void*, SDLAppResult, void>, int>)funcTable[1242])(argc, argv, (delegate*<void**, int, byte**, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appinit), (delegate*<void*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appiter), (delegate*<void*, SDLEvent*, SDLAppResult>)Utils.GetFunctionPointerForDelegate(appevent), (delegate*<void*, SDLAppResult, void>)Utils.GetFunctionPointerForDelegate(appquit));
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, nint, nint, nint, nint, int>)funcTable[1242])(argc, (nint)argv, (nint)Utils.GetFunctionPointerForDelegate(appinit), (nint)Utils.GetFunctionPointerForDelegate(appiter), (nint)Utils.GetFunctionPointerForDelegate(appevent), (nint)Utils.GetFunctionPointerForDelegate(appquit));
			#endif
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] byte** argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			int ret = EnterAppMainCallbacksNative(argc, argv, appinit, appiter, appevent, appquit);
			return ret;
		}

		/// <summary>
		/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
		/// Generally, you should not call this function directly. This only exists to<br/>
		/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
		/// and functionality available, and make the inline code in SDL_main.h as<br/>
		/// small as possible.<br/>
		/// Not all platforms use this, it's actual use is hidden in a magic<br/>
		/// header-only library, and you should not call this directly unless you<br/>
		/// _really_ know what you're doing.<br/>
		/// <br/>
		/// <br/>
		/// It is not safe to call this anywhere except as the only<br/>
		/// function call in SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnterAppMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnterAppMainCallbacks([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char *[-1]")] string[] argv, [NativeName(NativeNameType.Param, "appinit")] [NativeName(NativeNameType.Type, "SDL_AppInit_func")] SDLAppInitFunc appinit, [NativeName(NativeNameType.Param, "appiter")] [NativeName(NativeNameType.Type, "SDL_AppIterate_func")] SDLAppIterateFunc appiter, [NativeName(NativeNameType.Param, "appevent")] [NativeName(NativeNameType.Type, "SDL_AppEvent_func")] SDLAppEventFunc appevent, [NativeName(NativeNameType.Param, "appquit")] [NativeName(NativeNameType.Type, "SDL_AppQuit_func")] SDLAppQuitFunc appquit)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = EnterAppMainCallbacksNative(argc, pStrArray0, appinit, appiter, appevent, appquit);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RegisterAppNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, void*, byte>)funcTable[1243])(name, style, hInst);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, nint, byte>)funcTable[1243])((nint)name, style, (nint)hInst);
			#endif
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			byte ret = RegisterAppNative(name, style, hInst);
			return ret != 0;
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			fixed (byte* pname = &name)
			{
				byte ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret != 0;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			fixed (byte* pname = name)
			{
				byte ret = RegisterAppNative((byte*)pname, style, hInst);
				return ret != 0;
			}
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void *")] void* hInst)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RegisterAppNative(pStr0, style, hInst);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnregisterAppNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1244])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1244])();
			#endif
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnregisterApp()
		{
			UnregisterAppNative();
		}

		/// <summary>
		/// Callback from the application to let the suspend continue.<br/>
		/// This function is only needed for Xbox GDK support; all other platforms will<br/>
		/// do nothing and set an "unsupported" error message.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GDKSuspendComplete")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GDKSuspendCompleteNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1245])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1245])();
			#endif
		}

		/// <summary>
		/// Callback from the application to let the suspend continue.<br/>
		/// This function is only needed for Xbox GDK support; all other platforms will<br/>
		/// do nothing and set an "unsupported" error message.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GDKSuspendComplete")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GDKSuspendComplete()
		{
			GDKSuspendCompleteNative();
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WinMainNative([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] byte* szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nint, nint, byte*, int, int>)funcTable[1246])(hInst, hPrev, szCmdLine, sw);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)funcTable[1246])(hInst, hPrev, (nint)szCmdLine, sw);
			#endif
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WinMain([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] byte* szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			int ret = WinMainNative(hInst, hPrev, szCmdLine, sw);
			return ret;
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WinMain([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] ReadOnlySpan<byte> szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			fixed (byte* pszCmdLine = szCmdLine)
			{
				int ret = WinMainNative(hInst, hPrev, (byte*)pszCmdLine, sw);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "WinMain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WinMain([NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hInst, [NativeName(NativeNameType.Param, "hPrev")] [NativeName(NativeNameType.Type, "HINSTANCE")] nint hPrev, [NativeName(NativeNameType.Param, "szCmdLine")] [NativeName(NativeNameType.Type, "LPSTR")] string szCmdLine, [NativeName(NativeNameType.Param, "sw")] [NativeName(NativeNameType.Type, "int")] int sw)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (szCmdLine != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(szCmdLine);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(szCmdLine, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = WinMainNative(hInst, hPrev, pStr0, sw);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestAssertNative([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[1247])(assertCondition, assertDescription);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[1247])(assertCondition, (nint)assertDescription);
			#endif
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			TestAssertNative(assertCondition, assertDescription);
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ref byte assertDescription)
		{
			fixed (byte* passertDescription = &assertDescription)
			{
				TestAssertNative(assertCondition, (byte*)passertDescription);
			}
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> assertDescription)
		{
			fixed (byte* passertDescription = assertDescription)
			{
				TestAssertNative(assertCondition, (byte*)passertDescription);
			}
		}

		/// <summary>
		/// Assert that logs and break execution flow on failures.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Assert")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssert([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] string assertDescription)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (assertDescription != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(assertDescription);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(assertDescription, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestAssertNative(assertCondition, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestAssertCheckNative([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, int>)funcTable[1248])(assertCondition, assertDescription);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[1248])(assertCondition, (nint)assertDescription);
			#endif
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			int ret = TestAssertCheckNative(assertCondition, assertDescription);
			return ret;
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ref byte assertDescription)
		{
			fixed (byte* passertDescription = &assertDescription)
			{
				int ret = TestAssertCheckNative(assertCondition, (byte*)passertDescription);
				return ret;
			}
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> assertDescription)
		{
			fixed (byte* passertDescription = assertDescription)
			{
				int ret = TestAssertCheckNative(assertCondition, (byte*)passertDescription);
				return ret;
			}
		}

		/// <summary>
		/// Assert for test cases that logs but does not break execution flow on failures. Updates assertion counters.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertCheck")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertCheck([NativeName(NativeNameType.Param, "assertCondition")] [NativeName(NativeNameType.Type, "int")] int assertCondition, [NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] string assertDescription)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (assertDescription != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(assertDescription);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(assertDescription, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = TestAssertCheckNative(assertCondition, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestAssertPassNative([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1249])(assertDescription);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1249])((nint)assertDescription);
			#endif
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] byte* assertDescription)
		{
			TestAssertPassNative(assertDescription);
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ref byte assertDescription)
		{
			fixed (byte* passertDescription = &assertDescription)
			{
				TestAssertPassNative((byte*)passertDescription);
			}
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> assertDescription)
		{
			fixed (byte* passertDescription = assertDescription)
			{
				TestAssertPassNative((byte*)passertDescription);
			}
		}

		/// <summary>
		/// Explicitly pass without checking an assertion condition. Updates assertion counter.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestAssertPass([NativeName(NativeNameType.Param, "assertDescription")] [NativeName(NativeNameType.Type, "char const *")] string assertDescription)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (assertDescription != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(assertDescription);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(assertDescription, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestAssertPassNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Resets the assert summary counters to zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_ResetAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestResetAssertSummaryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1250])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1250])();
			#endif
		}

		/// <summary>
		/// Resets the assert summary counters to zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_ResetAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestResetAssertSummary()
		{
			TestResetAssertSummaryNative();
		}

		/// <summary>
		/// Logs summary of all assertions (total, pass, fail) since last reset as INFO or ERROR.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogAssertSummaryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1251])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1251])();
			#endif
		}

		/// <summary>
		/// Logs summary of all assertions (total, pass, fail) since last reset as INFO or ERROR.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogAssertSummary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogAssertSummary()
		{
			TestLogAssertSummaryNative();
		}

		/// <summary>
		/// Converts the current assert summary state to a test result.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertSummaryToTestResult")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestAssertSummaryToTestResultNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1252])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1252])();
			#endif
		}

		/// <summary>
		/// Converts the current assert summary state to a test result.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_AssertSummaryToTestResult")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestAssertSummaryToTestResult()
		{
			int ret = TestAssertSummaryToTestResultNative();
			return ret;
		}

		/// <summary>
		/// Parse command line parameters and create common state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonCreateState")]
		[return: NativeName(NativeNameType.Type, "SDLTest_CommonState *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTestCommonState* TestCommonCreateStateNative([NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLInitFlags, SDLTestCommonState*>)funcTable[1253])(argv, flags);
			#else
			return (SDLTestCommonState*)((delegate* unmanaged[Cdecl]<nint, SDLInitFlags, nint>)funcTable[1253])((nint)argv, flags);
			#endif
		}

		/// <summary>
		/// Parse command line parameters and create common state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonCreateState")]
		[return: NativeName(NativeNameType.Type, "SDLTest_CommonState *")]
		public static SDLTestCommonState* TestCommonCreateState([NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			SDLTestCommonState* ret = TestCommonCreateStateNative(argv, flags);
			return ret;
		}

		/// <summary>
		/// Parse command line parameters and create common state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonCreateState")]
		[return: NativeName(NativeNameType.Type, "SDLTest_CommonState *")]
		public static SDLTestCommonState* TestCommonCreateState([NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] ref byte* argv, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			fixed (byte** pargv = &argv)
			{
				SDLTestCommonState* ret = TestCommonCreateStateNative((byte**)pargv, flags);
				return ret;
			}
		}

		/// <summary>
		/// Free the common state object.<br/>
		/// You should call SDL_Quit() before calling this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDestroyState")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonDestroyStateNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, void>)funcTable[1254])(state);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1254])((nint)state);
			#endif
		}

		/// <summary>
		/// Free the common state object.<br/>
		/// You should call SDL_Quit() before calling this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDestroyState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDestroyState([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			TestCommonDestroyStateNative(state);
		}

		/// <summary>
		/// Free the common state object.<br/>
		/// You should call SDL_Quit() before calling this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDestroyState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDestroyState([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonDestroyStateNative((SDLTestCommonState*)pstate);
			}
		}

		/// <summary>
		/// Process one common argument.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonArg")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestCommonArgNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, int, int>)funcTable[1255])(state, index);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[1255])((nint)state, index);
			#endif
		}

		/// <summary>
		/// Process one common argument.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonArg")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCommonArg([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			int ret = TestCommonArgNative(state, index);
			return ret;
		}

		/// <summary>
		/// Process one common argument.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonArg")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCommonArg([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				int ret = TestCommonArgNative((SDLTestCommonState*)pstate, index);
				return ret;
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonLogUsageNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, byte*, byte**, void>)funcTable[1256])(state, argv0, options);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1256])((nint)state, (nint)argv0, (nint)options);
			#endif
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			TestCommonLogUsageNative(state, argv0, options);
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonLogUsageNative((SDLTestCommonState*)pstate, argv0, options);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ref byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (byte* pargv0 = &argv0)
			{
				TestCommonLogUsageNative(state, (byte*)pargv0, options);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (byte* pargv0 = argv0)
			{
				TestCommonLogUsageNative(state, (byte*)pargv0, options);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argv0 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argv0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestCommonLogUsageNative(state, pStr0, options);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ref byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = &argv0)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, options);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = argv0)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, options);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] byte** options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (argv0 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(argv0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestCommonLogUsageNative((SDLTestCommonState*)pstate, pStr0, options);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (byte** poptions = &options)
			{
				TestCommonLogUsageNative(state, argv0, (byte**)poptions);
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] byte* argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, argv0, (byte**)poptions);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ref byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (byte* pargv0 = &argv0)
			{
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative(state, (byte*)pargv0, (byte**)poptions);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (byte* pargv0 = argv0)
			{
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative(state, (byte*)pargv0, (byte**)poptions);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argv0 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argv0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** poptions = &options)
			{
				TestCommonLogUsageNative(state, pStr0, (byte**)poptions);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ref byte argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = &argv0)
				{
					fixed (byte** poptions = &options)
					{
						TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, (byte**)poptions);
					}
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte* pargv0 = argv0)
				{
					fixed (byte** poptions = &options)
					{
						TestCommonLogUsageNative((SDLTestCommonState*)pstate, (byte*)pargv0, (byte**)poptions);
					}
				}
			}
		}

		/// <summary>
		/// Logs command line usage info.<br/>
		/// This logs the appropriate command line options for the subsystems in use<br/>
		/// plus other common options, and then any application-specific options.<br/>
		/// This uses the SDL_Log() function and splits up output to be friendly to<br/>
		/// 80-character-wide terminals.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonLogUsage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonLogUsage([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argv0")] [NativeName(NativeNameType.Type, "char const *")] string argv0, [NativeName(NativeNameType.Param, "options")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* options)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (argv0 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(argv0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(argv0, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** poptions = &options)
				{
					TestCommonLogUsageNative((SDLTestCommonState*)pstate, pStr0, (byte**)poptions);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Open test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCommonInitNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, byte>)funcTable[1257])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1257])((nint)state);
			#endif
		}

		/// <summary>
		/// Open test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonInit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			byte ret = TestCommonInitNative(state);
			return ret != 0;
		}

		/// <summary>
		/// Open test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonInit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonInit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte ret = TestCommonInitNative((SDLTestCommonState*)pstate);
				return ret != 0;
			}
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCommonDefaultArgsNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, int, byte**, byte>)funcTable[1258])(state, argc, argv);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, byte>)funcTable[1258])((nint)state, argc, (nint)argv);
			#endif
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv)
		{
			byte ret = TestCommonDefaultArgsNative(state, argc, argv);
			return ret != 0;
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] byte** argv)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				byte ret = TestCommonDefaultArgsNative((SDLTestCommonState*)pstate, argc, argv);
				return ret != 0;
			}
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] ref byte* argv)
		{
			fixed (byte** pargv = &argv)
			{
				byte ret = TestCommonDefaultArgsNative(state, argc, (byte**)pargv);
				return ret != 0;
			}
		}

		/// <summary>
		/// Easy argument handling when test app doesn't need any custom args.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDefaultArgs")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCommonDefaultArgs([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char * *")] ref byte* argv)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (byte** pargv = &argv)
				{
					byte ret = TestCommonDefaultArgsNative((SDLTestCommonState*)pstate, argc, (byte**)pargv);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Print the details of an event.<br/>
		/// This is automatically called by SDLTest_CommonEvent() as needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_PrintEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestPrintEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLEvent*, void>)funcTable[1259])(evnt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1259])((nint)evnt);
			#endif
		}

		/// <summary>
		/// Print the details of an event.<br/>
		/// This is automatically called by SDLTest_CommonEvent() as needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_PrintEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestPrintEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			TestPrintEventNative(evnt);
		}

		/// <summary>
		/// Print the details of an event.<br/>
		/// This is automatically called by SDLTest_CommonEvent() as needed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_PrintEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestPrintEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				TestPrintEventNative((SDLEvent*)pevnt);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonEventNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, SDLEvent*, int*, void>)funcTable[1260])(state, evnt, done);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1260])((nint)state, (nint)evnt, (nint)done);
			#endif
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			TestCommonEventNative(state, evnt, done);
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonEventNative((SDLTestCommonState*)pstate, evnt, done);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				TestCommonEventNative(state, (SDLEvent*)pevnt, done);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] int* done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (SDLEvent* pevnt = &evnt)
				{
					TestCommonEventNative((SDLTestCommonState*)pstate, (SDLEvent*)pevnt, done);
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (int* pdone = &done)
			{
				TestCommonEventNative(state, evnt, (int*)pdone);
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (int* pdone = &done)
				{
					TestCommonEventNative((SDLTestCommonState*)pstate, evnt, (int*)pdone);
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				fixed (int* pdone = &done)
				{
					TestCommonEventNative(state, (SDLEvent*)pevnt, (int*)pdone);
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use a standard SDL_main.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonEvent([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event *")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "done")] [NativeName(NativeNameType.Type, "int *")] ref int done)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (SDLEvent* pevnt = &evnt)
				{
					fixed (int* pdone = &done)
					{
						TestCommonEventNative((SDLTestCommonState*)pstate, (SDLEvent*)pevnt, (int*)pdone);
					}
				}
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAppResult TestCommonEventMainCallbacksNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, SDLEvent*, SDLAppResult>)funcTable[1261])(state, evnt);
			#else
			return (SDLAppResult)((delegate* unmanaged[Cdecl]<nint, nint, SDLAppResult>)funcTable[1261])((nint)state, (nint)evnt);
			#endif
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			SDLAppResult ret = TestCommonEventMainCallbacksNative(state, evnt);
			return ret;
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] SDLEvent* evnt)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				SDLAppResult ret = TestCommonEventMainCallbacksNative((SDLTestCommonState*)pstate, evnt);
				return ret;
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				SDLAppResult ret = TestCommonEventMainCallbacksNative(state, (SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Common event handler for test windows if you use SDL_AppEvent.<br/>
		/// This does _not_ free anything in `event`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonEventMainCallbacks")]
		[return: NativeName(NativeNameType.Type, "SDL_AppResult")]
		public static SDLAppResult TestCommonEventMainCallbacks([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event const *")] ref SDLEvent evnt)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				fixed (SDLEvent* pevnt = &evnt)
				{
					SDLAppResult ret = TestCommonEventMainCallbacksNative((SDLTestCommonState*)pstate, (SDLEvent*)pevnt);
					return ret;
				}
			}
		}

		/// <summary>
		/// Close test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonQuitNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestCommonState*, void>)funcTable[1262])(state);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1262])((nint)state);
			#endif
		}

		/// <summary>
		/// Close test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonQuit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state)
		{
			TestCommonQuitNative(state);
		}

		/// <summary>
		/// Close test window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonQuit([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				TestCommonQuitNative((SDLTestCommonState*)pstate);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCommonDrawWindowInfoNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLWindow*, float*, void>)funcTable[1263])(renderer, window, usedHeight);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[1263])((nint)renderer, (nint)window, (nint)usedHeight);
			#endif
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			TestCommonDrawWindowInfoNative(renderer, window, usedHeight);
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, window, usedHeight);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				TestCommonDrawWindowInfoNative(renderer, (SDLWindow*)pwindow, usedHeight);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] float* usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, (SDLWindow*)pwindow, usedHeight);
				}
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (float* pusedHeight = &usedHeight)
			{
				TestCommonDrawWindowInfoNative(renderer, window, (float*)pusedHeight);
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pusedHeight = &usedHeight)
				{
					TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, window, (float*)pusedHeight);
				}
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* pusedHeight = &usedHeight)
				{
					TestCommonDrawWindowInfoNative(renderer, (SDLWindow*)pwindow, (float*)pusedHeight);
				}
			}
		}

		/// <summary>
		/// Draws various window information (position, size, etc.) to the renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CommonDrawWindowInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCommonDrawWindowInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "usedHeight")] [NativeName(NativeNameType.Type, "float *")] ref float usedHeight)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (float* pusedHeight = &usedHeight)
					{
						TestCommonDrawWindowInfoNative((SDLRenderer*)prenderer, (SDLWindow*)pwindow, (float*)pusedHeight);
					}
				}
			}
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestCompareSurfacesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLSurface*, int, int>)funcTable[1264])(surface, referenceSurface, allowableError);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[1264])((nint)surface, (nint)referenceSurface, allowableError);
			#endif
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			int ret = TestCompareSurfacesNative(surface, referenceSurface, allowableError);
			return ret;
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = TestCompareSurfacesNative((SDLSurface*)psurface, referenceSurface, allowableError);
				return ret;
			}
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* preferenceSurface = &referenceSurface)
			{
				int ret = TestCompareSurfacesNative(surface, (SDLSurface*)preferenceSurface, allowableError);
				return ret;
			}
		}

		/// <summary>
		/// Compares a surface and with reference image data for equality<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareSurfaces")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareSurfaces([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "referenceSurface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface referenceSurface, [NativeName(NativeNameType.Param, "allowable_error")] [NativeName(NativeNameType.Type, "int")] int allowableError)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLSurface* preferenceSurface = &referenceSurface)
				{
					int ret = TestCompareSurfacesNative((SDLSurface*)psurface, (SDLSurface*)preferenceSurface, allowableError);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compares 2 memory blocks for equality<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareMemory")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestCompareMemoryNative([NativeName(NativeNameType.Param, "actual")] [NativeName(NativeNameType.Type, "void const *")] void* actual, [NativeName(NativeNameType.Param, "size_actual")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeActual, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "void const *")] void* reference, [NativeName(NativeNameType.Param, "size_reference")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeReference)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, void*, nuint, int>)funcTable[1265])(actual, sizeActual, reference, sizeReference);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nuint, int>)funcTable[1265])((nint)actual, sizeActual, (nint)reference, sizeReference);
			#endif
		}

		/// <summary>
		/// Compares 2 memory blocks for equality<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CompareMemory")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestCompareMemory([NativeName(NativeNameType.Param, "actual")] [NativeName(NativeNameType.Type, "void const *")] void* actual, [NativeName(NativeNameType.Param, "size_actual")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeActual, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "void const *")] void* reference, [NativeName(NativeNameType.Param, "size_reference")] [NativeName(NativeNameType.Type, "size_t")] nuint sizeReference)
		{
			int ret = TestCompareMemoryNative(actual, sizeActual, reference, sizeReference);
			return ret;
		}

		/// <summary>
		/// Initialize the CRC context<br/>
		/// Note: The function initializes the crc table required for all crc calculations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32InitNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte>)funcTable[1266])(crcContext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1266])((nint)crcContext);
			#endif
		}

		/// <summary>
		/// Initialize the CRC context<br/>
		/// Note: The function initializes the crc table required for all crc calculations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Init([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext)
		{
			byte ret = TestCrc32InitNative(crcContext);
			return ret != 0;
		}

		/// <summary>
		/// Initialize the CRC context<br/>
		/// Note: The function initializes the crc table required for all crc calculations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Init([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32InitNative((SDLTestCrc32Context*)pcrcContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte*, uint, uint*, byte>)funcTable[1267])(crcContext, inBuf, inLen, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, byte>)funcTable[1267])((nint)crcContext, (nint)inBuf, inLen, (nint)crc32);
			#endif
		}
	}
}
