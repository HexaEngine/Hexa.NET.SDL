// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)window, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)window, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)window, (SDLGPUTexture**)swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)window, (SDLGPUTexture**)swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)window, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)window, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexturePtrPtr swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAndAcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAndAcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
							{
								byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SubmitGPUCommandBufferNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte>)funcTable[933])(commandBuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[933])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SubmitGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer)
		{
			byte ret = SubmitGPUCommandBufferNative((SDLGPUCommandBuffer*)commandBuffer);
			return ret != 0;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SubmitGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = SubmitGPUCommandBufferNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFenceNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUFence*>)funcTable[934])(commandBuffer);
			#else
			return (SDLGPUFence*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[934])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		public static SDLGPUFencePtr SubmitGPUCommandBufferAndAcquireFence([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer)
		{
			SDLGPUFencePtr ret = SubmitGPUCommandBufferAndAcquireFenceNative((SDLGPUCommandBuffer*)commandBuffer);
			return ret;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		public static SDLGPUFencePtr SubmitGPUCommandBufferAndAcquireFence([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUFencePtr ret = SubmitGPUCommandBufferAndAcquireFenceNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret;
			}
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CancelGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CancelGPUCommandBufferNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte>)funcTable[935])(commandBuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[935])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CancelGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CancelGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBufferPtr commandBuffer)
		{
			byte ret = CancelGPUCommandBufferNative((SDLGPUCommandBuffer*)commandBuffer);
			return ret != 0;
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CancelGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CancelGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = CancelGPUCommandBufferNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUIdleNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte>)funcTable[936])(device);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[936])((nint)device);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUIdle([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device)
		{
			byte ret = WaitForGPUIdleNative((SDLGPUDevice*)device);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUIdle([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUIdleNative((SDLGPUDevice*)pdevice);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUFencesNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] byte waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte, SDLGPUFence**, uint, byte>)funcTable[937])(device, waitAll, fences, numFences);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, nint, uint, byte>)funcTable[937])((nint)device, waitAll, (nint)fences, numFences);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			byte ret = WaitForGPUFencesNative((SDLGPUDevice*)device, waitAll ? (byte)1 : (byte)0, fences, numFences);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, fences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] in SDLGPUFence* fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUFence** pfences = &fences)
			{
				byte ret = WaitForGPUFencesNative((SDLGPUDevice*)device, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] in SDLGPUFence* fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence** pfences = &fences)
				{
					byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte QueryGPUFenceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, byte>)funcTable[938])(device, fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[938])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFencePtr fence)
		{
			byte ret = QueryGPUFenceNative((SDLGPUDevice*)device, (SDLGPUFence*)fence);
			return ret != 0;
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFencePtr fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)fence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				byte ret = QueryGPUFenceNative((SDLGPUDevice*)device, (SDLGPUFence*)pfence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUFenceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, void>)funcTable[939])(device, fence);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[939])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFencePtr fence)
		{
			ReleaseGPUFenceNative((SDLGPUDevice*)device, (SDLGPUFence*)fence);
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFencePtr fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)fence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				ReleaseGPUFenceNative((SDLGPUDevice*)device, (SDLGPUFence*)pfence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
				}
			}
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureFormatTexelBlockSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GPUTextureFormatTexelBlockSizeNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[940])(format);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[940])(format);
			#endif
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureFormatTexelBlockSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GPUTextureFormatTexelBlockSize([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			uint ret = GPUTextureFormatTexelBlockSizeNative(format);
			return ret;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsFormatNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] uint usage)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUTextureType, uint, byte>)funcTable[941])(device, format, type, usage);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUTextureType, uint, byte>)funcTable[941])((nint)device, format, type, usage);
			#endif
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] uint usage)
		{
			byte ret = GPUTextureSupportsFormatNative((SDLGPUDevice*)device, format, type, usage);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] uint usage)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsFormatNative((SDLGPUDevice*)pdevice, format, type, usage);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsSampleCountNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[942])(device, format, sampleCount);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[942])((nint)device, format, sampleCount);
			#endif
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsSampleCount([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			byte ret = GPUTextureSupportsSampleCountNative((SDLGPUDevice*)device, format, sampleCount);
			return ret != 0;
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsSampleCount([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsSampleCountNative((SDLGPUDevice*)pdevice, format, sampleCount);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the size in bytes of a texture format with dimensions.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGPUTextureFormatSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalculateGPUTextureFormatSizeNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "Uint32")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "Uint32")] uint height, [NativeName(NativeNameType.Param, "depth_or_layer_count")] [NativeName(NativeNameType.Type, "Uint32")] uint depthOrLayerCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint, uint, uint, uint>)funcTable[943])(format, width, height, depthOrLayerCount);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint, uint, uint, uint>)funcTable[943])(format, width, height, depthOrLayerCount);
			#endif
		}

		/// <summary>
		/// Calculate the size in bytes of a texture format with dimensions.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGPUTextureFormatSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint CalculateGPUTextureFormatSize([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "Uint32")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "Uint32")] uint height, [NativeName(NativeNameType.Param, "depth_or_layer_count")] [NativeName(NativeNameType.Type, "Uint32")] uint depthOrLayerCount)
		{
			uint ret = CalculateGPUTextureFormatSizeNative(format, width, height, depthOrLayerCount);
			return ret;
		}

		/// <summary>
		/// Get the SDL pixel format corresponding to a GPU texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatFromGPUTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_PixelFormat")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPixelFormat GetPixelFormatFromGPUTextureFormatNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, SDLPixelFormat>)funcTable[944])(format);
			#else
			return (SDLPixelFormat)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, SDLPixelFormat>)funcTable[944])(format);
			#endif
		}

		/// <summary>
		/// Get the SDL pixel format corresponding to a GPU texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatFromGPUTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_PixelFormat")]
		public static SDLPixelFormat GetPixelFormatFromGPUTextureFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			SDLPixelFormat ret = GetPixelFormatFromGPUTextureFormatNative(format);
			return ret;
		}

		/// <summary>
		/// Get the GPU texture format corresponding to an SDL pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUTextureFormatFromPixelFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTextureFormat GetGPUTextureFormatFromPixelFormatNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPixelFormat, SDLGPUTextureFormat>)funcTable[945])(format);
			#else
			return (SDLGPUTextureFormat)((delegate* unmanaged[Cdecl]<SDLPixelFormat, SDLGPUTextureFormat>)funcTable[945])(format);
			#endif
		}

		/// <summary>
		/// Get the GPU texture format corresponding to an SDL pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUTextureFormatFromPixelFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUTextureFormatFromPixelFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			SDLGPUTextureFormat ret = GetGPUTextureFormatFromPixelFormatNative(format);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetHapticsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[946])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[946])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		public static uint* GetHaptics([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetHapticsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		public static uint* GetHaptics([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetHapticsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[947])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[947])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			byte* ret = GetHapticNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHaptic")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[948])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[948])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHaptic")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHapticPtr OpenHaptic([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			SDLHapticPtr ret = OpenHapticNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* GetHapticFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[949])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[949])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHapticPtr GetHapticFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			SDLHapticPtr ret = GetHapticFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticIDNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[950])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[950])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		public static uint GetHapticID([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			uint ret = GetHapticIDNative((SDLHaptic*)haptic);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		public static uint GetHapticID([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticIDNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte*>)funcTable[951])(haptic);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[951])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticName([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			byte* ret = GetHapticNameNative((SDLHaptic*)haptic);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameS([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameNative((SDLHaptic*)haptic));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticName([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte* ret = GetHapticNameNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameS([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				string ret = Utils.DecodeStringUTF8(GetHapticNameNative((SDLHaptic*)phaptic));
				return ret;
			}
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMouseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseHapticNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[952])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[952])();
			#endif
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMouseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseHaptic()
		{
			byte ret = IsMouseHapticNative();
			return ret != 0;
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromMouseNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*>)funcTable[953])();
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint>)funcTable[953])();
			#endif
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHapticPtr OpenHapticFromMouse()
		{
			SDLHapticPtr ret = OpenHapticFromMouseNative();
			return ret;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJoystickHapticNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte>)funcTable[954])(joystick);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[954])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJoystickHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystickPtr joystick)
		{
			byte ret = IsJoystickHapticNative((SDLJoystick*)joystick);
			return ret != 0;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJoystickHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = IsJoystickHapticNative((SDLJoystick*)pjoystick);
				return ret != 0;
			}
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromJoystickNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLHaptic*>)funcTable[955])(joystick);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[955])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHapticPtr OpenHapticFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystickPtr joystick)
		{
			SDLHapticPtr ret = OpenHapticFromJoystickNative((SDLJoystick*)joystick);
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHapticPtr OpenHapticFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLHapticPtr ret = OpenHapticFromJoystickNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHaptic*, void>)funcTable[956])(haptic);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[956])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			CloseHapticNative((SDLHaptic*)haptic);
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				CloseHapticNative((SDLHaptic*)phaptic);
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[957])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[957])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			int ret = GetMaxHapticEffectsNative((SDLHaptic*)haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsPlayingNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[958])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[958])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			int ret = GetMaxHapticEffectsPlayingNative((SDLHaptic*)haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsPlayingNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticFeaturesNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[959])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[959])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetHapticFeatures([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			uint ret = GetHapticFeaturesNative((SDLHaptic*)haptic);
			return ret;
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetHapticFeatures([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticFeaturesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumHapticAxesNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[960])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[960])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			int ret = GetNumHapticAxesNative((SDLHaptic*)haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetNumHapticAxesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HapticEffectSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, byte>)funcTable[961])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[961])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffectPtr effect)
		{
			byte ret = HapticEffectSupportedNative((SDLHaptic*)haptic, (SDLHapticEffect*)effect);
			return ret != 0;
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffectPtr effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, (SDLHapticEffect*)effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] in SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				byte ret = HapticEffectSupportedNative((SDLHaptic*)haptic, (SDLHapticEffect*)peffect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] in SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticEffectID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, int>)funcTable[962])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[962])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticEffectID")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffectPtr effect)
		{
			int ret = CreateHapticEffectNative((SDLHaptic*)haptic, (SDLHapticEffect*)effect);
			return ret;
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticEffectID")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffectPtr effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, (SDLHapticEffect*)effect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticEffectID")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] in SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				int ret = CreateHapticEffectNative((SDLHaptic*)haptic, (SDLHapticEffect*)peffect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticEffectID")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] in SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, SDLHapticEffect*, byte>)funcTable[963])(haptic, effect, data);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, byte>)funcTable[963])((nint)haptic, effect, (nint)data);
			#endif
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffectPtr data)
		{
			byte ret = UpdateHapticEffectNative((SDLHaptic*)haptic, effect, (SDLHapticEffect*)data);
			return ret != 0;
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffectPtr data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = UpdateHapticEffectNative((SDLHaptic*)phaptic, effect, (SDLHapticEffect*)data);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] in SDLHapticEffect data)
		{
			fixed (SDLHapticEffect* pdata = &data)
			{
				byte ret = UpdateHapticEffectNative((SDLHaptic*)haptic, effect, (SDLHapticEffect*)pdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] in SDLHapticEffect data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* pdata = &data)
				{
					byte ret = UpdateHapticEffectNative((SDLHaptic*)phaptic, effect, (SDLHapticEffect*)pdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RunHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, uint, byte>)funcTable[964])(haptic, effect, iterations);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, uint, byte>)funcTable[964])((nint)haptic, effect, iterations);
			#endif
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RunHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			byte ret = RunHapticEffectNative((SDLHaptic*)haptic, effect, iterations);
			return ret != 0;
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RunHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = RunHapticEffectNative((SDLHaptic*)phaptic, effect, iterations);
				return ret != 0;
			}
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StopHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[965])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[965])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			byte ret = StopHapticEffectNative((SDLHaptic*)haptic, effect);
			return ret != 0;
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = StopHapticEffectNative((SDLHaptic*)phaptic, effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHaptic*, int, void>)funcTable[966])(haptic, effect);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[966])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			DestroyHapticEffectNative((SDLHaptic*)haptic, effect);
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyHapticEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				DestroyHapticEffectNative((SDLHaptic*)phaptic, effect);
			}
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetHapticEffectStatusNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[967])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[967])((nint)haptic, effect);
			#endif
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHapticEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			byte ret = GetHapticEffectStatusNative((SDLHaptic*)haptic, effect);
			return ret != 0;
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticEffectStatus")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHapticEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffectID")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = GetHapticEffectStatusNative((SDLHaptic*)phaptic, effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetHapticGainNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[968])(haptic, gain);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[968])((nint)haptic, gain);
			#endif
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			byte ret = SetHapticGainNative((SDLHaptic*)haptic, gain);
			return ret != 0;
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticGain")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = SetHapticGainNative((SDLHaptic*)phaptic, gain);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetHapticAutocenterNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, byte>)funcTable[969])(haptic, autocenter);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[969])((nint)haptic, autocenter);
			#endif
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			byte ret = SetHapticAutocenterNative((SDLHaptic*)haptic, autocenter);
			return ret != 0;
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHapticAutocenter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHapticAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = SetHapticAutocenterNative((SDLHaptic*)phaptic, autocenter);
				return ret != 0;
			}
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PauseHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[970])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[970])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PauseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			byte ret = PauseHapticNative((SDLHaptic*)haptic);
			return ret != 0;
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
		/// to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PauseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = PauseHapticNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ResumeHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[971])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[971])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResumeHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			byte ret = ResumeHapticNative((SDLHaptic*)haptic);
			return ret != 0;
		}

		/// <summary>
		/// Resume a haptic device.<br/>
		/// Call to unpause after SDL_PauseHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResumeHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResumeHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = ResumeHapticNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StopHapticEffectsNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[972])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[972])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			byte ret = StopHapticEffectsNative((SDLHaptic*)haptic);
			return ret != 0;
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticEffects")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = StopHapticEffectsNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HapticRumbleSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[973])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[973])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			byte ret = HapticRumbleSupportedNative((SDLHaptic*)haptic);
			return ret != 0;
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = HapticRumbleSupportedNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[974])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[974])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool InitHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			byte ret = InitHapticRumbleNative((SDLHaptic*)haptic);
			return ret != 0;
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool InitHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = InitHapticRumbleNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PlayHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, float, uint, byte>)funcTable[975])(haptic, strength, length);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, uint, byte>)funcTable[975])((nint)haptic, strength, length);
			#endif
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PlayHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			byte ret = PlayHapticRumbleNative((SDLHaptic*)haptic, strength, length);
			return ret != 0;
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PlayHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PlayHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = PlayHapticRumbleNative((SDLHaptic*)phaptic, strength, length);
				return ret != 0;
			}
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StopHapticRumbleNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte>)funcTable[976])(haptic);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[976])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHapticPtr haptic)
		{
			byte ret = StopHapticRumbleNative((SDLHaptic*)haptic);
			return ret != 0;
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopHapticRumble")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StopHapticRumble([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = StopHapticRumbleNative((SDLHaptic*)phaptic);
				return ret != 0;
			}
		}

		/// <summary>
		/// Initialize the HIDAPI library.<br/>
		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
		/// be called at the beginning of execution however, if there is a chance of<br/>
		/// HIDAPI handles being opened by different threads simultaneously.<br/>
		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidInitNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[977])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[977])();
			#endif
		}

		/// <summary>
		/// Initialize the HIDAPI library.<br/>
		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
		/// be called at the beginning of execution however, if there is a chance of<br/>
		/// HIDAPI handles being opened by different threads simultaneously.<br/>
		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidInit()
		{
			int ret = HidInitNative();
			return ret;
		}

		/// <summary>
		/// Finalize the HIDAPI library.<br/>
		/// This function frees all of the static data associated with HIDAPI. It<br/>
		/// should be called at the end of execution to avoid memory leaks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidExitNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[978])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[978])();
			#endif
		}

		/// <summary>
		/// Finalize the HIDAPI library.<br/>
		/// This function frees all of the static data associated with HIDAPI. It<br/>
		/// should be called at the end of execution to avoid memory leaks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidExit()
		{
			int ret = HidExitNative();
			return ret;
		}

		/// <summary>
		/// Check to see if devices may have been added or removed.<br/>
		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
		/// to see if there have been any system device changes since the last call to<br/>
		/// this function. A change in the counter returned doesn't necessarily mean<br/>
		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
		/// updated device list.<br/>
		/// Calling this function for the first time may cause a thread or other system<br/>
		/// resource to be allocated to track device change notifications.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint HidDeviceChangeCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[979])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[979])();
			#endif
		}

		/// <summary>
		/// Check to see if devices may have been added or removed.<br/>
		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
		/// to see if there have been any system device changes since the last call to<br/>
		/// this function. A change in the counter returned doesn't necessarily mean<br/>
		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
		/// updated device list.<br/>
		/// Calling this function for the first time may cause a thread or other system<br/>
		/// resource to be allocated to track device change notifications.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint HidDeviceChangeCount()
		{
			uint ret = HidDeviceChangeCountNative();
			return ret;
		}

		/// <summary>
		/// Enumerate the HID Devices.<br/>
		/// This function returns a linked list of all the HID devices attached to the<br/>
		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
		/// devices will be returned.<br/>
		/// By default SDL will only enumerate controllers, to reduce risk of hanging<br/>
		/// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS<br/>
		/// can be set to "0" to enumerate all HID devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDeviceInfo* HidEnumerateNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, SDLHidDeviceInfo*>)funcTable[980])(vendorId, productId);
			#else
			return (SDLHidDeviceInfo*)((delegate* unmanaged[Cdecl]<ushort, ushort, nint>)funcTable[980])(vendorId, productId);
			#endif
		}

		/// <summary>
		/// Enumerate the HID Devices.<br/>
		/// This function returns a linked list of all the HID devices attached to the<br/>
		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
		/// devices will be returned.<br/>
		/// By default SDL will only enumerate controllers, to reduce risk of hanging<br/>
		/// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS<br/>
		/// can be set to "0" to enumerate all HID devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		public static SDLHidDeviceInfoPtr HidEnumerate([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId)
		{
			SDLHidDeviceInfoPtr ret = HidEnumerateNative(vendorId, productId);
			return ret;
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HidFreeEnumerationNative([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] SDLHidDeviceInfo* devs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHidDeviceInfo*, void>)funcTable[981])(devs);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[981])((nint)devs);
			#endif
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] SDLHidDeviceInfoPtr devs)
		{
			HidFreeEnumerationNative((SDLHidDeviceInfo*)devs);
		}

		/// <summary>
		/// Free an enumeration linked list.<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info *")] ref SDLHidDeviceInfo devs)
		{
			fixed (SDLHidDeviceInfo* pdevs = &devs)
			{
				HidFreeEnumerationNative((SDLHidDeviceInfo*)pdevs);
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDevice* HidOpenNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* serialNumber)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, char*, SDLHidDevice*>)funcTable[982])(vendorId, productId, serialNumber);
			#else
			return (SDLHidDevice*)((delegate* unmanaged[Cdecl]<ushort, ushort, nint, nint>)funcTable[982])(vendorId, productId, (nint)serialNumber);
			#endif
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar_t const *")] char* serialNumber)
		{
			SDLHidDevicePtr ret = HidOpenNative(vendorId, productId, serialNumber);
			return ret;
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar_t const *")] in char serialNumber)
		{
			fixed (char* pserialNumber = &serialNumber)
			{
				SDLHidDevicePtr ret = HidOpenNative(vendorId, productId, (char*)pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar_t const *")] ReadOnlySpan<char> serialNumber)
		{
			fixed (char* pserialNumber = serialNumber)
			{
				SDLHidDevicePtr ret = HidOpenNative(vendorId, productId, (char*)pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "wchar_t const *")] string serialNumber)
		{
			fixed (char* pserialNumber = serialNumber)
			{
				SDLHidDevicePtr ret = HidOpenNative(vendorId, productId, pserialNumber);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDevice* HidOpenPathNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLHidDevice*>)funcTable[983])(path);
			#else
			return (SDLHidDevice*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[983])((nint)path);
			#endif
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			SDLHidDevicePtr ret = HidOpenPathNative(path);
			return ret;
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path)
		{
			fixed (byte* ppath = &path)
			{
				SDLHidDevicePtr ret = HidOpenPathNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				SDLHidDevicePtr ret = HidOpenPathNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device *")]
		public static SDLHidDevicePtr HidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLHidDevicePtr ret = HidOpenPathNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the properties associated with an SDL_hid_device.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_HIDAPI_LIBUSB_DEVICE_HANDLE_POINTER`: the libusb_device_handle<br/>
		/// associated with the device, if it was opened using libusb.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_properties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint HidGetPropertiesNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, uint>)funcTable[984])(dev);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[984])((nint)dev);
			#endif
		}

		/// <summary>
		/// Get the properties associated with an SDL_hid_device.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_HIDAPI_LIBUSB_DEVICE_HANDLE_POINTER`: the libusb_device_handle<br/>
		/// associated with the device, if it was opened using libusb.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_properties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint HidGetProperties([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev)
		{
			uint ret = HidGetPropertiesNative((SDLHidDevice*)dev);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with an SDL_hid_device.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_HIDAPI_LIBUSB_DEVICE_HANDLE_POINTER`: the libusb_device_handle<br/>
		/// associated with the device, if it was opened using libusb.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_properties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint HidGetProperties([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				uint ret = HidGetPropertiesNative((SDLHidDevice*)pdev);
				return ret;
			}
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidWriteNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[985])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[985])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidWriteNative((SDLHidDevice*)dev, data, length);
			return ret;
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidWriteNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] in byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidWriteNative((SDLHidDevice*)dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] in byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidWriteNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidReadTimeoutNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int, int>)funcTable[986])(dev, data, length, milliseconds);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int, int>)funcTable[986])((nint)dev, (nint)data, length, milliseconds);
			#endif
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			int ret = HidReadTimeoutNative((SDLHidDevice*)dev, data, length, milliseconds);
			return ret;
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidReadTimeoutNative((SDLHidDevice*)pdev, data, length, milliseconds);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidReadTimeoutNative((SDLHidDevice*)dev, (byte*)pdata, length, milliseconds);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidReadTimeoutNative((SDLHidDevice*)pdev, (byte*)pdata, length, milliseconds);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidReadNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[987])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[987])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidReadNative((SDLHidDevice*)dev, data, length);
			return ret;
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidReadNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidReadNative((SDLHidDevice*)dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidReadNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidSetNonblockingNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int, int>)funcTable[988])(dev, nonblock);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[988])((nint)dev, nonblock);
			#endif
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			int ret = HidSetNonblockingNative((SDLHidDevice*)dev, nonblock);
			return ret;
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidSetNonblockingNative((SDLHidDevice*)pdev, nonblock);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidSendFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[989])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[989])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidSendFeatureReportNative((SDLHidDevice*)dev, data, length);
			return ret;
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidSendFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] in byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidSendFeatureReportNative((SDLHidDevice*)dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char const *")] in byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidSendFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[990])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[990])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidGetFeatureReportNative((SDLHidDevice*)dev, data, length);
			return ret;
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidGetFeatureReportNative((SDLHidDevice*)dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidGetFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetInputReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[991])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[991])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidGetInputReportNative((SDLHidDevice*)dev, data, length);
			return ret;
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetInputReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidGetInputReportNative((SDLHidDevice*)dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidGetInputReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidCloseNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int>)funcTable[992])(dev);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[992])((nint)dev);
			#endif
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev)
		{
			int ret = HidCloseNative((SDLHidDevice*)dev);
			return ret;
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidCloseNative((SDLHidDevice*)pdev);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetManufacturerStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[993])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[993])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetManufacturerStringNative((SDLHidDevice*)dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetManufacturerStringNative((SDLHidDevice*)dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetManufacturerStringNative((SDLHidDevice*)dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetProductStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[994])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[994])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetProductStringNative((SDLHidDevice*)dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetProductStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevicePtr dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar_t *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetProductStringNative((SDLHidDevice*)dev, (char*)pstr, maxlen);
				return ret;
			}
		}
	}
}
