// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)filters, nfilters, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilterPtr filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)filters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowSaveFileDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] in SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowSaveFileDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFolderDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] byte allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, byte*, byte, void>)funcTable[617])(callback, userdata, window, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte, void>)funcTable[617])((nint)callback, (nint)userdata, (nint)window, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)window, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)window, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)window, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)window, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)window, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)window, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, (SDLWindow*)pwindow, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFolderDialogNative(callback, (void*)userdata, (SDLWindow*)pwindow, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] in byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFolderDialogNative((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, (SDLWindow*)pwindow, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Create and launch a file dialog with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of<br/>
		/// SDL_DialogFileFilter structs, which will be used as filters for<br/>
		/// file-based selections. Ignored if the dialog is an "Open Folder" dialog.<br/>
		/// If non-NULL, the array of filters must remain valid at least until the<br/>
		/// callback is invoked.<br/>
		/// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the<br/>
		/// array of filters, if it exists.<br/>
		/// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should<br/>
		/// be modal for.<br/>
		/// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to<br/>
		/// start the dialog at.<br/>
		/// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select<br/>
		/// more than one entry.<br/>
		/// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.<br/>
		/// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button<br/>
		/// should have.<br/>
		/// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button<br/>
		/// should have.<br/>
		/// Note that each platform may or may not support any of the properties.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowFileDialogWithProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowFileDialogWithPropertiesNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_FileDialogType")] SDLFileDialogType type, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLFileDialogType, delegate*<void*, byte**, int, void>, void*, uint, void>)funcTable[618])(type, callback, userdata, props);
			#else
			((delegate* unmanaged[Cdecl]<SDLFileDialogType, nint, nint, uint, void>)funcTable[618])(type, (nint)callback, (nint)userdata, props);
			#endif
		}

		/// <summary>
		/// Create and launch a file dialog with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of<br/>
		/// SDL_DialogFileFilter structs, which will be used as filters for<br/>
		/// file-based selections. Ignored if the dialog is an "Open Folder" dialog.<br/>
		/// If non-NULL, the array of filters must remain valid at least until the<br/>
		/// callback is invoked.<br/>
		/// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the<br/>
		/// array of filters, if it exists.<br/>
		/// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should<br/>
		/// be modal for.<br/>
		/// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to<br/>
		/// start the dialog at.<br/>
		/// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select<br/>
		/// more than one entry.<br/>
		/// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.<br/>
		/// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button<br/>
		/// should have.<br/>
		/// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button<br/>
		/// should have.<br/>
		/// Note that each platform may or may not support any of the properties.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowFileDialogWithProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowFileDialogWithProperties([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_FileDialogType")] SDLFileDialogType type, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			ShowFileDialogWithPropertiesNative(type, callback, userdata, props);
		}

		/// <summary>
		/// Create and launch a file dialog with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of<br/>
		/// SDL_DialogFileFilter structs, which will be used as filters for<br/>
		/// file-based selections. Ignored if the dialog is an "Open Folder" dialog.<br/>
		/// If non-NULL, the array of filters must remain valid at least until the<br/>
		/// callback is invoked.<br/>
		/// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the<br/>
		/// array of filters, if it exists.<br/>
		/// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should<br/>
		/// be modal for.<br/>
		/// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to<br/>
		/// start the dialog at.<br/>
		/// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select<br/>
		/// more than one entry.<br/>
		/// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.<br/>
		/// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button<br/>
		/// should have.<br/>
		/// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button<br/>
		/// should have.<br/>
		/// Note that each platform may or may not support any of the properties.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowFileDialogWithProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowFileDialogWithProperties([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_FileDialogType")] SDLFileDialogType type, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			ShowFileDialogWithPropertiesNative(type, (delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, props);
		}

		/// <summary>
		/// Create and launch a file dialog with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of<br/>
		/// SDL_DialogFileFilter structs, which will be used as filters for<br/>
		/// file-based selections. Ignored if the dialog is an "Open Folder" dialog.<br/>
		/// If non-NULL, the array of filters must remain valid at least until the<br/>
		/// callback is invoked.<br/>
		/// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the<br/>
		/// array of filters, if it exists.<br/>
		/// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should<br/>
		/// be modal for.<br/>
		/// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to<br/>
		/// start the dialog at.<br/>
		/// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select<br/>
		/// more than one entry.<br/>
		/// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.<br/>
		/// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button<br/>
		/// should have.<br/>
		/// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button<br/>
		/// should have.<br/>
		/// Note that each platform may or may not support any of the properties.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowFileDialogWithProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowFileDialogWithProperties([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_FileDialogType")] SDLFileDialogType type, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] delegate*<void*, byte**, int, void> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			ShowFileDialogWithPropertiesNative(type, callback, (void*)userdata, props);
		}

		/// <summary>
		/// Create and launch a file dialog with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_FILE_DIALOG_FILTERS_POINTER`: a pointer to a list of<br/>
		/// SDL_DialogFileFilter structs, which will be used as filters for<br/>
		/// file-based selections. Ignored if the dialog is an "Open Folder" dialog.<br/>
		/// If non-NULL, the array of filters must remain valid at least until the<br/>
		/// callback is invoked.<br/>
		/// - `SDL_PROP_FILE_DIALOG_NFILTERS_NUMBER`: the number of filters in the<br/>
		/// array of filters, if it exists.<br/>
		/// - `SDL_PROP_FILE_DIALOG_WINDOW_POINTER`: the window that the dialog should<br/>
		/// be modal for.<br/>
		/// - `SDL_PROP_FILE_DIALOG_LOCATION_STRING`: the default folder or file to<br/>
		/// start the dialog at.<br/>
		/// - `SDL_PROP_FILE_DIALOG_MANY_BOOLEAN`: true to allow the user to select<br/>
		/// more than one entry.<br/>
		/// - `SDL_PROP_FILE_DIALOG_TITLE_STRING`: the title for the dialog.<br/>
		/// - `SDL_PROP_FILE_DIALOG_ACCEPT_STRING`: the label that the accept button<br/>
		/// should have.<br/>
		/// - `SDL_PROP_FILE_DIALOG_CANCEL_STRING`: the label that the cancel button<br/>
		/// should have.<br/>
		/// Note that each platform may or may not support any of the properties.<br/>
		/// <br/>
		/// <br/>
		/// This function should be called only from the main thread. The<br/>
		/// callback may be invoked from the same thread or from a<br/>
		/// different one, depending on the OS's constraints.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowFileDialogWithProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowFileDialogWithProperties([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_FileDialogType")] SDLFileDialogType type, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata, [NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			ShowFileDialogWithPropertiesNative(type, (delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata, props);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GUIDToStringNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, byte*, int, void>)funcTable[619])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, int, void>)funcTable[619])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			GUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] ref byte pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				GUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] ref string pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid StringToGUIDNative([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SdlGuid>)funcTable[620])(pchGUID);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[620])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] byte* pchGUID)
		{
			SdlGuid ret = StringToGUIDNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] in byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdlGuid ret = StringToGUIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetPowerInfoNative([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, SDLPowerState>)funcTable[621])(seconds, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[621])((nint)seconds, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			SDLPowerState ret = GetPowerInfoNative(seconds, percent);
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			fixed (int* pseconds = &seconds)
			{
				SDLPowerState ret = GetPowerInfoNative((int*)pseconds, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetPowerInfoNative(seconds, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// On some platforms, retrieving power supply details might be expensive. If<br/>
		/// you want to display continuous status you could call this function every<br/>
		/// minute or so.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (int* pseconds = &seconds)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetPowerInfoNative((int*)pseconds, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetSensorsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[622])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[622])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		public static int* GetSensors([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = GetSensorsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		public static int* GetSensors([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetSensorsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[623])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[623])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			byte* ret = GetSensorNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[624])(instanceId);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[624])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensorType ret = GetSensorTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableTypeForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[625])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[625])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableTypeForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			int ret = GetSensorNonPortableTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* OpenSensorNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[626])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[626])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		public static SDLSensorPtr OpenSensor([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensorPtr ret = OpenSensorNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* GetSensorFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[627])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[627])(instanceId);
			#endif
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		public static SDLSensorPtr GetSensorFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensorPtr ret = GetSensorFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSensorPropertiesNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, uint>)funcTable[628])(sensor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[628])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSensorProperties([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor)
		{
			uint ret = GetSensorPropertiesNative((SDLSensor*)sensor);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSensorProperties([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				uint ret = GetSensorPropertiesNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, byte*>)funcTable[629])(sensor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[629])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor)
		{
			byte* ret = GetSensorNameNative((SDLSensor*)sensor);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameNative((SDLSensor*)sensor));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte* ret = GetSensorNameNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				string ret = Utils.DecodeStringUTF8(GetSensorNameNative((SDLSensor*)psensor));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, SDLSensorType>)funcTable[630])(sensor);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<nint, SDLSensorType>)funcTable[630])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor)
		{
			SDLSensorType ret = GetSensorTypeNative((SDLSensor*)sensor);
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorType ret = GetSensorTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[631])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[631])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor)
		{
			int ret = GetSensorNonPortableTypeNative((SDLSensor*)sensor);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorNonPortableTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorIDNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[632])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[632])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int GetSensorID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor)
		{
			int ret = GetSensorIDNative((SDLSensor*)sensor);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int GetSensorID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorIDNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSensorDataNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, float*, int, byte>)funcTable[633])(sensor, data, numValues);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[633])((nint)sensor, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			byte ret = GetSensorDataNative((SDLSensor*)sensor, data, numValues);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte ret = GetSensorDataNative((SDLSensor*)psensor, data, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				byte ret = GetSensorDataNative((SDLSensor*)sensor, (float*)pdata, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					byte ret = GetSensorDataNative((SDLSensor*)psensor, (float*)pdata, numValues);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseSensorNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSensor*, void>)funcTable[634])(sensor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[634])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseSensor([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensorPtr sensor)
		{
			CloseSensorNative((SDLSensor*)sensor);
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseSensor([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				CloseSensorNative((SDLSensor*)psensor);
			}
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[635])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[635])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateSensors()
		{
			UpdateSensorsNative();
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[636])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[636])();
			#endif
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockJoysticks()
		{
			LockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// This should be called from the same thread that called<br/>
		/// SDL_LockJoysticks().<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[637])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[637])();
			#endif
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// This should be called from the same thread that called<br/>
		/// SDL_LockJoysticks().<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockJoysticks()
		{
			UnlockJoysticksNative();
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasJoystick")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasJoystickNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[638])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[638])();
			#endif
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasJoystick")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasJoystick()
		{
			byte ret = HasJoystickNative();
			return ret != 0;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetJoysticksNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[639])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[639])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		public static int* GetJoysticks([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = GetJoysticksNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		public static int* GetJoysticks([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetJoysticksNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[640])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[640])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte* ret = GetJoystickNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickPathForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[641])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[641])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickPathForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte* ret = GetJoystickPathForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickPathForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickPathForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndexForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickPlayerIndexForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[642])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[642])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndexForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetJoystickPlayerIndexForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			int ret = GetJoystickPlayerIndexForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDForID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetJoystickGUIDForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[643])(instanceId);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[643])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDForID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid GetJoystickGUIDForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SdlGuid ret = GetJoystickGUIDForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendorForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickVendorForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[644])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[644])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendorForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickVendorForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickVendorForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[645])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[645])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickProductForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersionForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductVersionForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[646])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[646])(instanceId);
			#endif
		}
	}
}
