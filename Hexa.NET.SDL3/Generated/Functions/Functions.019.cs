// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
			{
				BindGPUComputeSamplersNative(computePass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
				{
					BindGPUComputeSamplersNative((SDLGPUComputePass*)pcomputePass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputeStorageTexturesNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, SDLGPUTexture**, uint, void>)funcTable[863])(computePass, firstSlot, storageTextures, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[863])((nint)computePass, firstSlot, (nint)storageTextures, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUComputeStorageTexturesNative(computePass, firstSlot, storageTextures, numBindings);
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputeStorageTexturesNative((SDLGPUComputePass*)pcomputePass, firstSlot, storageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
			{
				BindGPUComputeStorageTexturesNative(computePass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
				{
					BindGPUComputeStorageTexturesNative((SDLGPUComputePass*)pcomputePass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputeStorageBuffersNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, SDLGPUBuffer**, uint, void>)funcTable[864])(computePass, firstSlot, storageBuffers, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[864])((nint)computePass, firstSlot, (nint)storageBuffers, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUComputeStorageBuffersNative(computePass, firstSlot, storageBuffers, numBindings);
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputeStorageBuffersNative((SDLGPUComputePass*)pcomputePass, firstSlot, storageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
			{
				BindGPUComputeStorageBuffersNative(computePass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
				{
					BindGPUComputeStorageBuffersNative((SDLGPUComputePass*)pcomputePass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
				}
			}
		}

		/// <summary>
		/// Dispatches compute work.<br/>
		/// You must not call this function before binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUCompute")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchGPUComputeNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "groupcount_x")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountX, [NativeName(NativeNameType.Param, "groupcount_y")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountY, [NativeName(NativeNameType.Param, "groupcount_z")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, uint, uint, void>)funcTable[865])(computePass, groupcountX, groupcountY, groupcountZ);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, void>)funcTable[865])((nint)computePass, groupcountX, groupcountY, groupcountZ);
			#endif
		}

		/// <summary>
		/// Dispatches compute work.<br/>
		/// You must not call this function before binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUCompute")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUCompute([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "groupcount_x")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountX, [NativeName(NativeNameType.Param, "groupcount_y")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountY, [NativeName(NativeNameType.Param, "groupcount_z")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountZ)
		{
			DispatchGPUComputeNative(computePass, groupcountX, groupcountY, groupcountZ);
		}

		/// <summary>
		/// Dispatches compute work.<br/>
		/// You must not call this function before binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUCompute")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUCompute([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "groupcount_x")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountX, [NativeName(NativeNameType.Param, "groupcount_y")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountY, [NativeName(NativeNameType.Param, "groupcount_z")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountZ)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				DispatchGPUComputeNative((SDLGPUComputePass*)pcomputePass, groupcountX, groupcountY, groupcountZ);
			}
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchGPUComputeIndirectNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, SDLGPUBuffer*, uint, void>)funcTable[866])(computePass, buffer, offset);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[866])((nint)computePass, (nint)buffer, offset);
			#endif
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			DispatchGPUComputeIndirectNative(computePass, buffer, offset);
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				DispatchGPUComputeIndirectNative((SDLGPUComputePass*)pcomputePass, buffer, offset);
			}
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				DispatchGPUComputeIndirectNative(computePass, (SDLGPUBuffer*)pbuffer, offset);
			}
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					DispatchGPUComputeIndirectNative((SDLGPUComputePass*)pcomputePass, (SDLGPUBuffer*)pbuffer, offset);
				}
			}
		}

		/// <summary>
		/// Ends the current compute pass.<br/>
		/// All bound compute state on the command buffer is unset. The compute pass<br/>
		/// handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGPUComputePassNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, void>)funcTable[867])(computePass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[867])((nint)computePass);
			#endif
		}

		/// <summary>
		/// Ends the current compute pass.<br/>
		/// All bound compute state on the command buffer is unset. The compute pass<br/>
		/// handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUComputePass([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass)
		{
			EndGPUComputePassNative(computePass);
		}

		/// <summary>
		/// Ends the current compute pass.<br/>
		/// All bound compute state on the command buffer is unset. The compute pass<br/>
		/// handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUComputePass([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				EndGPUComputePassNative((SDLGPUComputePass*)pcomputePass);
			}
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBuffer*, byte, void*>)funcTable[868])(device, transferBuffer, cycle);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, byte, nint>)funcTable[868])((nint)device, (nint)transferBuffer, cycle);
			#endif
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			void* ret = MapGPUTransferBufferNative(device, transferBuffer, cycle ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				void* ret = MapGPUTransferBufferNative((SDLGPUDevice*)pdevice, transferBuffer, cycle ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
			{
				void* ret = MapGPUTransferBufferNative(device, (SDLGPUTransferBuffer*)ptransferBuffer, cycle ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
				{
					void* ret = MapGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBuffer*)ptransferBuffer, cycle ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnmapGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBuffer*, void>)funcTable[869])(device, transferBuffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[869])((nint)device, (nint)transferBuffer);
			#endif
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			UnmapGPUTransferBufferNative(device, transferBuffer);
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				UnmapGPUTransferBufferNative((SDLGPUDevice*)pdevice, transferBuffer);
			}
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
			{
				UnmapGPUTransferBufferNative(device, (SDLGPUTransferBuffer*)ptransferBuffer);
			}
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
				{
					UnmapGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBuffer*)ptransferBuffer);
				}
			}
		}

		/// <summary>
		/// Begins a copy pass on a command buffer.<br/>
		/// All operations related to copying to or from buffers or textures take place<br/>
		/// inside a copy pass. You must not begin another copy pass, or a render pass<br/>
		/// or compute pass before ending the copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUCopyPass* BeginGPUCopyPassNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUCopyPass*>)funcTable[870])(commandBuffer);
			#else
			return (SDLGPUCopyPass*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[870])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Begins a copy pass on a command buffer.<br/>
		/// All operations related to copying to or from buffers or textures take place<br/>
		/// inside a copy pass. You must not begin another copy pass, or a render pass<br/>
		/// or compute pass before ending the copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")]
		public static SDLGPUCopyPass* BeginGPUCopyPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			SDLGPUCopyPass* ret = BeginGPUCopyPassNative(commandBuffer);
			return ret;
		}

		/// <summary>
		/// Begins a copy pass on a command buffer.<br/>
		/// All operations related to copying to or from buffers or textures take place<br/>
		/// inside a copy pass. You must not begin another copy pass, or a render pass<br/>
		/// or compute pass before ending the copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")]
		public static SDLGPUCopyPass* BeginGPUCopyPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUCopyPass* ret = BeginGPUCopyPassNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret;
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UploadToGPUTextureNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTextureTransferInfo*, SDLGPUTextureRegion*, byte, void>)funcTable[871])(copyPass, source, destination, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, void>)funcTable[871])((nint)copyPass, (nint)source, (nint)destination, cycle);
			#endif
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			UploadToGPUTextureNative(copyPass, source, destination, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureTransferInfo* psource = &source)
			{
				UploadToGPUTextureNative(copyPass, (SDLGPUTextureTransferInfo*)psource, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureTransferInfo* psource = &source)
				{
					UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureTransferInfo*)psource, destination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureRegion* pdestination = &destination)
			{
				UploadToGPUTextureNative(copyPass, source, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* pdestination = &destination)
				{
					UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureTransferInfo* psource = &source)
			{
				fixed (SDLGPUTextureRegion* pdestination = &destination)
				{
					UploadToGPUTextureNative(copyPass, (SDLGPUTextureTransferInfo*)psource, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureTransferInfo* psource = &source)
				{
					fixed (SDLGPUTextureRegion* pdestination = &destination)
					{
						UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureTransferInfo*)psource, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UploadToGPUBufferNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTransferBufferLocation*, SDLGPUBufferRegion*, byte, void>)funcTable[872])(copyPass, source, destination, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, void>)funcTable[872])((nint)copyPass, (nint)source, (nint)destination, cycle);
			#endif
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			UploadToGPUBufferNative(copyPass, source, destination, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTransferBufferLocation* psource = &source)
			{
				UploadToGPUBufferNative(copyPass, (SDLGPUTransferBufferLocation*)psource, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTransferBufferLocation* psource = &source)
				{
					UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTransferBufferLocation*)psource, destination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferRegion* pdestination = &destination)
			{
				UploadToGPUBufferNative(copyPass, source, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* pdestination = &destination)
				{
					UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTransferBufferLocation* psource = &source)
			{
				fixed (SDLGPUBufferRegion* pdestination = &destination)
				{
					UploadToGPUBufferNative(copyPass, (SDLGPUTransferBufferLocation*)psource, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTransferBufferLocation* psource = &source)
				{
					fixed (SDLGPUBufferRegion* pdestination = &destination)
					{
						UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTransferBufferLocation*)psource, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyGPUTextureToTextureNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTextureLocation*, SDLGPUTextureLocation*, uint, uint, uint, byte, void>)funcTable[873])(copyPass, source, destination, w, h, d, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, uint, uint, byte, void>)funcTable[873])((nint)copyPass, (nint)source, (nint)destination, w, h, d, cycle);
			#endif
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			CopyGPUTextureToTextureNative(copyPass, source, destination, w, h, d, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, source, destination, w, h, d, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureLocation* psource = &source)
			{
				CopyGPUTextureToTextureNative(copyPass, (SDLGPUTextureLocation*)psource, destination, w, h, d, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureLocation* psource = &source)
				{
					CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureLocation*)psource, destination, w, h, d, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureLocation* pdestination = &destination)
			{
				CopyGPUTextureToTextureNative(copyPass, source, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureLocation* pdestination = &destination)
				{
					CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureLocation* psource = &source)
			{
				fixed (SDLGPUTextureLocation* pdestination = &destination)
				{
					CopyGPUTextureToTextureNative(copyPass, (SDLGPUTextureLocation*)psource, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureLocation* psource = &source)
				{
					fixed (SDLGPUTextureLocation* pdestination = &destination)
					{
						CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureLocation*)psource, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyGPUBufferToBufferNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUBufferLocation*, SDLGPUBufferLocation*, uint, byte, void>)funcTable[874])(copyPass, source, destination, size, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, byte, void>)funcTable[874])((nint)copyPass, (nint)source, (nint)destination, size, cycle);
			#endif
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			CopyGPUBufferToBufferNative(copyPass, source, destination, size, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, source, destination, size, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferLocation* psource = &source)
			{
				CopyGPUBufferToBufferNative(copyPass, (SDLGPUBufferLocation*)psource, destination, size, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* psource = &source)
				{
					CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferLocation*)psource, destination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferLocation* pdestination = &destination)
			{
				CopyGPUBufferToBufferNative(copyPass, source, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* pdestination = &destination)
				{
					CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferLocation* psource = &source)
			{
				fixed (SDLGPUBufferLocation* pdestination = &destination)
				{
					CopyGPUBufferToBufferNative(copyPass, (SDLGPUBufferLocation*)psource, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* psource = &source)
				{
					fixed (SDLGPUBufferLocation* pdestination = &destination)
					{
						CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferLocation*)psource, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DownloadFromGPUTextureNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTextureRegion*, SDLGPUTextureTransferInfo*, void>)funcTable[875])(copyPass, source, destination);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[875])((nint)copyPass, (nint)source, (nint)destination);
			#endif
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			DownloadFromGPUTextureNative(copyPass, source, destination);
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, destination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUTextureRegion* psource = &source)
			{
				DownloadFromGPUTextureNative(copyPass, (SDLGPUTextureRegion*)psource, destination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* psource = &source)
				{
					DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureRegion*)psource, destination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
			{
				DownloadFromGPUTextureNative(copyPass, source, (SDLGPUTextureTransferInfo*)pdestination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
				{
					DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTextureTransferInfo*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUTextureRegion* psource = &source)
			{
				fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
				{
					DownloadFromGPUTextureNative(copyPass, (SDLGPUTextureRegion*)psource, (SDLGPUTextureTransferInfo*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* psource = &source)
				{
					fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
					{
						DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureRegion*)psource, (SDLGPUTextureTransferInfo*)pdestination);
					}
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DownloadFromGPUBufferNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUBufferRegion*, SDLGPUTransferBufferLocation*, void>)funcTable[876])(copyPass, source, destination);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[876])((nint)copyPass, (nint)source, (nint)destination);
			#endif
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			DownloadFromGPUBufferNative(copyPass, source, destination);
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, destination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUBufferRegion* psource = &source)
			{
				DownloadFromGPUBufferNative(copyPass, (SDLGPUBufferRegion*)psource, destination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* psource = &source)
				{
					DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferRegion*)psource, destination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
			{
				DownloadFromGPUBufferNative(copyPass, source, (SDLGPUTransferBufferLocation*)pdestination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
				{
					DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTransferBufferLocation*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUBufferRegion* psource = &source)
			{
				fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
				{
					DownloadFromGPUBufferNative(copyPass, (SDLGPUBufferRegion*)psource, (SDLGPUTransferBufferLocation*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* psource = &source)
				{
					fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
					{
						DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferRegion*)psource, (SDLGPUTransferBufferLocation*)pdestination);
					}
				}
			}
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGPUCopyPassNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, void>)funcTable[877])(copyPass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[877])((nint)copyPass);
			#endif
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUCopyPass([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass)
		{
			EndGPUCopyPassNative(copyPass);
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUCopyPass([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				EndGPUCopyPassNative((SDLGPUCopyPass*)pcopyPass);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapsForGPUTextureNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUTexture*, void>)funcTable[878])(commandBuffer, texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[878])((nint)commandBuffer, (nint)texture);
			#endif
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			GenerateMipmapsForGPUTextureNative(commandBuffer, texture);
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				GenerateMipmapsForGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, texture);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				GenerateMipmapsForGPUTextureNative(commandBuffer, (SDLGPUTexture*)ptexture);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					GenerateMipmapsForGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUTexture*)ptexture);
				}
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitGPUTextureNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] SDLGPUBlitInfo* info)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUBlitInfo*, void>)funcTable[879])(commandBuffer, info);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[879])((nint)commandBuffer, (nint)info);
			#endif
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] SDLGPUBlitInfo* info)
		{
			BlitGPUTextureNative(commandBuffer, info);
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] SDLGPUBlitInfo* info)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				BlitGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, info);
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] ref SDLGPUBlitInfo info)
		{
			fixed (SDLGPUBlitInfo* pinfo = &info)
			{
				BlitGPUTextureNative(commandBuffer, (SDLGPUBlitInfo*)pinfo);
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] ref SDLGPUBlitInfo info)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUBlitInfo* pinfo = &info)
				{
					BlitGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUBlitInfo*)pinfo);
				}
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowSupportsGPUSwapchainCompositionNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUSwapchainComposition, byte>)funcTable[880])(device, window, swapchainComposition);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUSwapchainComposition, byte>)funcTable[880])((nint)device, (nint)window, swapchainComposition);
			#endif
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			byte ret = WindowSupportsGPUSwapchainCompositionNative(device, window, swapchainComposition);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WindowSupportsGPUSwapchainCompositionNative((SDLGPUDevice*)pdevice, window, swapchainComposition);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowSupportsGPUSwapchainCompositionNative(device, (SDLWindow*)pwindow, swapchainComposition);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WindowSupportsGPUSwapchainCompositionNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, swapchainComposition);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowSupportsGPUPresentModeNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUPresentMode, byte>)funcTable[881])(device, window, presentMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUPresentMode, byte>)funcTable[881])((nint)device, (nint)window, presentMode);
			#endif
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			byte ret = WindowSupportsGPUPresentModeNative(device, window, presentMode);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WindowSupportsGPUPresentModeNative((SDLGPUDevice*)pdevice, window, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowSupportsGPUPresentModeNative(device, (SDLWindow*)pwindow, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WindowSupportsGPUPresentModeNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, presentMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClaimWindowForGPUDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, byte>)funcTable[882])(device, window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[882])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = ClaimWindowForGPUDeviceNative(device, window);
			return ret != 0;
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = ClaimWindowForGPUDeviceNative((SDLGPUDevice*)pdevice, window);
				return ret != 0;
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ClaimWindowForGPUDeviceNative(device, (SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = ClaimWindowForGPUDeviceNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseWindowFromGPUDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, void>)funcTable[883])(device, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[883])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			ReleaseWindowFromGPUDeviceNative(device, window);
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseWindowFromGPUDeviceNative((SDLGPUDevice*)pdevice, window);
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ReleaseWindowFromGPUDeviceNative(device, (SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					ReleaseWindowFromGPUDeviceNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGPUSwapchainParametersNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUSwapchainComposition, SDLGPUPresentMode, byte>)funcTable[884])(device, window, swapchainComposition, presentMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUSwapchainComposition, SDLGPUPresentMode, byte>)funcTable[884])((nint)device, (nint)window, swapchainComposition, presentMode);
			#endif
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			byte ret = SetGPUSwapchainParametersNative(device, window, swapchainComposition, presentMode);
			return ret != 0;
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = SetGPUSwapchainParametersNative((SDLGPUDevice*)pdevice, window, swapchainComposition, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetGPUSwapchainParametersNative(device, (SDLWindow*)pwindow, swapchainComposition, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = SetGPUSwapchainParametersNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, swapchainComposition, presentMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTextureFormat GetGPUSwapchainTextureFormatNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUTextureFormat>)funcTable[885])(device, window);
			#else
			return (SDLGPUTextureFormat)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUTextureFormat>)funcTable[885])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative(device, window);
			return ret;
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative((SDLGPUDevice*)pdevice, window);
				return ret;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative(device, (SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AcquireGPUSwapchainTextureNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLWindow*, SDLGPUTexture**, uint*, uint*, byte>)funcTable[886])(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[886])((nint)commandBuffer, (nint)window, (nint)swapchainTexture, (nint)swapchainTextureWidth, (nint)swapchainTextureHeight);
			#endif
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			return ret != 0;
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
		/// with NULL under certain conditions. This is not necessarily an error. If<br/>
		/// this function returns false then there is an error.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
							{
								byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SubmitGPUCommandBufferNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte>)funcTable[887])(commandBuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[887])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SubmitGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			byte ret = SubmitGPUCommandBufferNative(commandBuffer);
			return ret != 0;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SubmitGPUCommandBuffer([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = SubmitGPUCommandBufferNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFenceNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUFence*>)funcTable[888])(commandBuffer);
			#else
			return (SDLGPUFence*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[888])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		public static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFence([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			SDLGPUFence* ret = SubmitGPUCommandBufferAndAcquireFenceNative(commandBuffer);
			return ret;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SubmitGPUCommandBufferAndAcquireFence")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUFence *")]
		public static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFence([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUFence* ret = SubmitGPUCommandBufferAndAcquireFenceNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret;
			}
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUIdleNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte>)funcTable[889])(device);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[889])((nint)device);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUIdle([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			byte ret = WaitForGPUIdleNative(device);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUIdle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUIdle([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUIdleNative((SDLGPUDevice*)pdevice);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUFencesNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] byte waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte, SDLGPUFence**, uint, byte>)funcTable[890])(device, waitAll, fences, numFences);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, nint, uint, byte>)funcTable[890])((nint)device, waitAll, (nint)fences, numFences);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			byte ret = WaitForGPUFencesNative(device, waitAll ? (byte)1 : (byte)0, fences, numFences);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] SDLGPUFence** fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, fences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] ref SDLGPUFence* fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUFence** pfences = &fences)
			{
				byte ret = WaitForGPUFencesNative(device, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitForGPUFences")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitForGPUFences([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "wait_all")] [NativeName(NativeNameType.Type, "bool")] bool waitAll, [NativeName(NativeNameType.Param, "fences")] [NativeName(NativeNameType.Type, "SDL_GPUFence * const *")] ref SDLGPUFence* fences, [NativeName(NativeNameType.Param, "num_fences")] [NativeName(NativeNameType.Type, "Uint32")] uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence** pfences = &fences)
				{
					byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte QueryGPUFenceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, byte>)funcTable[891])(device, fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[891])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			byte ret = QueryGPUFenceNative(device, fence);
			return ret != 0;
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, fence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				byte ret = QueryGPUFenceNative(device, (SDLGPUFence*)pfence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryGPUFence")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool QueryGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUFenceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, void>)funcTable[892])(device, fence);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[892])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			ReleaseGPUFenceNative(device, fence);
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] SDLGPUFence* fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, fence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				ReleaseGPUFenceNative(device, (SDLGPUFence*)pfence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUFence")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUFence([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "fence")] [NativeName(NativeNameType.Type, "SDL_GPUFence *")] ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
				}
			}
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureFormatTexelBlockSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GPUTextureFormatTexelBlockSizeNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[893])(format);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[893])(format);
			#endif
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureFormatTexelBlockSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GPUTextureFormatTexelBlockSize([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format)
		{
			uint ret = GPUTextureFormatTexelBlockSizeNative(format);
			return ret;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsFormatNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] SDLGPUTextureUsageFlags usage)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUTextureType, SDLGPUTextureUsageFlags, byte>)funcTable[894])(device, format, type, usage);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUTextureType, SDLGPUTextureUsageFlags, byte>)funcTable[894])((nint)device, format, type, usage);
			#endif
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] SDLGPUTextureUsageFlags usage)
		{
			byte ret = GPUTextureSupportsFormatNative(device, format, type, usage);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsFormat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GPUTextureType")] SDLGPUTextureType type, [NativeName(NativeNameType.Param, "usage")] [NativeName(NativeNameType.Type, "SDL_GPUTextureUsageFlags")] SDLGPUTextureUsageFlags usage)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsFormatNative((SDLGPUDevice*)pdevice, format, type, usage);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsSampleCountNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[895])(device, format, sampleCount);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[895])((nint)device, format, sampleCount);
			#endif
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsSampleCount([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			byte ret = GPUTextureSupportsSampleCountNative(device, format, sampleCount);
			return ret != 0;
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUTextureSupportsSampleCount")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUTextureSupportsSampleCount([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")] SDLGPUTextureFormat format, [NativeName(NativeNameType.Param, "sample_count")] [NativeName(NativeNameType.Type, "SDL_GPUSampleCount")] SDLGPUSampleCount sampleCount)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsSampleCountNative((SDLGPUDevice*)pdevice, format, sampleCount);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetHapticsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[896])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[896])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		public static uint* GetHaptics([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetHapticsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHaptics")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID *")]
		public static uint* GetHaptics([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetHapticsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[897])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[897])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			byte* ret = GetHapticNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHaptic")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[898])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[898])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHaptic")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHaptic([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			SDLHaptic* ret = OpenHapticNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* GetHapticFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[899])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[899])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* GetHapticFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_HapticID")] uint instanceId)
		{
			SDLHaptic* ret = GetHapticFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticIDNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[900])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[900])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		public static uint GetHapticID([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			uint ret = GetHapticIDNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticID")]
		[return: NativeName(NativeNameType.Type, "SDL_HapticID")]
		public static uint GetHapticID([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticIDNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte*>)funcTable[901])(haptic);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[901])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticName([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			byte* ret = GetHapticNameNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameS([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameNative(haptic));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHapticName([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte* ret = GetHapticNameNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHapticNameS([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				string ret = Utils.DecodeStringUTF8(GetHapticNameNative((SDLHaptic*)phaptic));
				return ret;
			}
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMouseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseHapticNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[902])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[902])();
			#endif
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMouseHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseHaptic()
		{
			byte ret = IsMouseHapticNative();
			return ret != 0;
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromMouseNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*>)funcTable[903])();
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint>)funcTable[903])();
			#endif
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHapticFromMouse()
		{
			SDLHaptic* ret = OpenHapticFromMouseNative();
			return ret;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJoystickHapticNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte>)funcTable[904])(joystick);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[904])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJoystickHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte ret = IsJoystickHapticNative(joystick);
			return ret != 0;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickHaptic")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJoystickHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = IsJoystickHapticNative((SDLJoystick*)pjoystick);
				return ret != 0;
			}
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromJoystickNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLHaptic*>)funcTable[905])(joystick);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[905])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHapticFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			SDLHaptic* ret = OpenHapticFromJoystickNative(joystick);
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenHapticFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic *")]
		public static SDLHaptic* OpenHapticFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLHaptic* ret = OpenHapticFromJoystickNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseHapticNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHaptic*, void>)funcTable[906])(haptic);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[906])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			CloseHapticNative(haptic);
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseHaptic")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseHaptic([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				CloseHapticNative((SDLHaptic*)phaptic);
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[907])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[907])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = GetMaxHapticEffectsNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsPlayingNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[908])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[908])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = GetMaxHapticEffectsPlayingNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMaxHapticEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMaxHapticEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsPlayingNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticFeaturesNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[909])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[909])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetHapticFeatures([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			uint ret = GetHapticFeaturesNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHapticFeatures")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetHapticFeatures([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticFeaturesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumHapticAxesNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[910])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[910])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic)
		{
			int ret = GetNumHapticAxesNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumHapticAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumHapticAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetNumHapticAxesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HapticEffectSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, byte>)funcTable[911])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[911])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			byte ret = HapticEffectSupportedNative(haptic, effect);
			return ret != 0;
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				byte ret = HapticEffectSupportedNative(haptic, (SDLHapticEffect*)peffect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, int>)funcTable[912])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[912])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			int ret = CreateHapticEffectNative(haptic, effect);
			return ret;
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				int ret = CreateHapticEffectNative(haptic, (SDLHapticEffect*)peffect);
				return ret;
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CreateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					int ret = CreateHapticEffectNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateHapticEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int, SDLHapticEffect*, byte>)funcTable[913])(haptic, effect, data);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, nint, byte>)funcTable[913])((nint)haptic, effect, (nint)data);
			#endif
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			byte ret = UpdateHapticEffectNative(haptic, effect, data);
			return ret != 0;
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] SDLHapticEffect* data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = UpdateHapticEffectNative((SDLHaptic*)phaptic, effect, data);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_UpdateHapticEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateHapticEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool UpdateHapticEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic *")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect const *")] ref SDLHapticEffect data)
		{
			fixed (SDLHapticEffect* pdata = &data)
			{
				byte ret = UpdateHapticEffectNative(haptic, effect, (SDLHapticEffect*)pdata);
				return ret != 0;
			}
		}
	}
}
