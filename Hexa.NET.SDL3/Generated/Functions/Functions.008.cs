// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					GetRGBANative(pixel, format, palette, (byte*)pr, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, (byte*)pg, b, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pg = &g)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pb = &b)
			{
				GetRGBANative(pixel, format, palette, r, g, (byte*)pb, a);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, palette, (byte*)pr, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pb = &b)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					GetRGBANative(pixel, format, palette, r, (byte*)pg, (byte*)pb, a);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, (byte*)pg, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						GetRGBANative(pixel, format, palette, (byte*)pr, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, (byte*)pg, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pg = &g)
						{
							fixed (byte* pb = &b)
							{
								GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, (byte*)pb, a);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pa = &a)
			{
				GetRGBANative(pixel, format, palette, r, g, b, (byte*)pa);
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, palette, (byte*)pr, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, g, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, g, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, g, b, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, palette, r, (byte*)pg, b, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, (byte*)pg, b, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, palette, (byte*)pr, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, (byte*)pg, b, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pg = &g)
						{
							fixed (byte* pa = &a)
							{
								GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, b, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pa = &a)
				{
					GetRGBANative(pixel, format, palette, r, g, (byte*)pb, (byte*)pa);
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, g, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, palette, (byte*)pr, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, g, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, g, (byte*)pb, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						GetRGBANative(pixel, format, palette, r, (byte*)pg, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, r, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, format, (SDLPalette*)ppalette, r, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, r, (byte*)pg, (byte*)pb, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							GetRGBANative(pixel, format, palette, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] SDLPalette* palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, palette, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] SDLPixelFormatDetails* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								GetRGBANative(pixel, format, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, as long as<br/>
		/// the palette is not modified.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormatDetails const *")] ref SDLPixelFormatDetails format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette const *")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte a)
		{
			fixed (SDLPixelFormatDetails* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					fixed (byte* pr = &r)
					{
						fixed (byte* pg = &g)
						{
							fixed (byte* pb = &b)
							{
								fixed (byte* pa = &a)
								{
									GetRGBANative(pixel, (SDLPixelFormatDetails*)pformat, (SDLPalette*)ppalette, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasRectIntersectionNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, int>)funcTable[342])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[342])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b)
		{
			int ret = HasRectIntersectionNative(a, b);
			return ret;
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b)
		{
			fixed (SDLRect* pa = &a)
			{
				int ret = HasRectIntersectionNative((SDLRect*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b)
		{
			fixed (SDLRect* pb = &b)
			{
				int ret = HasRectIntersectionNative(a, (SDLRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					int ret = HasRectIntersectionNative((SDLRect*)pa, (SDLRect*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectIntersectionNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLRect*, int>)funcTable[343])(a, b, result);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[343])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			int ret = GetRectIntersectionNative(a, b, result);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				int ret = GetRectIntersectionNative((SDLRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				int ret = GetRectIntersectionNative(a, (SDLRect*)pb, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					int ret = GetRectIntersectionNative((SDLRect*)pa, (SDLRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				int ret = GetRectIntersectionNative(a, b, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					int ret = GetRectIntersectionNative((SDLRect*)pa, b, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					int ret = GetRectIntersectionNative(a, (SDLRect*)pb, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						int ret = GetRectIntersectionNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectUnionNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, SDLRect*, SDLRect*, int>)funcTable[344])(a, b, result);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[344])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			int ret = GetRectUnionNative(a, b, result);
			return ret;
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				int ret = GetRectUnionNative((SDLRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				int ret = GetRectUnionNative(a, (SDLRect*)pb, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					int ret = GetRectUnionNative((SDLRect*)pa, (SDLRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				int ret = GetRectUnionNative(a, b, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					int ret = GetRectUnionNative((SDLRect*)pa, b, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					int ret = GetRectUnionNative(a, (SDLRect*)pb, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnion")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnion([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						int ret = GetRectUnionNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectEnclosingPointsNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLPoint*, int, SDLRect*, SDLRect*, int>)funcTable[345])(points, count, clip, result);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int>)funcTable[345])((nint)points, count, (nint)clip, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			int ret = GetRectEnclosingPointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				int ret = GetRectEnclosingPointsNative((SDLPoint*)ppoints, count, clip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				int ret = GetRectEnclosingPointsNative(points, count, (SDLRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					int ret = GetRectEnclosingPointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				int ret = GetRectEnclosingPointsNative(points, count, clip, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* presult = &result)
				{
					int ret = GetRectEnclosingPointsNative((SDLPoint*)ppoints, count, clip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				fixed (SDLRect* presult = &result)
				{
					int ret = GetRectEnclosingPointsNative(points, count, (SDLRect*)pclip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_Point const *")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect *")] ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					fixed (SDLRect* presult = &result)
					{
						int ret = GetRectEnclosingPointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectAndLineIntersectionNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRect*, int*, int*, int*, int*, int>)funcTable[346])(rect, x1, y1, x2, y2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[346])((nint)rect, (nint)x1, (nint)y1, (nint)x2, (nint)y2);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			int ret = GetRectAndLineIntersectionNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, y1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				int ret = GetRectAndLineIntersectionNative(rect, x1, (int*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (int* px2 = &x2)
			{
				int ret = GetRectAndLineIntersectionNative(rect, x1, y1, (int*)px2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					int ret = GetRectAndLineIntersectionNative(rect, x1, (int*)py1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, y2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* py2 = &y2)
			{
				int ret = GetRectAndLineIntersectionNative(rect, x1, y1, x2, (int*)py2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, y1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionNative(rect, x1, (int*)py1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* px2 = &x2)
			{
				fixed (int* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionNative(rect, x1, y1, (int*)px2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionNative(rect, x1, (int*)py1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionNative(rect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersection([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int *")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int *")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int *")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int *")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							fixed (int* py2 = &y2)
							{
								int ret = GetRectAndLineIntersectionNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasRectIntersectionFloatNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, int>)funcTable[347])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[347])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b)
		{
			int ret = HasRectIntersectionFloatNative(a, b);
			return ret;
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b)
		{
			fixed (SDLFRect* pa = &a)
			{
				int ret = HasRectIntersectionFloatNative((SDLFRect*)pa, b);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b)
		{
			fixed (SDLFRect* pb = &b)
			{
				int ret = HasRectIntersectionFloatNative(a, (SDLFRect*)pb);
				return ret;
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					int ret = HasRectIntersectionFloatNative((SDLFRect*)pa, (SDLFRect*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectIntersectionFloatNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLFRect*, int>)funcTable[348])(a, b, result);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[348])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			int ret = GetRectIntersectionFloatNative(a, b, result);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				int ret = GetRectIntersectionFloatNative((SDLFRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				int ret = GetRectIntersectionFloatNative(a, (SDLFRect*)pb, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					int ret = GetRectIntersectionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				int ret = GetRectIntersectionFloatNative(a, b, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					int ret = GetRectIntersectionFloatNative((SDLFRect*)pa, b, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					int ret = GetRectIntersectionFloatNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectIntersectionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						int ret = GetRectIntersectionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectUnionFloatNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, SDLFRect*, SDLFRect*, int>)funcTable[349])(a, b, result);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[349])((nint)a, (nint)b, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			int ret = GetRectUnionFloatNative(a, b, result);
			return ret;
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				int ret = GetRectUnionFloatNative((SDLFRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				int ret = GetRectUnionFloatNative(a, (SDLFRect*)pb, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					int ret = GetRectUnionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				int ret = GetRectUnionFloatNative(a, b, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					int ret = GetRectUnionFloatNative((SDLFRect*)pa, b, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					int ret = GetRectUnionFloatNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectUnionFloat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetRectUnionFloat([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						int ret = GetRectUnionFloatNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectEnclosingPointsFloatNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFPoint*, int, SDLFRect*, SDLFRect*, int>)funcTable[350])(points, count, clip, result);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int>)funcTable[350])((nint)points, count, (nint)clip, (nint)result);
			#endif
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			int ret = GetRectEnclosingPointsFloatNative(points, count, clip, result);
			return ret;
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				int ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, clip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				int ret = GetRectEnclosingPointsFloatNative(points, count, (SDLFRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] SDLFRect* result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					int ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, result);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				int ret = GetRectEnclosingPointsFloatNative(points, count, clip, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* presult = &result)
				{
					int ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, clip, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				fixed (SDLFRect* presult = &result)
				{
					int ret = GetRectEnclosingPointsFloatNative(points, count, (SDLFRect*)pclip, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectEnclosingPointsFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectEnclosingPointsFloat([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "SDL_FPoint const *")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect *")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					fixed (SDLFRect* presult = &result)
					{
						int ret = GetRectEnclosingPointsFloatNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, (SDLFRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRectAndLineIntersectionFloatNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFRect*, float*, float*, float*, float*, int>)funcTable[351])(rect, x1, y1, x2, y2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[351])((nint)rect, (nint)x1, (nint)y1, (nint)x2, (nint)y2);
			#endif
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			int ret = GetRectAndLineIntersectionFloatNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				int ret = GetRectAndLineIntersectionFloatNative(rect, x1, (float*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, (float*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px2 = &x2)
			{
				int ret = GetRectAndLineIntersectionFloatNative(rect, x1, y1, (float*)px2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, y1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					int ret = GetRectAndLineIntersectionFloatNative(rect, x1, (float*)py1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, (float*)py1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, y2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* py2 = &y2)
			{
				int ret = GetRectAndLineIntersectionFloatNative(rect, x1, y1, x2, (float*)py2);
				return ret;
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, y1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionFloatNative(rect, x1, (float*)py1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, (float*)py1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px2 = &x2)
			{
				fixed (float* py2 = &y2)
				{
					int ret = GetRectAndLineIntersectionFloatNative(rect, x1, y1, (float*)px2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, y1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, y1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						int ret = GetRectAndLineIntersectionFloatNative(rect, x1, (float*)py1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							int ret = GetRectAndLineIntersectionFloatNative(rect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectAndLineIntersectionFloat")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetRectAndLineIntersectionFloat([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_FRect const *")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float *")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float *")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float *")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float *")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							fixed (float* py2 = &y2)
							{
								int ret = GetRectAndLineIntersectionFloatNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateSurfaceNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, SDLSurface*>)funcTable[352])(width, height, format);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint>)funcTable[352])(width, height, format);
			#endif
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* CreateSurface([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format)
		{
			SDLSurface* ret = CreateSurfaceNative(width, height, format);
			return ret;
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format and existing pixel<br/>
		/// data.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// Pitch is the offset in bytes from one row of pixels to the next, e.g.<br/>
		/// `width*4` for `SDL_PIXELFORMAT_RGBA8888`.<br/>
		/// You may pass NULL for pixels and 0 for pitch to create a surface that you<br/>
		/// will fill in with valid values later.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* CreateSurfaceFromNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void *")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, void*, int, SDLSurface*>)funcTable[353])(width, height, format, pixels, pitch);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<int, int, SDLPixelFormat, nint, int, nint>)funcTable[353])(width, height, format, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Allocate a new surface with a specific pixel format and existing pixel<br/>
		/// data.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// Pitch is the offset in bytes from one row of pixels to the next, e.g.<br/>
		/// `width*4` for `SDL_PIXELFORMAT_RGBA8888`.<br/>
		/// You may pass NULL for pixels and 0 for pitch to create a surface that you<br/>
		/// will fill in with valid values later.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* CreateSurfaceFrom([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat")] SDLPixelFormat format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void *")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			SDLSurface* ret = CreateSurfaceFromNative(width, height, format, pixels, pitch);
			return ret;
		}

		/// <summary>
		/// Free a surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroySurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSurface*, void>)funcTable[354])(surface);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[354])((nint)surface);
			#endif
		}

		/// <summary>
		/// Free a surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			DestroySurfaceNative(surface);
		}

		/// <summary>
		/// Free a surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				DestroySurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Get the properties associated with a surface.<br/>
		/// The following properties are understood by SDL:<br/>
		/// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.<br/>
		/// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. This defaults to 0.0, which disables tone<br/>
		/// mapping.<br/>
		/// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator<br/>
		/// used when compressing from a surface with high dynamic range to another<br/>
		/// with lower dynamic range. Currently this supports "chrome", which uses<br/>
		/// the same tone mapping that Chrome uses for HDR content, the form "*=N",<br/>
		/// where N is a floating point scale factor applied in linear space, and<br/>
		/// "none", which disables tone mapping. This defaults to "chrome".<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSurfacePropertiesNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, uint>)funcTable[355])(surface);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[355])((nint)surface);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a surface.<br/>
		/// The following properties are understood by SDL:<br/>
		/// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.<br/>
		/// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. This defaults to 0.0, which disables tone<br/>
		/// mapping.<br/>
		/// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator<br/>
		/// used when compressing from a surface with high dynamic range to another<br/>
		/// with lower dynamic range. Currently this supports "chrome", which uses<br/>
		/// the same tone mapping that Chrome uses for HDR content, the form "*=N",<br/>
		/// where N is a floating point scale factor applied in linear space, and<br/>
		/// "none", which disables tone mapping. This defaults to "chrome".<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSurfaceProperties([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			uint ret = GetSurfacePropertiesNative(surface);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a surface.<br/>
		/// The following properties are understood by SDL:<br/>
		/// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.<br/>
		/// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// surfaces, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. This defaults to 0.0, which disables tone<br/>
		/// mapping.<br/>
		/// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator<br/>
		/// used when compressing from a surface with high dynamic range to another<br/>
		/// with lower dynamic range. Currently this supports "chrome", which uses<br/>
		/// the same tone mapping that Chrome uses for HDR content, the form "*=N",<br/>
		/// where N is a floating point scale factor applied in linear space, and<br/>
		/// "none", which disables tone mapping. This defaults to "chrome".<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSurfaceProperties([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				uint ret = GetSurfacePropertiesNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Set the colorspace used by a surface.<br/>
		/// Setting the colorspace doesn't change the pixels, only how they are<br/>
		/// interpreted in color operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetSurfaceColorspaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLColorspace, int>)funcTable[356])(surface, colorspace);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, SDLColorspace, int>)funcTable[356])((nint)surface, colorspace);
			#endif
		}

		/// <summary>
		/// Set the colorspace used by a surface.<br/>
		/// Setting the colorspace doesn't change the pixels, only how they are<br/>
		/// interpreted in color operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace)
		{
			int ret = SetSurfaceColorspaceNative(surface, colorspace);
			return ret;
		}

		/// <summary>
		/// Set the colorspace used by a surface.<br/>
		/// Setting the colorspace doesn't change the pixels, only how they are<br/>
		/// interpreted in color operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "colorspace")] [NativeName(NativeNameType.Type, "SDL_Colorspace")] SDLColorspace colorspace)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SetSurfaceColorspaceNative((SDLSurface*)psurface, colorspace);
				return ret;
			}
		}

		/// <summary>
		/// Get the colorspace used by a surface.<br/>
		/// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point<br/>
		/// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for<br/>
		/// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Colorspace")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLColorspace GetSurfaceColorspaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLColorspace>)funcTable[357])(surface);
			#else
			return (SDLColorspace)((delegate* unmanaged[Cdecl]<nint, SDLColorspace>)funcTable[357])((nint)surface);
			#endif
		}

		/// <summary>
		/// Get the colorspace used by a surface.<br/>
		/// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point<br/>
		/// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for<br/>
		/// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Colorspace")]
		public static SDLColorspace GetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			SDLColorspace ret = GetSurfaceColorspaceNative(surface);
			return ret;
		}

		/// <summary>
		/// Get the colorspace used by a surface.<br/>
		/// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point<br/>
		/// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for<br/>
		/// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorspace")]
		[return: NativeName(NativeNameType.Type, "SDL_Colorspace")]
		public static SDLColorspace GetSurfaceColorspace([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLColorspace ret = GetSurfaceColorspaceNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Create a palette and associate it with a surface.<br/>
		/// This function creates a palette compatible with the provided surface. The<br/>
		/// palette is then returned for you to modify, and the surface will<br/>
		/// automatically use the new palette in future operations. You do not need to<br/>
		/// destroy the returned palette, it will be freed when the reference count<br/>
		/// reaches 0, usually when the surface is destroyed.<br/>
		/// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or<br/>
		/// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as<br/>
		/// white and 1 as black. Other surfaces will get a palette initialized with<br/>
		/// white in every entry.<br/>
		/// If this function is called for a surface that already has a palette, a new<br/>
		/// palette will be created to replace it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPalette* CreateSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPalette*>)funcTable[358])(surface);
			#else
			return (SDLPalette*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[358])((nint)surface);
			#endif
		}

		/// <summary>
		/// Create a palette and associate it with a surface.<br/>
		/// This function creates a palette compatible with the provided surface. The<br/>
		/// palette is then returned for you to modify, and the surface will<br/>
		/// automatically use the new palette in future operations. You do not need to<br/>
		/// destroy the returned palette, it will be freed when the reference count<br/>
		/// reaches 0, usually when the surface is destroyed.<br/>
		/// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or<br/>
		/// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as<br/>
		/// white and 1 as black. Other surfaces will get a palette initialized with<br/>
		/// white in every entry.<br/>
		/// If this function is called for a surface that already has a palette, a new<br/>
		/// palette will be created to replace it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		public static SDLPalette* CreateSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface)
		{
			SDLPalette* ret = CreateSurfacePaletteNative(surface);
			return ret;
		}

		/// <summary>
		/// Create a palette and associate it with a surface.<br/>
		/// This function creates a palette compatible with the provided surface. The<br/>
		/// palette is then returned for you to modify, and the surface will<br/>
		/// automatically use the new palette in future operations. You do not need to<br/>
		/// destroy the returned palette, it will be freed when the reference count<br/>
		/// reaches 0, usually when the surface is destroyed.<br/>
		/// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or<br/>
		/// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as<br/>
		/// white and 1 as black. Other surfaces will get a palette initialized with<br/>
		/// white in every entry.<br/>
		/// If this function is called for a surface that already has a palette, a new<br/>
		/// palette will be created to replace it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette *")]
		public static SDLPalette* CreateSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLPalette* ret = CreateSurfacePaletteNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette *")] SDLPalette* palette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLPalette*, int>)funcTable[359])(surface, palette);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[359])((nint)surface, (nint)palette);
			#endif
		}
	}
}
