// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, ref int top, int* left, ref int bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, int* top, ref int left, ref int bottom, int* right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					byte ret = GetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, right);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, ref int top, ref int left, ref int bottom, int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						byte ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, right);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, ref int bottom, int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, right);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, int* top, int* left, int* bottom, ref int right)
		{
			fixed (int* pright = &right)
			{
				byte ret = GetWindowBordersSizeNative(window, top, left, bottom, (int*)pright);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, int* top, int* left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, ref int top, int* left, int* bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative(window, (int*)ptop, left, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, int* top, ref int left, int* bottom, ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative(window, top, (int*)pleft, bottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, ref int top, ref int left, int* bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, bottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, int* bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, int* top, int* left, ref int bottom, ref int right)
		{
			fixed (int* pbottom = &bottom)
			{
				fixed (int* pright = &right)
				{
					byte ret = GetWindowBordersSizeNative(window, top, left, (int*)pbottom, (int*)pright);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, int* top, int* left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, ref int top, int* left, ref int bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, ref int top, int* left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, int* top, ref int left, ref int bottom, ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						byte ret = GetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, (int*)pright);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, int* top, ref int left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(SDLWindow* window, ref int top, ref int left, ref int bottom, ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							byte ret = GetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns false), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns false if getting the information is not<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowBordersSize(ref SDLWindow window, ref int top, ref int left, ref int bottom, ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							fixed (int* pright = &right)
							{
								byte ret = GetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowSizeInPixelsNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[536])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[536])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(SDLWindow* window, int* w, int* h)
		{
			byte ret = GetWindowSizeInPixelsNative(window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowSizeInPixelsNative(window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowSizeInPixelsNative(window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowSizeInPixelsNative(window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a window's client area, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSizeInPixels(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMinimumSizeNative(SDLWindow* window, int minW, int minH)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[537])(window, minW, minH);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[537])((nint)window, minW, minH);
			#endif
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMinimumSize(SDLWindow* window, int minW, int minH)
		{
			byte ret = SetWindowMinimumSizeNative(window, minW, minH);
			return ret != 0;
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMinimumSize(ref SDLWindow window, int minW, int minH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMinimumSizeNative((SDLWindow*)pwindow, minW, minH);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMinimumSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[538])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[538])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(SDLWindow* window, int* w, int* h)
		{
			byte ret = GetWindowMinimumSizeNative(window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowMinimumSizeNative(window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowMinimumSizeNative(window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMinimumSizeNative(window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMinimumSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMaximumSizeNative(SDLWindow* window, int maxW, int maxH)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[539])(window, maxW, maxH);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[539])((nint)window, maxW, maxH);
			#endif
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMaximumSize(SDLWindow* window, int maxW, int maxH)
		{
			byte ret = SetWindowMaximumSizeNative(window, maxW, maxH);
			return ret != 0;
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMaximumSize(ref SDLWindow window, int maxW, int maxH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMaximumSizeNative((SDLWindow*)pwindow, maxW, maxH);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMaximumSizeNative(SDLWindow* window, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, int*, byte>)funcTable[540])(window, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[540])((nint)window, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(SDLWindow* window, int* w, int* h)
		{
			byte ret = GetWindowMaximumSizeNative(window, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(ref SDLWindow window, int* w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(SDLWindow* window, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetWindowMaximumSizeNative(window, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(ref SDLWindow window, ref int w, int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(SDLWindow* window, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetWindowMaximumSizeNative(window, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(ref SDLWindow window, int* w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(SDLWindow* window, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetWindowMaximumSizeNative(window, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMaximumSize(ref SDLWindow window, ref int w, ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowBorderedNative(SDLWindow* window, byte bordered)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[541])(window, bordered);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[541])((nint)window, bordered);
			#endif
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowBordered(SDLWindow* window, bool bordered)
		{
			byte ret = SetWindowBorderedNative(window, bordered ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowBordered(ref SDLWindow window, bool bordered)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowBorderedNative((SDLWindow*)pwindow, bordered ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowResizableNative(SDLWindow* window, byte resizable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[542])(window, resizable);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[542])((nint)window, resizable);
			#endif
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowResizable(SDLWindow* window, bool resizable)
		{
			byte ret = SetWindowResizableNative(window, resizable ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowResizable(ref SDLWindow window, bool resizable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowResizableNative((SDLWindow*)pwindow, resizable ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowAlwaysOnTopNative(SDLWindow* window, byte onTop)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[543])(window, onTop);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[543])((nint)window, onTop);
			#endif
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowAlwaysOnTop(SDLWindow* window, bool onTop)
		{
			byte ret = SetWindowAlwaysOnTopNative(window, onTop ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowAlwaysOnTop(ref SDLWindow window, bool onTop)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowAlwaysOnTopNative((SDLWindow*)pwindow, onTop ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[544])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[544])((nint)window);
			#endif
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ShowWindow(SDLWindow* window)
		{
			byte ret = ShowWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ShowWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ShowWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HideWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[545])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[545])((nint)window);
			#endif
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HideWindow(SDLWindow* window)
		{
			byte ret = HideWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HideWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = HideWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RaiseWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[546])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[546])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool RaiseWindow(SDLWindow* window)
		{
			byte ret = RaiseWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that a window be raised above other windows and gain the input<br/>
		/// focus.<br/>
		/// The result of this request is subject to desktop window manager policy,<br/>
		/// particularly if raising the requested window would result in stealing focus<br/>
		/// from another application. If the window is successfully raised and gains<br/>
		/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
		/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool RaiseWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = RaiseWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MaximizeWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[547])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[547])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool MaximizeWindow(SDLWindow* window)
		{
			byte ret = MaximizeWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window be made as large as possible.<br/>
		/// Non-resizable windows can't be maximized. The window must have the<br/>
		/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// When maximizing a window, whether the constraints set via<br/>
		/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
		/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
		/// and Wayland window managers may vary.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool MaximizeWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = MaximizeWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte MinimizeWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[548])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[548])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool MinimizeWindow(SDLWindow* window)
		{
			byte ret = MinimizeWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window be minimized to an iconic representation.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool MinimizeWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = MinimizeWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RestoreWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[549])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[549])((nint)window);
			#endif
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RestoreWindow(SDLWindow* window)
		{
			byte ret = RestoreWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Request that the size and position of a minimized or maximized window be<br/>
		/// restored.<br/>
		/// If the window is in a fullscreen state, this request has no direct effect.<br/>
		/// It may alter the state the window is returned to when leaving fullscreen.<br/>
		/// On some windowing systems this request is asynchronous and the new window<br/>
		/// state may not have have been applied immediately upon the return of this<br/>
		/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
		/// block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
		/// emitted. Note that, as this is just a request, the windowing system can<br/>
		/// deny the state change.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RestoreWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = RestoreWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowFullscreenNative(SDLWindow* window, byte fullscreen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[550])(window, fullscreen);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[550])((nint)window, fullscreen);
			#endif
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowFullscreen(SDLWindow* window, bool fullscreen)
		{
			byte ret = SetWindowFullscreenNative(window, fullscreen ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Request that the window's fullscreen state be changed.<br/>
		/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
		/// mode, but a specific exclusive display mode can be set using<br/>
		/// SDL_SetWindowFullscreenMode().<br/>
		/// On some windowing systems this request is asynchronous and the new<br/>
		/// fullscreen state may not have have been applied immediately upon the return<br/>
		/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
		/// to block until the changes have taken effect.<br/>
		/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
		/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
		/// is just a request, it can be denied by the windowing system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowFullscreen(ref SDLWindow window, bool fullscreen)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowFullscreenNative((SDLWindow*)pwindow, fullscreen ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SyncWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[551])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[551])((nint)window);
			#endif
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SyncWindow(SDLWindow* window)
		{
			byte ret = SyncWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Block until any pending window state is finalized.<br/>
		/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
		/// for pending window state. It will attempt to wait until any pending window<br/>
		/// state has been applied and is guaranteed to return within finite time. Note<br/>
		/// that for how long it can potentially block depends on the underlying window<br/>
		/// system, as window state changes may involve somewhat lengthy animations<br/>
		/// that must complete before the window is in its final requested state.<br/>
		/// On windowing systems where changes are immediate, this does nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SyncWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SyncWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowHasSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[552])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[552])((nint)window);
			#endif
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowHasSurface(SDLWindow* window)
		{
			byte ret = WindowHasSurfaceNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowHasSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowHasSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* GetWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*>)funcTable[553])(window);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[553])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* GetWindowSurface(SDLWindow* window)
		{
			SDLSurface* ret = GetWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLSurface* GetWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSurface* ret = GetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowSurfaceVSyncNative(SDLWindow* window, int vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, byte>)funcTable[554])(window, vsync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[554])((nint)window, vsync);
			#endif
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowSurfaceVSync(SDLWindow* window, int vsync)
		{
			byte ret = SetWindowSurfaceVSyncNative(window, vsync);
			return ret != 0;
		}

		/// <summary>
		/// Toggle VSync for the window surface.<br/>
		/// When a window surface is created, vsync defaults to<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
		/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
		/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
		/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
		/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
		/// supported by every driver, so you should check the return value to see<br/>
		/// whether the requested setting is supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowSurfaceVSync(ref SDLWindow window, int vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowSurfaceVSyncNative((SDLWindow*)pwindow, vsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowSurfaceVSyncNative(SDLWindow* window, int* vsync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int*, byte>)funcTable[555])(window, vsync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[555])((nint)window, (nint)vsync);
			#endif
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSurfaceVSync(SDLWindow* window, int* vsync)
		{
			byte ret = GetWindowSurfaceVSyncNative(window, vsync);
			return ret != 0;
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSurfaceVSync(ref SDLWindow window, int* vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)pwindow, vsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSurfaceVSync(SDLWindow* window, ref int vsync)
		{
			fixed (int* pvsync = &vsync)
			{
				byte ret = GetWindowSurfaceVSyncNative(window, (int*)pvsync);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get VSync for the window surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowSurfaceVSync(ref SDLWindow window, ref int vsync)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pvsync = &vsync)
				{
					byte ret = GetWindowSurfaceVSyncNative((SDLWindow*)pwindow, (int*)pvsync);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[556])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[556])((nint)window);
			#endif
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateWindowSurface(SDLWindow* window)
		{
			byte ret = UpdateWindowSurfaceNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = UpdateWindowSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateWindowSurfaceRectsNative(SDLWindow* window, SDLRect* rects, int numrects)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, int, byte>)funcTable[557])(window, rects, numrects);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[557])((nint)window, (nint)rects, numrects);
			#endif
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateWindowSurfaceRects(SDLWindow* window, SDLRect* rects, int numrects)
		{
			byte ret = UpdateWindowSurfaceRectsNative(window, rects, numrects);
			return ret != 0;
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateWindowSurfaceRects(ref SDLWindow window, SDLRect* rects, int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, rects, numrects);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateWindowSurfaceRects(SDLWindow* window, ref SDLRect rects, int numrects)
		{
			fixed (SDLRect* prects = &rects)
			{
				byte ret = UpdateWindowSurfaceRectsNative(window, (SDLRect*)prects, numrects);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// Note that this function will update _at least_ the rectangles specified,<br/>
		/// but this is only intended as an optimization; in practice, this might<br/>
		/// update more of the screen (or all of the screen!), depending on what method<br/>
		/// SDL uses to send pixels to the system.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateWindowSurfaceRects(ref SDLWindow window, ref SDLRect rects, int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prects = &rects)
				{
					byte ret = UpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)prects, numrects);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DestroyWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[558])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[558])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool DestroyWindowSurface(SDLWindow* window)
		{
			byte ret = DestroyWindowSurfaceNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool DestroyWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = DestroyWindowSurfaceNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowKeyboardGrabNative(SDLWindow* window, byte grabbed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[559])(window, grabbed);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[559])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowKeyboardGrab(SDLWindow* window, bool grabbed)
		{
			byte ret = SetWindowKeyboardGrabNative(window, grabbed ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowKeyboardGrab(ref SDLWindow window, bool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowKeyboardGrabNative((SDLWindow*)pwindow, grabbed ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMouseGrabNative(SDLWindow* window, byte grabbed)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[560])(window, grabbed);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[560])((nint)window, grabbed);
			#endif
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMouseGrab(SDLWindow* window, bool grabbed)
		{
			byte ret = SetWindowMouseGrabNative(window, grabbed ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMouseGrab(ref SDLWindow window, bool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMouseGrabNative((SDLWindow*)pwindow, grabbed ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowKeyboardGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[561])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[561])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowKeyboardGrab(SDLWindow* window)
		{
			byte ret = GetWindowKeyboardGrabNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowKeyboardGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowKeyboardGrabNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetWindowMouseGrabNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[562])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[562])((nint)window);
			#endif
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMouseGrab(SDLWindow* window)
		{
			byte ret = GetWindowMouseGrabNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetWindowMouseGrab(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GetWindowMouseGrabNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetGrabbedWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[563])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[563])();
			#endif
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GetGrabbedWindow()
		{
			SDLWindow* ret = GetGrabbedWindowNative();
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowMouseRectNative(SDLWindow* window, SDLRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*, byte>)funcTable[564])(window, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[564])((nint)window, (nint)rect);
			#endif
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMouseRect(SDLWindow* window, SDLRect* rect)
		{
			byte ret = SetWindowMouseRectNative(window, rect);
			return ret != 0;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMouseRect(ref SDLWindow window, SDLRect* rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowMouseRectNative((SDLWindow*)pwindow, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMouseRect(SDLWindow* window, ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = SetWindowMouseRectNative(window, (SDLRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowMouseRect(ref SDLWindow window, ref SDLRect rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = SetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRect* GetWindowMouseRectNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRect*>)funcTable[565])(window);
			#else
			return (SDLRect*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[565])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRect* GetWindowMouseRect(SDLWindow* window)
		{
			SDLRect* ret = GetWindowMouseRectNative(window);
			return ret;
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRect* GetWindowMouseRect(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRect* ret = GetWindowMouseRectNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowOpacityNative(SDLWindow* window, float opacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float, byte>)funcTable[566])(window, opacity);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, byte>)funcTable[566])((nint)window, opacity);
			#endif
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowOpacity(SDLWindow* window, float opacity)
		{
			byte ret = SetWindowOpacityNative(window, opacity);
			return ret != 0;
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns false if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowOpacity(ref SDLWindow window, float opacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowOpacityNative((SDLWindow*)pwindow, opacity);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetWindowOpacityNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, float>)funcTable[567])(window);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[567])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetWindowOpacity(SDLWindow* window)
		{
			float ret = GetWindowOpacityNative(window);
			return ret;
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be returned<br/>
		/// as 1.0f without error.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static float GetWindowOpacity(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				float ret = GetWindowOpacityNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowParentNative(SDLWindow* window, SDLWindow* parent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLWindow*, byte>)funcTable[568])(window, parent);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[568])((nint)window, (nint)parent);
			#endif
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowParent(SDLWindow* window, SDLWindow* parent)
		{
			byte ret = SetWindowParentNative(window, parent);
			return ret != 0;
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowParent(ref SDLWindow window, SDLWindow* parent)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowParentNative((SDLWindow*)pwindow, parent);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowParent(SDLWindow* window, ref SDLWindow parent)
		{
			fixed (SDLWindow* pparent = &parent)
			{
				byte ret = SetWindowParentNative(window, (SDLWindow*)pparent);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the window as a child of a parent window.<br/>
		/// If the window is already the child of an existing window, it will be<br/>
		/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
		/// the window and removes child window status.<br/>
		/// If a parent window is hidden or destroyed, the operation will be<br/>
		/// recursively applied to child windows. Child windows hidden with the parent<br/>
		/// that did not have their hidden status explicitly set will be restored when<br/>
		/// the parent is shown.<br/>
		/// Attempting to set the parent of a window that is currently in the modal<br/>
		/// state will fail. Use SDL_SetWindowModal() to cancel the modal status before<br/>
		/// attempting to change the parent.<br/>
		/// Popup windows cannot change parents and attempts to do so will fail.<br/>
		/// Setting a parent window that is currently the sibling or descendent of the<br/>
		/// child window results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowParent(ref SDLWindow window, ref SDLWindow parent)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindow* pparent = &parent)
				{
					byte ret = SetWindowParentNative((SDLWindow*)pwindow, (SDLWindow*)pparent);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowModalNative(SDLWindow* window, byte modal)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[569])(window, modal);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[569])((nint)window, modal);
			#endif
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowModal(SDLWindow* window, bool modal)
		{
			byte ret = SetWindowModalNative(window, modal ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Toggle the state of the window as modal.<br/>
		/// To enable modal status on a window, the window must currently be the child<br/>
		/// window of a parent, or toggling modal status on will fail.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowModal(ref SDLWindow window, bool modal)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowModalNative((SDLWindow*)pwindow, modal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowFocusableNative(SDLWindow* window, byte focusable)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte, byte>)funcTable[570])(window, focusable);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[570])((nint)window, focusable);
			#endif
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowFocusable(SDLWindow* window, bool focusable)
		{
			byte ret = SetWindowFocusableNative(window, focusable ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set whether the window may have input focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowFocusable(ref SDLWindow window, bool focusable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowFocusableNative((SDLWindow*)pwindow, focusable ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowWindowSystemMenuNative(SDLWindow* window, int x, int y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, int, int, byte>)funcTable[571])(window, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte>)funcTable[571])((nint)window, x, y);
			#endif
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ShowWindowSystemMenu(SDLWindow* window, int x, int y)
		{
			byte ret = ShowWindowSystemMenuNative(window, x, y);
			return ret != 0;
		}

		/// <summary>
		/// Display the system-level window menu.<br/>
		/// This default window menu is provided by the system and on some platforms<br/>
		/// provides functionality for setting or changing privileged state on the<br/>
		/// window, such as moving it between workspaces or displays, or toggling the<br/>
		/// always-on-top property.<br/>
		/// On platforms or desktops where this is unsupported, this function does<br/>
		/// nothing.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool ShowWindowSystemMenu(ref SDLWindow window, int x, int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ShowWindowSystemMenuNative((SDLWindow*)pwindow, x, y);
				return ret != 0;
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowHitTestNative(SDLWindow* window, SDLHitTest callback, void* callbackData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>, void*, byte>)funcTable[572])(window, (delegate*<SDLWindow*, SDLPoint*, void*, SDLHitTestResult>)Utils.GetFunctionPointerForDelegate(callback), callbackData);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[572])((nint)window, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)callbackData);
			#endif
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowHitTest(SDLWindow* window, SDLHitTest callback, void* callbackData)
		{
			byte ret = SetWindowHitTestNative(window, callback, callbackData);
			return ret != 0;
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return false<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowHitTest(ref SDLWindow window, SDLHitTest callback, void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowHitTestNative((SDLWindow*)pwindow, callback, callbackData);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetWindowShapeNative(SDLWindow* window, SDLSurface* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLSurface*, byte>)funcTable[573])(window, shape);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[573])((nint)window, (nint)shape);
			#endif
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowShape(SDLWindow* window, SDLSurface* shape)
		{
			byte ret = SetWindowShapeNative(window, shape);
			return ret != 0;
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowShape(ref SDLWindow window, SDLSurface* shape)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetWindowShapeNative((SDLWindow*)pwindow, shape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowShape(SDLWindow* window, ref SDLSurface shape)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				byte ret = SetWindowShapeNative(window, (SDLSurface*)pshape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the shape of a transparent window.<br/>
		/// This sets the alpha channel of a transparent window and any fully<br/>
		/// transparent areas are also transparent to mouse clicks. If you are using<br/>
		/// something besides the SDL render API, then you are responsible for drawing<br/>
		/// the alpha channel of the window to match the shape alpha channel to get<br/>
		/// consistent cross-platform results.<br/>
		/// The shape is copied inside this function, so you can free it afterwards. If<br/>
		/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
		/// update the window. This is an expensive operation, so should be done<br/>
		/// sparingly.<br/>
		/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool SetWindowShape(ref SDLWindow window, ref SDLSurface shape)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					byte ret = SetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FlashWindowNative(SDLWindow* window, SDLFlashOperation operation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLFlashOperation, byte>)funcTable[574])(window, operation);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLFlashOperation, byte>)funcTable[574])((nint)window, operation);
			#endif
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool FlashWindow(SDLWindow* window, SDLFlashOperation operation)
		{
			byte ret = FlashWindowNative(window, operation);
			return ret != 0;
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool FlashWindow(ref SDLWindow window, SDLFlashOperation operation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = FlashWindowNative((SDLWindow*)pwindow, operation);
				return ret != 0;
			}
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any child windows owned by the window will be recursively destroyed as<br/>
		/// well.<br/>
		/// Note that on some platforms, the visible window may not actually be removed<br/>
		/// from the screen until the SDL event loop is pumped again, even though the<br/>
		/// SDL_Window is no longer valid after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyWindowNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLWindow*, void>)funcTable[575])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[575])((nint)window);
			#endif
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any child windows owned by the window will be recursively destroyed as<br/>
		/// well.<br/>
		/// Note that on some platforms, the visible window may not actually be removed<br/>
		/// from the screen until the SDL event loop is pumped again, even though the<br/>
		/// SDL_Window is no longer valid after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyWindow(SDLWindow* window)
		{
			DestroyWindowNative(window);
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// Any child windows owned by the window will be recursively destroyed as<br/>
		/// well.<br/>
		/// Note that on some platforms, the visible window may not actually be removed<br/>
		/// from the screen until the SDL event loop is pumped again, even though the<br/>
		/// SDL_Window is no longer valid after this call.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyWindow(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				DestroyWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ScreenSaverEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[576])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[576])();
			#endif
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ScreenSaverEnabled()
		{
			byte ret = ScreenSaverEnabledNative();
			return ret != 0;
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EnableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[577])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[577])();
			#endif
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool EnableScreenSaver()
		{
			byte ret = EnableScreenSaverNative();
			return ret != 0;
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default, but this may by changed by<br/>
		/// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DisableScreenSaverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[578])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[578])();
			#endif
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default, but this may by changed by<br/>
		/// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool DisableScreenSaver()
		{
			byte ret = DisableScreenSaverNative();
			return ret != 0;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLLoadLibraryNative(byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[579])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[579])((nint)path);
			#endif
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLLoadLibrary(byte* path)
		{
			byte ret = GLLoadLibraryNative(path);
			return ret != 0;
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLLoadLibrary(ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = GLLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLLoadLibrary(ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				byte ret = GLLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLLoadLibrary(string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GLLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> GLGetProcAddressNative(byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[580])(proc);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[580])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GLGetProcAddress(byte* proc)
		{
			delegate*<void> ret = GLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GLGetProcAddress(ref byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				delegate*<void> ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GLGetProcAddress(ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				delegate*<void> ret = GLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GLGetProcAddress(string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = GLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> EGLGetProcAddressNative(byte* proc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[581])(proc);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[581])((nint)proc);
			#endif
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> EGLGetProcAddress(byte* proc)
		{
			delegate*<void> ret = EGLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> EGLGetProcAddress(ref byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				delegate*<void> ret = EGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> EGLGetProcAddress(ReadOnlySpan<byte> proc)
		{
			fixed (byte* pproc = proc)
			{
				delegate*<void> ret = EGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>
		/// Get an EGL library function by name.<br/>
		/// If an EGL library is loaded, this function allows applications to get entry<br/>
		/// points for EGL functions. This is useful to provide to an EGL API and<br/>
		/// extension loader.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> EGLGetProcAddress(string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = EGLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLUnloadLibraryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[582])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[582])();
			#endif
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLUnloadLibrary()
		{
			GLUnloadLibraryNative();
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLExtensionSupportedNative(byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[583])(extension);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[583])((nint)extension);
			#endif
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GLExtensionSupported(byte* extension)
		{
			byte ret = GLExtensionSupportedNative(extension);
			return ret != 0;
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GLExtensionSupported(ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				byte ret = GLExtensionSupportedNative((byte*)pextension);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GLExtensionSupported(ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				byte ret = GLExtensionSupportedNative((byte*)pextension);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GLExtensionSupported(string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GLExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GLResetAttributesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[584])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[584])();
			#endif
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GLResetAttributes()
		{
			GLResetAttributesNative();
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSetAttributeNative(SDLGLAttr attr, int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLAttr, int, byte>)funcTable[585])(attr, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLAttr, int, byte>)funcTable[585])(attr, value);
			#endif
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLSetAttribute(SDLGLAttr attr, int value)
		{
			byte ret = GLSetAttributeNative(attr, value);
			return ret != 0;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLGetAttributeNative(SDLGLAttr attr, int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLAttr, int*, byte>)funcTable[586])(attr, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLAttr, nint, byte>)funcTable[586])(attr, (nint)value);
			#endif
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLGetAttribute(SDLGLAttr attr, int* value)
		{
			byte ret = GLGetAttributeNative(attr, value);
			return ret != 0;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLGetAttribute(SDLGLAttr attr, ref int value)
		{
			fixed (int* pvalue = &value)
			{
				byte ret = GLGetAttributeNative(attr, (int*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLCreateContextNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext>)funcTable[587])(window);
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<nint, SDLGLContext>)funcTable[587])((nint)window);
			#endif
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGLContext GLCreateContext(SDLWindow* window)
		{
			SDLGLContext ret = GLCreateContextNative(window);
			return ret;
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGLContext GLCreateContext(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLContext ret = GLCreateContextNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLMakeCurrentNative(SDLWindow* window, SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext, byte>)funcTable[588])(window, context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGLContext, byte>)funcTable[588])((nint)window, context);
			#endif
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLMakeCurrent(SDLWindow* window, SDLGLContext context)
		{
			byte ret = GLMakeCurrentNative(window, context);
			return ret != 0;
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GLMakeCurrent(ref SDLWindow window, SDLGLContext context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GLMakeCurrentNative((SDLWindow*)pwindow, context);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GLGetCurrentWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[589])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[589])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GLGetCurrentWindow()
		{
			SDLWindow* ret = GLGetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLGetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[590])();
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[590])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGLContext GLGetCurrentContext()
		{
			SDLGLContext ret = GLGetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active EGL display.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEGLDisplay EGLGetCurrentDisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEGLDisplay>)funcTable[591])();
			#else
			return (SDLEGLDisplay)((delegate* unmanaged[Cdecl]<SDLEGLDisplay>)funcTable[591])();
			#endif
		}

		/// <summary>
		/// Get the currently active EGL display.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLEGLDisplay EGLGetCurrentDisplay()
		{
			SDLEGLDisplay ret = EGLGetCurrentDisplayNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active EGL config.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEGLConfig EGLGetCurrentConfigNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEGLConfig>)funcTable[592])();
			#else
			return (SDLEGLConfig)((delegate* unmanaged[Cdecl]<SDLEGLConfig>)funcTable[592])();
			#endif
		}

		/// <summary>
		/// Get the currently active EGL config.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLEGLConfig EGLGetCurrentConfig()
		{
			SDLEGLConfig ret = EGLGetCurrentConfigNative();
			return ret;
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEGLSurface EGLGetWindowSurfaceNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLEGLSurface>)funcTable[593])(window);
			#else
			return (SDLEGLSurface)((delegate* unmanaged[Cdecl]<nint, SDLEGLSurface>)funcTable[593])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLEGLSurface EGLGetWindowSurface(SDLWindow* window)
		{
			SDLEGLSurface ret = EGLGetWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLEGLSurface EGLGetWindowSurface(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLEGLSurface ret = EGLGetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EGLSetAttributeCallbacksNative(SDLEGLAttribArrayCallback platformAttribCallback, SDLEGLIntArrayCallback surfaceAttribCallback, SDLEGLIntArrayCallback contextAttribCallback, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, nint*>, delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>, delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>, void*, void>)funcTable[594])((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[594])((nint)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (nint)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (nint)Utils.GetFunctionPointerForDelegate(contextAttribCallback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static void EGLSetAttributeCallbacks(SDLEGLAttribArrayCallback platformAttribCallback, SDLEGLIntArrayCallback surfaceAttribCallback, SDLEGLIntArrayCallback contextAttribCallback, void* userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, surfaceAttribCallback, contextAttribCallback, userdata);
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return false. In such a case, you should<br/>
		/// probably retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSetSwapIntervalNative(int interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[595])(interval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[595])(interval);
			#endif
		}
	}
}
