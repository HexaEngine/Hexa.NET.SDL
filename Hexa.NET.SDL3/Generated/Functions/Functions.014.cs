// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			byte ret = GLSetAttributeNative(attr, value);
			return ret != 0;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLGetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int *")] int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLattr, int*, byte>)funcTable[566])(attr, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLattr, nint, byte>)funcTable[566])(attr, (nint)value);
			#endif
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int *")] int* value)
		{
			byte ret = GLGetAttributeNative(attr, value);
			return ret != 0;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int *")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				byte ret = GLGetAttributeNative(attr, (int*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLCreateContextNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext>)funcTable[567])(window);
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<nint, SDLGLContext>)funcTable[567])((nint)window);
			#endif
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext GLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			SDLGLContext ret = GLCreateContextNative(window);
			return ret;
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext GLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLContext ret = GLCreateContextNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLMakeCurrentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLGLContext, byte>)funcTable[568])(window, context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGLContext, byte>)funcTable[568])((nint)window, context);
			#endif
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			byte ret = GLMakeCurrentNative(window, context);
			return ret != 0;
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GLMakeCurrentNative((SDLWindow*)pwindow, context);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GLGetCurrentWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[569])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[569])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindow* GLGetCurrentWindow()
		{
			SDLWindow* ret = GLGetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGLContext GLGetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[570])();
			#else
			return (SDLGLContext)((delegate* unmanaged[Cdecl]<SDLGLContext>)funcTable[570])();
			#endif
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext GLGetCurrentContext()
		{
			SDLGLContext ret = GLGetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active EGL display.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentDisplay")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLDisplay")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEGLDisplay EGLGetCurrentDisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEGLDisplay>)funcTable[571])();
			#else
			return (SDLEGLDisplay)((delegate* unmanaged[Cdecl]<SDLEGLDisplay>)funcTable[571])();
			#endif
		}

		/// <summary>
		/// Get the currently active EGL display.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentDisplay")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLDisplay")]
		public static SDLEGLDisplay EGLGetCurrentDisplay()
		{
			SDLEGLDisplay ret = EGLGetCurrentDisplayNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active EGL config.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentConfig")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLConfig")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEGLConfig EGLGetCurrentConfigNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLEGLConfig>)funcTable[572])();
			#else
			return (SDLEGLConfig)((delegate* unmanaged[Cdecl]<SDLEGLConfig>)funcTable[572])();
			#endif
		}

		/// <summary>
		/// Get the currently active EGL config.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetCurrentConfig")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLConfig")]
		public static SDLEGLConfig EGLGetCurrentConfig()
		{
			SDLEGLConfig ret = EGLGetCurrentConfigNative();
			return ret;
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLSurface")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLEGLSurface EGLGetWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLEGLSurface>)funcTable[573])(window);
			#else
			return (SDLEGLSurface)((delegate* unmanaged[Cdecl]<nint, SDLEGLSurface>)funcTable[573])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLSurface")]
		public static SDLEGLSurface EGLGetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			SDLEGLSurface ret = EGLGetWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// Get the EGL surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_EGLSurface")]
		public static SDLEGLSurface EGLGetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLEGLSurface ret = EGLGetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EGLSetAttributeCallbacksNative([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, nint*>, delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>, delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>, void*, void>)funcTable[574])((delegate*<void*, nint*>)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (delegate*<void*, SDLEGLDisplay, SDLEGLConfig, int*>)Utils.GetFunctionPointerForDelegate(contextAttribCallback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[574])((nint)Utils.GetFunctionPointerForDelegate(platformAttribCallback), (nint)Utils.GetFunctionPointerForDelegate(surfaceAttribCallback), (nint)Utils.GetFunctionPointerForDelegate(contextAttribCallback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
		/// initialization.<br/>
		/// Callbacks that aren't needed can be set to NULL.<br/>
		/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EGL_SetAttributeCallbacks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EGLSetAttributeCallbacks([NativeName(NativeNameType.Param, "platformAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLAttribArrayCallback")] SDLEGLAttribArrayCallback platformAttribCallback, [NativeName(NativeNameType.Param, "surfaceAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback surfaceAttribCallback, [NativeName(NativeNameType.Param, "contextAttribCallback")] [NativeName(NativeNameType.Type, "SDL_EGLIntArrayCallback")] SDLEGLIntArrayCallback contextAttribCallback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			EGLSetAttributeCallbacksNative(platformAttribCallback, surfaceAttribCallback, contextAttribCallback, userdata);
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return false. In such a case, you should<br/>
		/// probably retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSetSwapIntervalNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[575])(interval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[575])(interval);
			#endif
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return false. In such a case, you should<br/>
		/// probably retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			byte ret = GLSetSwapIntervalNative(interval);
			return ret != 0;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLGetSwapIntervalNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int *")] int* interval)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, byte>)funcTable[576])(interval);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[576])((nint)interval);
			#endif
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int *")] int* interval)
		{
			byte ret = GLGetSwapIntervalNative(interval);
			return ret != 0;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will set *interval to 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLGetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int *")] ref int interval)
		{
			fixed (int* pinterval = &interval)
			{
				byte ret = GLGetSwapIntervalNative((int*)pinterval);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLSwapWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[577])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[577])((nint)window);
			#endif
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = GLSwapWindowNative(window);
			return ret != 0;
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = GLSwapWindowNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_DestroyContext")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GLDestroyContextNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGLContext, byte>)funcTable[578])(context);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGLContext, byte>)funcTable[578])(context);
			#endif
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_DestroyContext")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GLDestroyContext([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			byte ret = GLDestroyContextNative(context);
			return ret != 0;
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFileDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] byte allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, byte, void>)funcTable[579])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, filters, nfilters, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, byte, void>)funcTable[579])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFileDialogNative(callback, userdata, window, filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a file on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowOpenFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0, allowMany ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowSaveFileDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, SDLDialogFileFilter*, int, byte*, void>)funcTable[580])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, filters, nfilters, defaultLocation);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, nint, void>)funcTable[580])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)filters, nfilters, (nint)defaultLocation);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, defaultLocation);
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, defaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, (byte*)pdefaultLocation);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowSaveFileDialogNative(callback, userdata, window, filters, nfilters, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] SDLDialogFileFilter* filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, filters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLDialogFileFilter* pfilters = &filters)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowSaveFileDialogNative(callback, userdata, window, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = &defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					fixed (byte* pdefaultLocation = defaultLocation)
					{
						ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, (byte*)pdefaultLocation);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user choose a new or existing file on their<br/>
		/// filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// The chosen file may or may not already exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSaveFileDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowSaveFileDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "filters")] [NativeName(NativeNameType.Type, "SDL_DialogFileFilter const *")] ref SDLDialogFileFilter filters, [NativeName(NativeNameType.Param, "nfilters")] [NativeName(NativeNameType.Type, "int")] int nfilters, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDialogFileFilter* pfilters = &filters)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (defaultLocation != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ShowSaveFileDialogNative(callback, userdata, (SDLWindow*)pwindow, (SDLDialogFileFilter*)pfilters, nfilters, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShowOpenFolderDialogNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] byte allowMany)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<void*, byte**, int, void>, void*, SDLWindow*, byte*, byte, void>)funcTable[581])((delegate*<void*, byte**, int, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, window, defaultLocation, allowMany);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte, void>)funcTable[581])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, (nint)window, (nint)defaultLocation, allowMany);
			#endif
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			ShowOpenFolderDialogNative(callback, userdata, window, defaultLocation, allowMany ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, defaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = &defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (byte* pdefaultLocation = defaultLocation)
			{
				ShowOpenFolderDialogNative(callback, userdata, window, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultLocation != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShowOpenFolderDialogNative(callback, userdata, window, pStr0, allowMany ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = &defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pdefaultLocation = defaultLocation)
				{
					ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, (byte*)pdefaultLocation, allowMany ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
		/// This function should only be invoked from the main thread.<br/>
		/// This is an asynchronous function; it will return immediately, and the<br/>
		/// result will be passed to the callback.<br/>
		/// The callback will be invoked with a null-terminated list of files the user<br/>
		/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
		/// be NULL if an error occurred.<br/>
		/// Note that the callback may be called from a different thread than the one<br/>
		/// the function was invoked on.<br/>
		/// Depending on the platform, the user may be allowed to input paths that<br/>
		/// don't yet exist.<br/>
		/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
		/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
		/// should add a call to SDL_PumpEvents in their main loop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowOpenFolderDialog")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShowOpenFolderDialog([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_DialogFileCallback")] SDLDialogFileCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "default_location")] [NativeName(NativeNameType.Type, "char const *")] string defaultLocation, [NativeName(NativeNameType.Param, "allow_many")] [NativeName(NativeNameType.Type, "bool")] bool allowMany)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (defaultLocation != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(defaultLocation);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(defaultLocation, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ShowOpenFolderDialogNative(callback, userdata, (SDLWindow*)pwindow, pStr0, allowMany ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GUIDToStringNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, byte*, int, void>)funcTable[582])(guid, pszGUID, cbGUID);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, int, void>)funcTable[582])(guid, (nint)pszGUID, cbGUID);
			#endif
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			GUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] ref byte pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				GUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_GUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char *")] ref string pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid StringToGUIDNative([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] byte* pchGUID)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SdlGuid>)funcTable[583])(pchGUID);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[583])((nint)pchGUID);
			#endif
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] byte* pchGUID)
		{
			SdlGuid ret = StringToGUIDNative(pchGUID);
			return ret;
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pchGUID)
		{
			fixed (byte* ppchGUID = pchGUID)
			{
				SdlGuid ret = StringToGUIDNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StringToGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid StringToGUID([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "char const *")] string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdlGuid ret = StringToGUIDNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetPowerInfoNative([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*, SDLPowerState>)funcTable[584])(seconds, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[584])((nint)seconds, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			SDLPowerState ret = GetPowerInfoNative(seconds, percent);
			return ret;
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			fixed (int* pseconds = &seconds)
			{
				SDLPowerState ret = GetPowerInfoNative((int*)pseconds, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetPowerInfoNative(seconds, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int *")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (int* pseconds = &seconds)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetPowerInfoNative((int*)pseconds, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetSensorsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[585])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[585])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		public static int* GetSensors([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = GetSensorsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected sensors.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensors")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID *")]
		public static int* GetSensors([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetSensorsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[586])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[586])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			byte* ret = GetSensorNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[587])(instanceId);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<int, SDLSensorType>)funcTable[587])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensorType ret = GetSensorTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableTypeForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[588])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[588])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// This can be called before any sensors are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableTypeForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			int ret = GetSensorNonPortableTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* OpenSensorNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[589])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[589])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		public static SDLSensor* OpenSensor([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensor* ret = OpenSensorNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensor* GetSensorFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLSensor*>)funcTable[590])(instanceId);
			#else
			return (SDLSensor*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[590])(instanceId);
			#endif
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance ID.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor *")]
		public static SDLSensor* GetSensorFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensor* ret = GetSensorFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSensorPropertiesNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, uint>)funcTable[591])(sensor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[591])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSensorProperties([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			uint ret = GetSensorPropertiesNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetSensorProperties([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				uint ret = GetSensorPropertiesNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSensorNameNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, byte*>)funcTable[592])(sensor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[592])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			byte* ret = GetSensorNameNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			string ret = Utils.DecodeStringUTF8(GetSensorNameNative(sensor));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetSensorName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte* ret = GetSensorNameNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetSensorNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				string ret = Utils.DecodeStringUTF8(GetSensorNameNative((SDLSensor*)psensor));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSensorType GetSensorTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, SDLSensorType>)funcTable[593])(sensor);
			#else
			return (SDLSensorType)((delegate* unmanaged[Cdecl]<nint, SDLSensorType>)funcTable[593])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			SDLSensorType ret = GetSensorTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType GetSensorType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorType ret = GetSensorTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorNonPortableTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[594])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[594])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			int ret = GetSensorNonPortableTypeNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetSensorNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorNonPortableTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSensorIDNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, int>)funcTable[595])(sensor);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[595])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int GetSensorID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			int ret = GetSensorIDNative(sensor);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int GetSensorID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = GetSensorIDNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetSensorDataNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSensor*, float*, int, byte>)funcTable[596])(sensor, data, numValues);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[596])((nint)sensor, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			byte ret = GetSensorDataNative(sensor, data, numValues);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte ret = GetSensorDataNative((SDLSensor*)psensor, data, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				byte ret = GetSensorDataNative(sensor, (float*)pdata, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetSensorData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					byte ret = GetSensorDataNative((SDLSensor*)psensor, (float*)pdata, numValues);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseSensorNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSensor*, void>)funcTable[597])(sensor);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[597])((nint)sensor);
			#endif
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseSensor([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] SDLSensor* sensor)
		{
			CloseSensorNative(sensor);
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_OpenSensor().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseSensor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseSensor([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor *")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				CloseSensorNative((SDLSensor*)psensor);
			}
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateSensorsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[598])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[598])();
			#endif
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateSensors()
		{
			UpdateSensorsNative();
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[599])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[599])();
			#endif
		}

		/// <summary>
		/// Locking for atomic access to the joystick API.<br/>
		/// The SDL joystick functions are thread-safe, however you can lock the<br/>
		/// joysticks while processing to guarantee that the joystick list won't change<br/>
		/// and joystick and gamepad events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockJoysticks()
		{
			LockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockJoysticksNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[600])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[600])();
			#endif
		}

		/// <summary>
		/// Unlocking for atomic access to the joystick API.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockJoysticks()
		{
			UnlockJoysticksNative();
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasJoystick")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasJoystickNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[601])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[601])();
			#endif
		}

		/// <summary>
		/// Return whether a joystick is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasJoystick")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasJoystick()
		{
			byte ret = HasJoystickNative();
			return ret != 0;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetJoysticksNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int*>)funcTable[602])(count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[602])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		public static int* GetJoysticks([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = GetJoysticksNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected joysticks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoysticks")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID *")]
		public static int* GetJoysticks([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetJoysticksNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[603])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[603])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte* ret = GetJoystickNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickPathForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[604])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[604])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickPathForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte* ret = GetJoystickPathForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPathForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickPathForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickPathForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndexForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickPlayerIndexForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[605])(instanceId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[605])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the player index of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndexForID")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetJoystickPlayerIndexForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			int ret = GetJoystickPlayerIndexForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDForID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetJoystickGUIDForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[606])(instanceId);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<int, SdlGuid>)funcTable[606])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDForID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid GetJoystickGUIDForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SdlGuid ret = GetJoystickGUIDForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendorForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickVendorForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[607])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[607])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendorForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickVendorForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickVendorForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[608])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[608])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickProductForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersionForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductVersionForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[609])(instanceId);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<int, ushort>)funcTable[609])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersionForID")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductVersionForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			ushort ret = GetJoystickProductVersionForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType GetJoystickTypeForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[610])(instanceId);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<int, SDLJoystickType>)funcTable[610])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickTypeForID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType GetJoystickTypeForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystickType ret = GetJoystickTypeForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* OpenJoystickNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[611])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[611])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystick* OpenJoystick([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystick* ret = OpenJoystickNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetJoystickFromIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[612])(instanceId);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[612])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystick* GetJoystickFromID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystick* ret = GetJoystickFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetJoystickFromPlayerIndexNative([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, SDLJoystick*>)funcTable[613])(playerIndex);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[613])(playerIndex);
			#endif
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystick* GetJoystickFromPlayerIndex([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLJoystick* ret = GetJoystickFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AttachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AttachVirtualJoystickNative([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "SDL_VirtualJoystickDesc const *")] SDLVirtualJoystickDesc* desc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLVirtualJoystickDesc*, int>)funcTable[614])(desc);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[614])((nint)desc);
			#endif
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AttachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int AttachVirtualJoystick([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "SDL_VirtualJoystickDesc const *")] SDLVirtualJoystickDesc* desc)
		{
			int ret = AttachVirtualJoystickNative(desc);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AttachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int AttachVirtualJoystick([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "SDL_VirtualJoystickDesc const *")] ref SDLVirtualJoystickDesc desc)
		{
			fixed (SDLVirtualJoystickDesc* pdesc = &desc)
			{
				int ret = AttachVirtualJoystickNative((SDLVirtualJoystickDesc*)pdesc);
				return ret;
			}
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DetachVirtualJoystickNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[615])(instanceId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[615])(instanceId);
			#endif
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachVirtualJoystick")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DetachVirtualJoystick([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte ret = DetachVirtualJoystickNative(instanceId);
			return ret != 0;
		}

		/// <summary>
		/// Query whether or not a joystick is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickVirtual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJoystickVirtualNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[616])(instanceId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[616])(instanceId);
			#endif
		}

		/// <summary>
		/// Query whether or not a joystick is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsJoystickVirtual")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJoystickVirtual([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			byte ret = IsJoystickVirtualNative(instanceId);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualAxisNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, byte>)funcTable[617])(joystick, axis, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, short, byte>)funcTable[617])((nint)joystick, axis, value);
			#endif
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			byte ret = SetJoystickVirtualAxisNative(joystick, axis, value);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of an axis on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualAxisNative((SDLJoystick*)pjoystick, axis, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualBall")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualBallNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "xrel")] [NativeName(NativeNameType.Type, "Sint16")] short xrel, [NativeName(NativeNameType.Param, "yrel")] [NativeName(NativeNameType.Type, "Sint16")] short yrel)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, short, short, byte>)funcTable[618])(joystick, ball, xrel, yrel);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, short, short, byte>)funcTable[618])((nint)joystick, ball, xrel, yrel);
			#endif
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualBall")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "xrel")] [NativeName(NativeNameType.Type, "Sint16")] short xrel, [NativeName(NativeNameType.Param, "yrel")] [NativeName(NativeNameType.Type, "Sint16")] short yrel)
		{
			byte ret = SetJoystickVirtualBallNative(joystick, ball, xrel, yrel);
			return ret != 0;
		}

		/// <summary>
		/// Generate ball motion on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualBall")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "xrel")] [NativeName(NativeNameType.Type, "Sint16")] short xrel, [NativeName(NativeNameType.Param, "yrel")] [NativeName(NativeNameType.Type, "Sint16")] short yrel)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualBallNative((SDLJoystick*)pjoystick, ball, xrel, yrel);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualButtonNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool")] byte down)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, byte>)funcTable[619])(joystick, button, down);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte, byte>)funcTable[619])((nint)joystick, button, down);
			#endif
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool")] bool down)
		{
			byte ret = SetJoystickVirtualButtonNative(joystick, button, down ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of a button on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool")] bool down)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualButtonNative((SDLJoystick*)pjoystick, button, down ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualHat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualHatNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte, byte>)funcTable[620])(joystick, hat, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte, byte>)funcTable[620])((nint)joystick, hat, value);
			#endif
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualHat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			byte ret = SetJoystickVirtualHatNative(joystick, hat, value);
			return ret != 0;
		}

		/// <summary>
		/// Set the state of a hat on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualHat")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualHatNative((SDLJoystick*)pjoystick, hat, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualTouchpad")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickVirtualTouchpadNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool")] byte down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float")] float pressure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, int, byte, float, float, float, byte>)funcTable[621])(joystick, touchpad, finger, down, x, y, pressure);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, byte, float, float, float, byte>)funcTable[621])((nint)joystick, touchpad, finger, down, x, y, pressure);
			#endif
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualTouchpad")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualTouchpad([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool")] bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float")] float pressure)
		{
			byte ret = SetJoystickVirtualTouchpadNative(joystick, touchpad, finger, down ? (byte)1 : (byte)0, x, y, pressure);
			return ret != 0;
		}

		/// <summary>
		/// Set touchpad finger state on an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickVirtualTouchpad")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickVirtualTouchpad([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool")] bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float")] float pressure)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickVirtualTouchpadNative((SDLJoystick*)pjoystick, touchpad, finger, down ? (byte)1 : (byte)0, x, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SendJoystickVirtualSensorDataNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLSensorType, ulong, float*, int, byte>)funcTable[622])(joystick, type, sensorTimestamp, data, numValues);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, ulong, nint, int, byte>)funcTable[622])((nint)joystick, type, sensorTimestamp, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			byte ret = SendJoystickVirtualSensorDataNative(joystick, type, sensorTimestamp, data, numValues);
			return ret != 0;
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SendJoystickVirtualSensorDataNative((SDLJoystick*)pjoystick, type, sensorTimestamp, data, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				byte ret = SendJoystickVirtualSensorDataNative(joystick, type, sensorTimestamp, (float*)pdata, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a sensor update for an opened virtual joystick.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendJoystickVirtualSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendJoystickVirtualSensorData([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "sensor_timestamp")] [NativeName(NativeNameType.Type, "Uint64")] ulong sensorTimestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float const *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (float* pdata = &data)
				{
					byte ret = SendJoystickVirtualSensorDataNative((SDLJoystick*)pjoystick, type, sensorTimestamp, (float*)pdata, numValues);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetJoystickPropertiesNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, uint>)funcTable[623])(joystick);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[623])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetJoystickProperties([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			uint ret = GetJoystickPropertiesNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a joystick.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
		/// LED that has adjustable brightness<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
		/// that has adjustable color<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
		/// player LED<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// left/right rumble<br/>
		/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
		/// simple trigger rumble<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetJoystickProperties([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				uint ret = GetJoystickPropertiesNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[624])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[624])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte* ret = GetJoystickNameNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickNameNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickNameNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickPathNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[625])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[625])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte* ret = GetJoystickPathNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickPathNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickPathNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickPathNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetJoystickPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int>)funcTable[626])(joystick);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[626])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			int ret = GetJoystickPlayerIndexNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = GetJoystickPlayerIndexNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetJoystickPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, int, byte>)funcTable[627])(joystick, playerIndex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[627])((nint)joystick, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			byte ret = SetJoystickPlayerIndexNative(joystick, playerIndex);
			return ret != 0;
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetJoystickPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetJoystickPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SetJoystickPlayerIndexNative((SDLJoystick*)pjoystick, playerIndex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SdlGuid GetJoystickGUIDNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SdlGuid>)funcTable[628])(joystick);
			#else
			return (SdlGuid)((delegate* unmanaged[Cdecl]<nint, SdlGuid>)funcTable[628])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid GetJoystickGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			SdlGuid ret = GetJoystickGUIDNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdlGuid GetJoystickGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SdlGuid ret = GetJoystickGUIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickVendorNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[629])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[629])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickVendorNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickVendorNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[630])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[630])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickProductNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickProductNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickProductVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[631])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[631])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickProductVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickProductVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetJoystickFirmwareVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, ushort>)funcTable[632])(joystick);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[632])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			ushort ret = GetJoystickFirmwareVersionNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetJoystickFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = GetJoystickFirmwareVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickSerialNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte*>)funcTable[633])(joystick);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[633])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickSerial([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			byte* ret = GetJoystickSerialNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickSerialS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickSerialNative(joystick));
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetJoystickSerial([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = GetJoystickSerialNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetJoystickSerialS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickSerialNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickType GetJoystickTypeNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLJoystickType>)funcTable[634])(joystick);
			#else
			return (SDLJoystickType)((delegate* unmanaged[Cdecl]<nint, SDLJoystickType>)funcTable[634])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType GetJoystickType([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] SDLJoystick* joystick)
		{
			SDLJoystickType ret = GetJoystickTypeNative(joystick);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType GetJoystickType([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick *")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickType ret = GetJoystickTypeNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetJoystickGUIDInfoNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SdlGuid, ushort*, ushort*, ushort*, ushort*, void>)funcTable[635])(guid, vendor, product, version, crc16);
			#else
			((delegate* unmanaged[Cdecl]<SdlGuid, nint, nint, nint, nint, void>)funcTable[635])(guid, (nint)vendor, (nint)product, (nint)version, (nint)crc16);
			#endif
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			GetJoystickGUIDInfoNative(guid, vendor, product, version, crc16);
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			fixed (ushort* pversion = &version)
			{
				GetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, crc16);
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>
		/// Get the device information encoded in a SDL_GUID structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdlGuid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					GetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, crc16);
				}
			}
		}
	}
}
