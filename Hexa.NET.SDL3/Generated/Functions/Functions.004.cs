// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Create a new read/write lock.<br/>
		/// A read/write lock is useful for situations where you have multiple threads<br/>
		/// trying to access a resource that is rarely updated. All threads requesting<br/>
		/// a read-only lock will be allowed to run in parallel; if a thread requests a<br/>
		/// write lock, it will be provided exclusive access. This makes it safe for<br/>
		/// multiple threads to use a resource at the same time if they promise not to<br/>
		/// change it, and when it has to be changed, the rwlock will serve as a<br/>
		/// gateway to make sure those changes can be made safely.<br/>
		/// In the right situation, a rwlock can be more efficient than a mutex, which<br/>
		/// only lets a single thread proceed at a time, even if it won't be modifying<br/>
		/// the data.<br/>
		/// All newly-created read/write locks begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not<br/>
		/// return while the rwlock is locked _for writing_ by another thread. See<br/>
		/// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt<br/>
		/// to lock without blocking.<br/>
		/// SDL read/write locks are only recursive for read-only locks! They are not<br/>
		/// guaranteed to be fair, or provide access in a FIFO manner! They are not<br/>
		/// guaranteed to favor writers. You may not lock a rwlock for both read-only<br/>
		/// and write access at the same time from the same thread (so you can't<br/>
		/// promote your read-only lock to a write lock without unlocking first).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRWLock")]
		[return: NativeName(NativeNameType.Type, "SDL_RWLock *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRWLock* CreateRWLockNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*>)funcTable[180])();
			#else
			return (SDLRWLock*)((delegate* unmanaged[Cdecl]<nint>)funcTable[180])();
			#endif
		}

		/// <summary>
		/// Create a new read/write lock.<br/>
		/// A read/write lock is useful for situations where you have multiple threads<br/>
		/// trying to access a resource that is rarely updated. All threads requesting<br/>
		/// a read-only lock will be allowed to run in parallel; if a thread requests a<br/>
		/// write lock, it will be provided exclusive access. This makes it safe for<br/>
		/// multiple threads to use a resource at the same time if they promise not to<br/>
		/// change it, and when it has to be changed, the rwlock will serve as a<br/>
		/// gateway to make sure those changes can be made safely.<br/>
		/// In the right situation, a rwlock can be more efficient than a mutex, which<br/>
		/// only lets a single thread proceed at a time, even if it won't be modifying<br/>
		/// the data.<br/>
		/// All newly-created read/write locks begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not<br/>
		/// return while the rwlock is locked _for writing_ by another thread. See<br/>
		/// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt<br/>
		/// to lock without blocking.<br/>
		/// SDL read/write locks are only recursive for read-only locks! They are not<br/>
		/// guaranteed to be fair, or provide access in a FIFO manner! They are not<br/>
		/// guaranteed to favor writers. You may not lock a rwlock for both read-only<br/>
		/// and write access at the same time from the same thread (so you can't<br/>
		/// promote your read-only lock to a write lock without unlocking first).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRWLock")]
		[return: NativeName(NativeNameType.Type, "SDL_RWLock *")]
		public static SDLRWLock* CreateRWLock()
		{
			SDLRWLock* ret = CreateRWLockNative();
			return ret;
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockRWLockForReadingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[181])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[181])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			LockRWLockForReadingNative(rwlock);
		}

		/// <summary>
		/// Lock the read/write lock for _read only_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
		/// rwlock, all may do so at the same time as long as they are requesting<br/>
		/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
		/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
		/// same time.<br/>
		/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
		/// reading. It must unlock it the same number of times before it is actually<br/>
		/// made available for other threads in the system (this is known as a<br/>
		/// "recursive rwlock").<br/>
		/// Note that locking for writing is not recursive (this is only available to<br/>
		/// read-only locks).<br/>
		/// It is illegal to request a read-only lock from a thread that already holds<br/>
		/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
		/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
		/// write lock, you don't need further locks to read in any case.)<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				LockRWLockForReadingNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LockRWLockForWritingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[182])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[182])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			LockRWLockForWritingNative(rwlock);
		}

		/// <summary>
		/// Lock the read/write lock for _write_ operations.<br/>
		/// This will block until the rwlock is available, which is to say it is not<br/>
		/// locked for reading or writing by any other thread. Only one thread may hold<br/>
		/// the lock when it requests write access; all other threads, whether they<br/>
		/// also want to write or only want read-only access, must wait until the<br/>
		/// writer thread has released the lock.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
		/// having locked nothing. If the rwlock is valid, this function will always<br/>
		/// block until it can lock the mutex, and return with it locked.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				LockRWLockForWritingNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns `SDL_RWLOCK_TIMEDOUT` immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function does not fail; if rwlock is NULL, it will return 0<br/>
		/// immediately having locked nothing. If rwlock is valid, this function will<br/>
		/// always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT<br/>
		/// and lock nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TryLockRWLockForReadingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*, int>)funcTable[183])(rwlock);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[183])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns `SDL_RWLOCK_TIMEDOUT` immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function does not fail; if rwlock is NULL, it will return 0<br/>
		/// immediately having locked nothing. If rwlock is valid, this function will<br/>
		/// always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT<br/>
		/// and lock nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TryLockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			int ret = TryLockRWLockForReadingNative(rwlock);
			return ret;
		}

		/// <summary>
		/// Try to lock a read/write lock _for reading_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
		/// available, then this function returns `SDL_RWLOCK_TIMEDOUT` immediately.<br/>
		/// This technique is useful if you need access to a resource but don't want to<br/>
		/// wait for it, and will return to it to try again later.<br/>
		/// Trying to lock for read-only access can succeed if other threads are<br/>
		/// holding read-only locks, as this won't prevent access.<br/>
		/// This function does not fail; if rwlock is NULL, it will return 0<br/>
		/// immediately having locked nothing. If rwlock is valid, this function will<br/>
		/// always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT<br/>
		/// and lock nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForReading")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TryLockRWLockForReading([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				int ret = TryLockRWLockForReadingNative((SDLRWLock*)prwlock);
				return ret;
			}
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, this function returns `SDL_RWLOCK_TIMEDOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return 0<br/>
		/// immediately having locked nothing. If rwlock is valid, this function will<br/>
		/// always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT<br/>
		/// and lock nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TryLockRWLockForWritingNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWLock*, int>)funcTable[184])(rwlock);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[184])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, this function returns `SDL_RWLOCK_TIMEDOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return 0<br/>
		/// immediately having locked nothing. If rwlock is valid, this function will<br/>
		/// always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT<br/>
		/// and lock nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TryLockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			int ret = TryLockRWLockForWritingNative(rwlock);
			return ret;
		}

		/// <summary>
		/// Try to lock a read/write lock _for writing_ without blocking.<br/>
		/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
		/// available, this function returns `SDL_RWLOCK_TIMEDOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
		/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
		/// results in undefined behavior.<br/>
		/// It is illegal to request a write lock from a thread that already holds a<br/>
		/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
		/// read-only lock before requesting a write lock.<br/>
		/// This function does not fail; if rwlock is NULL, it will return 0<br/>
		/// immediately having locked nothing. If rwlock is valid, this function will<br/>
		/// always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT<br/>
		/// and lock nothing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockRWLockForWriting")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TryLockRWLockForWriting([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				int ret = TryLockRWLockForWritingNative((SDLRWLock*)prwlock);
				return ret;
			}
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockRWLockNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[185])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[185])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			UnlockRWLockNative(rwlock);
		}

		/// <summary>
		/// Unlock the read/write lock.<br/>
		/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
		/// or write operations.<br/>
		/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
		/// It must unlock it the same number of times before it is actually made<br/>
		/// available for other threads in the system (this is known as a "recursive<br/>
		/// rwlock").<br/>
		/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				UnlockRWLockNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyRWLockNative([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLRWLock*, void>)funcTable[186])(rwlock);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[186])((nint)rwlock);
			#endif
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] SDLRWLock* rwlock)
		{
			DestroyRWLockNative(rwlock);
		}

		/// <summary>
		/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
		/// This function must be called on any read/write lock that is no longer<br/>
		/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
		/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
		/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
		/// undefined behavior depending on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyRWLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyRWLock([NativeName(NativeNameType.Param, "rwlock")] [NativeName(NativeNameType.Type, "SDL_RWLock *")] ref SDLRWLock rwlock)
		{
			fixed (SDLRWLock* prwlock = &rwlock)
			{
				DestroyRWLockNative((SDLRWLock*)prwlock);
			}
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_Semaphore *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSemaphore* CreateSemaphoreNative([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLSemaphore*>)funcTable[187])(initialValue);
			#else
			return (SDLSemaphore*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[187])(initialValue);
			#endif
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_Semaphore *")]
		public static SDLSemaphore* CreateSemaphore([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue)
		{
			SDLSemaphore* ret = CreateSemaphoreNative(initialValue);
			return ret;
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroySemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLSemaphore*, void>)funcTable[188])(sem);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[188])((nint)sem);
			#endif
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			DestroySemaphoreNative(sem);
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroySemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				DestroySemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WaitSemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int>)funcTable[189])(sem);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[189])((nint)sem);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			int ret = WaitSemaphoreNative(sem);
			return ret;
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = WaitSemaphoreNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryWaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TryWaitSemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int>)funcTable[190])(sem);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[190])((nint)sem);
			#endif
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryWaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TryWaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			int ret = TryWaitSemaphoreNative(sem);
			return ret;
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryWaitSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TryWaitSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = TryWaitSemaphoreNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphoreTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WaitSemaphoreTimeoutNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int, int>)funcTable[191])(sem, timeoutMS);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[191])((nint)sem, timeoutMS);
			#endif
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphoreTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitSemaphoreTimeout([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			int ret = WaitSemaphoreTimeoutNative(sem, timeoutMS);
			return ret;
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitSemaphoreTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitSemaphoreTimeout([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = WaitSemaphoreTimeoutNative((SDLSemaphore*)psem, timeoutMS);
				return ret;
			}
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SignalSemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, int>)funcTable[192])(sem);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[192])((nint)sem);
			#endif
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SignalSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			int ret = SignalSemaphoreNative(sem);
			return ret;
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalSemaphore")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SignalSemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SignalSemaphoreNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSemaphoreValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSemaphoreValueNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSemaphore*, uint>)funcTable[193])(sem);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[193])((nint)sem);
			#endif
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSemaphoreValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetSemaphoreValue([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] SDLSemaphore* sem)
		{
			uint ret = GetSemaphoreValueNative(sem);
			return ret;
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSemaphoreValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint GetSemaphoreValue([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_Semaphore *")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				uint ret = GetSemaphoreValueNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCondition")]
		[return: NativeName(NativeNameType.Type, "SDL_Condition *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLCondition* CreateConditionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*>)funcTable[194])();
			#else
			return (SDLCondition*)((delegate* unmanaged[Cdecl]<nint>)funcTable[194])();
			#endif
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCondition")]
		[return: NativeName(NativeNameType.Type, "SDL_Condition *")]
		public static SDLCondition* CreateCondition()
		{
			SDLCondition* ret = CreateConditionNative();
			return ret;
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLCondition*, void>)funcTable[195])(cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[195])((nint)cond);
			#endif
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			DestroyConditionNative(cond);
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCondition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				DestroyConditionNative((SDLCondition*)pcond);
			}
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SignalConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*, int>)funcTable[196])(cond);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[196])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SignalCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			int ret = SignalConditionNative(cond);
			return ret;
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SignalCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				int ret = SignalConditionNative((SDLCondition*)pcond);
				return ret;
			}
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BroadcastCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BroadcastConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*, int>)funcTable[197])(cond);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[197])((nint)cond);
			#endif
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BroadcastCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BroadcastCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond)
		{
			int ret = BroadcastConditionNative(cond);
			return ret;
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BroadcastCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BroadcastCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				int ret = BroadcastConditionNative((SDLCondition*)pcond);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WaitConditionNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*, SDLMutex*, int>)funcTable[198])(cond, mutex);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[198])((nint)cond, (nint)mutex);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			int ret = WaitConditionNative(cond, mutex);
			return ret;
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				int ret = WaitConditionNative((SDLCondition*)pcond, mutex);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = WaitConditionNative(cond, (SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
		/// re-locked and the function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
		/// a time length of -1.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitCondition")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitCondition([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					int ret = WaitConditionNative((SDLCondition*)pcond, (SDLMutex*)pmutex);
					return ret;
				}
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WaitConditionTimeoutNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLCondition*, SDLMutex*, int, int>)funcTable[199])(cond, mutex, timeoutMS);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[199])((nint)cond, (nint)mutex, timeoutMS);
			#endif
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			int ret = WaitConditionTimeoutNative(cond, mutex, timeoutMS);
			return ret;
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				int ret = WaitConditionTimeoutNative((SDLCondition*)pcond, mutex, timeoutMS);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] SDLCondition* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = WaitConditionTimeoutNative(cond, (SDLMutex*)pmutex, timeoutMS);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
		/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
		/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
		/// function returns.<br/>
		/// The mutex must be locked before calling this function. Locking the mutex<br/>
		/// recursively (more than once) is not supported and leads to undefined<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitConditionTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int WaitConditionTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_Condition *")] ref SDLCondition cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_Mutex *")] ref SDLMutex mutex, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLCondition* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					int ret = WaitConditionTimeoutNative((SDLCondition*)pcond, (SDLMutex*)pmutex, timeoutMS);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the global SDL properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGlobalPropertiesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[200])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[200])();
			#endif
		}

		/// <summary>
		/// Get the global SDL properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetGlobalProperties()
		{
			uint ret = GetGlobalPropertiesNative();
			return ret;
		}

		/// <summary>
		/// Create a group of properties.<br/>
		/// All properties are automatically destroyed when SDL_Quit() is called.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreatePropertiesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[201])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[201])();
			#endif
		}

		/// <summary>
		/// Create a group of properties.<br/>
		/// All properties are automatically destroyed when SDL_Quit() is called.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint CreateProperties()
		{
			uint ret = CreatePropertiesNative();
			return ret;
		}

		/// <summary>
		/// Copy a group of properties.<br/>
		/// Copy all the properties from one group of properties to another, with the<br/>
		/// exception of properties requiring cleanup (set using<br/>
		/// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any<br/>
		/// property that already exists on `dst` will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CopyPropertiesNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint src, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, int>)funcTable[202])(src, dst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, uint, int>)funcTable[202])(src, dst);
			#endif
		}

		/// <summary>
		/// Copy a group of properties.<br/>
		/// Copy all the properties from one group of properties to another, with the<br/>
		/// exception of properties requiring cleanup (set using<br/>
		/// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any<br/>
		/// property that already exists on `dst` will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CopyProperties([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint src, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint dst)
		{
			int ret = CopyPropertiesNative(src, dst);
			return ret;
		}

		/// <summary>
		/// Lock a group of properties.<br/>
		/// Obtain a multi-threaded lock for these properties. Other threads will wait<br/>
		/// while trying to lock these properties until they are unlocked. Properties<br/>
		/// must be unlocked before they are destroyed.<br/>
		/// The lock is automatically taken when setting individual properties, this<br/>
		/// function is only needed when you want to set several properties atomically<br/>
		/// or want to guarantee that properties being queried aren't freed in another<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LockPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int>)funcTable[203])(props);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, int>)funcTable[203])(props);
			#endif
		}

		/// <summary>
		/// Lock a group of properties.<br/>
		/// Obtain a multi-threaded lock for these properties. Other threads will wait<br/>
		/// while trying to lock these properties until they are unlocked. Properties<br/>
		/// must be unlocked before they are destroyed.<br/>
		/// The lock is automatically taken when setting individual properties, this<br/>
		/// function is only needed when you want to set several properties atomically<br/>
		/// or want to guarantee that properties being queried aren't freed in another<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int LockProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			int ret = LockPropertiesNative(props);
			return ret;
		}

		/// <summary>
		/// Unlock a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[204])(props);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[204])(props);
			#endif
		}

		/// <summary>
		/// Unlock a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnlockProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			UnlockPropertiesNative(props);
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPointerPropertyWithCleanupNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, delegate*<void*, void*, void>, void*, int>)funcTable[205])(props, name, value, (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(cleanup), userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, int>)funcTable[205])(props, (nint)name, (nint)value, (nint)Utils.GetFunctionPointerForDelegate(cleanup), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			int ret = SetPointerPropertyWithCleanupNative(props, name, value, cleanup, userdata);
			return ret;
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				int ret = SetPointerPropertyWithCleanupNative(props, (byte*)pname, value, cleanup, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties with a cleanup function<br/>
		/// that is called when the property is deleted.<br/>
		/// The cleanup function is also called if setting the property fails for any<br/>
		/// reason.<br/>
		/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
		/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
		/// instead, as those functions will handle cleanup on your behalf. This<br/>
		/// function is only for more complex, custom data.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerPropertyWithCleanup")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerPropertyWithCleanup([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value, [NativeName(NativeNameType.Param, "cleanup")] [NativeName(NativeNameType.Type, "SDL_CleanupPropertyCallback")] SDLCleanupPropertyCallback cleanup, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetPointerPropertyWithCleanupNative(props, pStr0, value, cleanup, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetPointerPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, int>)funcTable[206])(props, name, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, int>)funcTable[206])(props, (nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			int ret = SetPointerPropertyNative(props, name, value);
			return ret;
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetPointerPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			fixed (byte* pname = name)
			{
				int ret = SetPointerPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void *")] void* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetPointerPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetStringPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, int>)funcTable[207])(props, name, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, int>)funcTable[207])(props, (nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			int ret = SetStringPropertyNative(props, name, value);
			return ret;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetStringPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = name)
			{
				int ret = SetStringPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetStringPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				int ret = SetStringPropertyNative(props, name, (byte*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pvalue = value)
			{
				int ret = SetStringPropertyNative(props, name, (byte*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetStringPropertyNative(props, name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					int ret = SetStringPropertyNative(props, (byte*)pname, (byte*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					int ret = SetStringPropertyNative(props, (byte*)pname, (byte*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a string property in a group of properties.<br/>
		/// This function makes a copy of the string; the caller does not have to<br/>
		/// preserve the data after this call completes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetStringProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetNumberPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, int>)funcTable[208])(props, name, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, long, int>)funcTable[208])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			int ret = SetNumberPropertyNative(props, name, value);
			return ret;
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (byte* pname = name)
			{
				int ret = SetNumberPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set an integer property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetNumberPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetFloatPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, int>)funcTable[209])(props, name, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, float, int>)funcTable[209])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			int ret = SetFloatPropertyNative(props, name, value);
			return ret;
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			fixed (byte* pname = name)
			{
				int ret = SetFloatPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a floating point property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetFloatPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetBooleanPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "SDL_bool")] int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int, int>)funcTable[210])(props, name, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int, int>)funcTable[210])(props, (nint)name, value);
			#endif
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "SDL_bool")] int value)
		{
			int ret = SetBooleanPropertyNative(props, name, value);
			return ret;
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "SDL_bool")] int value)
		{
			fixed (byte* pname = &name)
			{
				int ret = SetBooleanPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "SDL_bool")] int value)
		{
			fixed (byte* pname = name)
			{
				int ret = SetBooleanPropertyNative(props, (byte*)pname, value);
				return ret;
			}
		}

		/// <summary>
		/// Set a boolean property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "SDL_bool")] int value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SetBooleanPropertyNative(props, pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HasPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[211])(props, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[211])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			int ret = HasPropertyNative(props, name);
			return ret;
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = HasPropertyNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = HasPropertyNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Return whether a property exists in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int HasProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = HasPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPropertyType GetPropertyTypeNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, SDLPropertyType>)funcTable[212])(props, name);
			#else
			return (SDLPropertyType)((delegate* unmanaged[Cdecl]<uint, nint, SDLPropertyType>)funcTable[212])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			SDLPropertyType ret = GetPropertyTypeNative(props, name);
			return ret;
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLPropertyType ret = GetPropertyTypeNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a property in a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPropertyType")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertyType")]
		public static SDLPropertyType GetPropertyType([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLPropertyType ret = GetPropertyTypeNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetPointerPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, void*, void*>)funcTable[213])(props, name, defaultValue);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[213])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			void* ret = GetPointerPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			fixed (byte* pname = name)
			{
				void* ret = GetPointerPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a pointer property from a group of properties.<br/>
		/// By convention, the names of properties that SDL exposes on objects will<br/>
		/// start with "SDL.", and properties that SDL uses internally will start with<br/>
		/// "SDL.internal.". These should be considered read-only and should not be<br/>
		/// modified by applications.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetPointerProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointerProperty")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetPointerProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "void *")] void* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = GetPointerPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte*, byte*>)funcTable[214])(props, name, defaultValue);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[214])(props, (nint)name, (nint)defaultValue);
			#endif
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* ret = GetStringPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, defaultValue));
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetStringPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, defaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] byte* defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, defaultValue));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pdefaultValue = &defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				byte* ret = GetStringPropertyNative(props, name, (byte*)pdefaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pdefaultValue = defaultValue)
			{
				string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, (byte*)pdefaultValue));
				return ret;
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetStringPropertyNative(props, name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, name, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ref byte defaultValue)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pdefaultValue = &defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					byte* ret = GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> defaultValue)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pdefaultValue = defaultValue)
				{
					string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, (byte*)pname, (byte*)pdefaultValue));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetStringProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = GetStringPropertyNative(props, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the data returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetStringProperty() or<br/>
		/// SDL_ClearProperty() on these properties from another thread.<br/>
		/// If you need to avoid this, use SDL_LockProperties() and<br/>
		/// SDL_UnlockProperties().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetStringProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetStringPropertyS([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "char const *")] string defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (defaultValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(defaultValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(defaultValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetStringPropertyNative(props, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetNumberPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, long, long>)funcTable[215])(props, name, defaultValue);
			#else
			return (long)((delegate* unmanaged[Cdecl]<uint, nint, long, long>)funcTable[215])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			long ret = GetNumberPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			fixed (byte* pname = &name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			fixed (byte* pname = name)
			{
				long ret = GetNumberPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a number property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a number property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumberProperty")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetNumberProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "Sint64")] long defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = GetNumberPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetFloatPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, float, float>)funcTable[216])(props, name, defaultValue);
			#else
			return (float)((delegate* unmanaged[Cdecl]<uint, nint, float, float>)funcTable[216])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			float ret = GetFloatPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			fixed (byte* pname = &name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			fixed (byte* pname = name)
			{
				float ret = GetFloatPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a floating point property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a floating point property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetFloatProperty")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetFloatProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "float")] float defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			float ret = GetFloatPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetBooleanPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int, int>)funcTable[217])(props, name, defaultValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int, int>)funcTable[217])(props, (nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			int ret = GetBooleanPropertyNative(props, name, defaultValue);
			return ret;
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			fixed (byte* pname = &name)
			{
				int ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			fixed (byte* pname = name)
			{
				int ret = GetBooleanPropertyNative(props, (byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// Get a boolean property from a group of properties.<br/>
		/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
		/// is a boolean property.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBooleanProperty")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int GetBooleanProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] int defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetBooleanPropertyNative(props, pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ClearPropertyNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[218])(props, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[218])(props, (nint)name);
			#endif
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			int ret = ClearPropertyNative(props, name);
			return ret;
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = ClearPropertyNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = ClearPropertyNative(props, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Clear a property from a group of properties.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearProperty")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ClearProperty([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ClearPropertyNative(props, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EnumeratePropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] SDLEnumeratePropertiesCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void*, uint, byte*, void>, void*, int>)funcTable[219])(props, (delegate*<void*, uint, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, int>)funcTable[219])(props, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Enumerate the properties contained in a group of properties.<br/>
		/// The callback function is called for each property in the group of<br/>
		/// properties. The properties are locked during enumeration.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateProperties")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int EnumerateProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumeratePropertiesCallback")] SDLEnumeratePropertiesCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			int ret = EnumeratePropertiesNative(props, callback, userdata);
			return ret;
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[220])(props);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[220])(props);
			#endif
		}

		/// <summary>
		/// Destroy a group of properties.<br/>
		/// All properties are deleted and their cleanup functions will be called, if<br/>
		/// any.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called while these properties are<br/>
		/// locked or other threads might be setting or getting values<br/>
		/// from these properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			DestroyPropertiesNative(props);
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLIOStream*>)funcTable[221])(file, mode);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[221])((nint)file, (nint)mode);
			#endif
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			SDLIOStream* ret = IOFromFileNative(file, mode);
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLIOStream* ret = IOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = file)
			{
				SDLIOStream* ret = IOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLIOStream* ret = IOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				SDLIOStream* ret = IOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ref byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLIOStream* ret = IOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfile = file)
			{
				fixed (byte* pmode = mode)
				{
					SDLIOStream* ret = IOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_IOStream structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
		/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
		/// the app's `assets`.<br/>
		/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
		/// The following properties may be set at creation time by SDL:<br/>
		/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
		/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
		/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
		/// other method to access the filesystem, this property will not be set.<br/>
		/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
		/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
		/// If SDL used some other method to access the filesystem, this property<br/>
		/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
		/// than your app, trying to use this pointer will almost certainly result in<br/>
		/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
		/// your app with the same compiler and settings to avoid it.<br/>
		/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
		/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
		/// the filesystem. If SDL used some other method to access the filesystem,<br/>
		/// this property will not be set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLIOStream* ret = IOFromFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to make sure the SDL_IOStream never writes to the memory<br/>
		/// buffer, you should use SDL_IOFromConstMem() with a read-only buffer of<br/>
		/// memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, SDLIOStream*>)funcTable[222])(mem, size);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[222])((nint)mem, size);
			#endif
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to make sure the SDL_IOStream never writes to the memory<br/>
		/// buffer, you should use SDL_IOFromConstMem() with a read-only buffer of<br/>
		/// memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			SDLIOStream* ret = IOFromMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this SDL_IOStream stream will report an error<br/>
		/// without writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_IOFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromConstMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void const *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nuint, SDLIOStream*>)funcTable[223])(mem, size);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nuint, nint>)funcTable[223])((nint)mem, size);
			#endif
		}
	}
}
