// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with<br/>
		/// SDL_IOStream.<br/>
		/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this SDL_IOStream stream will report an error<br/>
		/// without writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
		/// provide must remain valid until you close the stream. Closing the stream<br/>
		/// will not free the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_IOFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromConstMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void const *")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			SDLIOStream* ret = IOFromConstMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to create an SDL_IOStream that is backed by dynamically<br/>
		/// allocated memory.<br/>
		/// This supports the following properties to provide access to the memory and<br/>
		/// control over allocations:<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal<br/>
		/// memory of the stream. This can be set to NULL to transfer ownership of<br/>
		/// the memory to the application, which should free the memory with<br/>
		/// SDL_free(). If this is done, the next operation on the stream must be<br/>
		/// SDL_CloseIO().<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in<br/>
		/// multiples of this size, defaulting to 1024.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromDynamicMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* IOFromDynamicMemNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*>)funcTable[224])();
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint>)funcTable[224])();
			#endif
		}

		/// <summary>
		/// Use this function to create an SDL_IOStream that is backed by dynamically<br/>
		/// allocated memory.<br/>
		/// This supports the following properties to provide access to the memory and<br/>
		/// control over allocations:<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal<br/>
		/// memory of the stream. This can be set to NULL to transfer ownership of<br/>
		/// the memory to the application, which should free the memory with<br/>
		/// SDL_free(). If this is done, the next operation on the stream must be<br/>
		/// SDL_CloseIO().<br/>
		/// - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in<br/>
		/// multiples of this size, defaulting to 1024.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOFromDynamicMem")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* IOFromDynamicMem()
		{
			SDLIOStream* ret = IOFromDynamicMemNative();
			return ret;
		}

		/// <summary>
		/// Create a custom SDL_IOStream.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_IOStream implementation. If you just need an SDL_IOStream to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_CloseIO().<br/>
		/// This function makes a copy of `iface` and the caller does not need to keep<br/>
		/// this data around after this call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenIO")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStream* OpenIONative([NativeName(NativeNameType.Param, "iface")] [NativeName(NativeNameType.Type, "SDL_IOStreamInterface const *")] SDLIOStreamInterface* iface, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStreamInterface*, void*, SDLIOStream*>)funcTable[225])(iface, userdata);
			#else
			return (SDLIOStream*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[225])((nint)iface, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Create a custom SDL_IOStream.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_IOStream implementation. If you just need an SDL_IOStream to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_CloseIO().<br/>
		/// This function makes a copy of `iface` and the caller does not need to keep<br/>
		/// this data around after this call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenIO")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* OpenIO([NativeName(NativeNameType.Param, "iface")] [NativeName(NativeNameType.Type, "SDL_IOStreamInterface const *")] SDLIOStreamInterface* iface, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SDLIOStream* ret = OpenIONative(iface, userdata);
			return ret;
		}

		/// <summary>
		/// Create a custom SDL_IOStream.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_IOStream implementation. If you just need an SDL_IOStream to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_CloseIO().<br/>
		/// This function makes a copy of `iface` and the caller does not need to keep<br/>
		/// this data around after this call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenIO")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStream *")]
		public static SDLIOStream* OpenIO([NativeName(NativeNameType.Param, "iface")] [NativeName(NativeNameType.Type, "SDL_IOStreamInterface const *")] ref SDLIOStreamInterface iface, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLIOStreamInterface* piface = &iface)
			{
				SDLIOStream* ret = OpenIONative((SDLIOStreamInterface*)piface, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Close and free an allocated SDL_IOStream structure.<br/>
		/// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_IOStream itself. This<br/>
		/// returns 0 on success, or -1 if the stream failed to flush to its output<br/>
		/// (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_IOStream is still invalid once this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseIO")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CloseIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, int>)funcTable[226])(context);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[226])((nint)context);
			#endif
		}

		/// <summary>
		/// Close and free an allocated SDL_IOStream structure.<br/>
		/// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_IOStream itself. This<br/>
		/// returns 0 on success, or -1 if the stream failed to flush to its output<br/>
		/// (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_IOStream is still invalid once this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseIO")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CloseIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			int ret = CloseIONative(context);
			return ret;
		}

		/// <summary>
		/// Close and free an allocated SDL_IOStream structure.<br/>
		/// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_IOStream itself. This<br/>
		/// returns 0 on success, or -1 if the stream failed to flush to its output<br/>
		/// (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_IOStream is still invalid once this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseIO")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int CloseIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				int ret = CloseIONative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Get the properties associated with an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIOPropertiesNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, uint>)funcTable[227])(context);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[227])((nint)context);
			#endif
		}

		/// <summary>
		/// Get the properties associated with an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetIOProperties([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			uint ret = GetIOPropertiesNative(context);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetIOProperties([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				uint ret = GetIOPropertiesNative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Query the stream status of an SDL_IOStream.<br/>
		/// This information can be useful to decide if a short read or write was due<br/>
		/// to an error, an EOF, or a non-blocking operation that isn't yet ready to<br/>
		/// complete.<br/>
		/// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or<br/>
		/// SDL_WriteIO call; don't expect it to change if you just call this query<br/>
		/// function in a tight loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called at the same time that<br/>
		/// another thread is operating on the same SDL_IOStream.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStatus")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIOStatus GetIOStatusNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLIOStatus>)funcTable[228])(context);
			#else
			return (SDLIOStatus)((delegate* unmanaged[Cdecl]<nint, SDLIOStatus>)funcTable[228])((nint)context);
			#endif
		}

		/// <summary>
		/// Query the stream status of an SDL_IOStream.<br/>
		/// This information can be useful to decide if a short read or write was due<br/>
		/// to an error, an EOF, or a non-blocking operation that isn't yet ready to<br/>
		/// complete.<br/>
		/// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or<br/>
		/// SDL_WriteIO call; don't expect it to change if you just call this query<br/>
		/// function in a tight loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called at the same time that<br/>
		/// another thread is operating on the same SDL_IOStream.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStatus")]
		public static SDLIOStatus GetIOStatus([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			SDLIOStatus ret = GetIOStatusNative(context);
			return ret;
		}

		/// <summary>
		/// Query the stream status of an SDL_IOStream.<br/>
		/// This information can be useful to decide if a short read or write was due<br/>
		/// to an error, an EOF, or a non-blocking operation that isn't yet ready to<br/>
		/// complete.<br/>
		/// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or<br/>
		/// SDL_WriteIO call; don't expect it to change if you just call this query<br/>
		/// function in a tight loop.<br/>
		/// <br/>
		/// <br/>
		/// This function should not be called at the same time that<br/>
		/// another thread is operating on the same SDL_IOStream.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_IOStatus")]
		public static SDLIOStatus GetIOStatus([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				SDLIOStatus ret = GetIOStatusNative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetIOSizeNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long>)funcTable[229])(context);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[229])((nint)context);
			#endif
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetIOSize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			long ret = GetIOSizeNative(context);
			return ret;
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetIOSize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				long ret = GetIOSizeNative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Seek within an SDL_IOStream data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `SDL_IO_SEEK_SET`: seek from the beginning of data<br/>
		/// - `SDL_IO_SEEK_CUR`: seek relative to current read point<br/>
		/// - `SDL_IO_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SeekIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long SeekIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "SDL_IOWhence")] SDLIOWhence whence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long, SDLIOWhence, long>)funcTable[230])(context, offset, whence);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long, SDLIOWhence, long>)funcTable[230])((nint)context, offset, whence);
			#endif
		}

		/// <summary>
		/// Seek within an SDL_IOStream data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `SDL_IO_SEEK_SET`: seek from the beginning of data<br/>
		/// - `SDL_IO_SEEK_CUR`: seek relative to current read point<br/>
		/// - `SDL_IO_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SeekIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SeekIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "SDL_IOWhence")] SDLIOWhence whence)
		{
			long ret = SeekIONative(context, offset, whence);
			return ret;
		}

		/// <summary>
		/// Seek within an SDL_IOStream data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `SDL_IO_SEEK_SET`: seek from the beginning of data<br/>
		/// - `SDL_IO_SEEK_CUR`: seek relative to current read point<br/>
		/// - `SDL_IO_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SeekIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SeekIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "SDL_IOWhence")] SDLIOWhence whence)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				long ret = SeekIONative((SDLIOStream*)pcontext, offset, whence);
				return ret;
			}
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_IOStream data stream.<br/>
		/// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's<br/>
		/// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to<br/>
		/// simplify application development.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TellIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long TellIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long>)funcTable[231])(context);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[231])((nint)context);
			#endif
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_IOStream data stream.<br/>
		/// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's<br/>
		/// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to<br/>
		/// simplify application development.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TellIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long TellIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context)
		{
			long ret = TellIONative(context);
			return ret;
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_IOStream data stream.<br/>
		/// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's<br/>
		/// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to<br/>
		/// simplify application development.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TellIO")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long TellIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				long ret = TellIONative((SDLIOStream*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up `size` bytes from the data source to the area<br/>
		/// pointed at by `ptr`. This function may read less bytes than requested. It<br/>
		/// will return zero when the data stream is completely read, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF, or on error, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint ReadIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, void*, nuint, nuint>)funcTable[232])(context, ptr, size);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[232])((nint)context, (nint)ptr, size);
			#endif
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up `size` bytes from the data source to the area<br/>
		/// pointed at by `ptr`. This function may read less bytes than requested. It<br/>
		/// will return zero when the data stream is completely read, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF, or on error, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint ReadIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			nuint ret = ReadIONative(context, ptr, size);
			return ret;
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up `size` bytes from the data source to the area<br/>
		/// pointed at by `ptr`. This function may read less bytes than requested. It<br/>
		/// will return zero when the data stream is completely read, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF, or on error, and<br/>
		/// SDL_GetIOStatus() will return SDL_IO_STATUS_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint ReadIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = ReadIONative((SDLIOStream*)pcontext, ptr, size);
				return ret;
			}
		}

		/// <summary>
		/// Write to an SDL_IOStream data stream.<br/>
		/// This function writes exactly `size` bytes from the area pointed at by `ptr`<br/>
		/// to the stream. If this fails for any reason, it'll return less than `size`<br/>
		/// to demonstrate how far the write progressed. On success, it returns `size`.<br/>
		/// On error, this function still attempts to write as much as possible, so it<br/>
		/// might return a positive value less than the requested write size.<br/>
		/// The caller can use SDL_GetIOStatus() to determine if the problem is<br/>
		/// recoverable, such as a non-blocking write that can simply be retried later,<br/>
		/// or a fatal error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint WriteIONative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void const *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, void*, nuint, nuint>)funcTable[233])(context, ptr, size);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nuint>)funcTable[233])((nint)context, (nint)ptr, size);
			#endif
		}

		/// <summary>
		/// Write to an SDL_IOStream data stream.<br/>
		/// This function writes exactly `size` bytes from the area pointed at by `ptr`<br/>
		/// to the stream. If this fails for any reason, it'll return less than `size`<br/>
		/// to demonstrate how far the write progressed. On success, it returns `size`.<br/>
		/// On error, this function still attempts to write as much as possible, so it<br/>
		/// might return a positive value less than the requested write size.<br/>
		/// The caller can use SDL_GetIOStatus() to determine if the problem is<br/>
		/// recoverable, such as a non-blocking write that can simply be retried later,<br/>
		/// or a fatal error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint WriteIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void const *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			nuint ret = WriteIONative(context, ptr, size);
			return ret;
		}

		/// <summary>
		/// Write to an SDL_IOStream data stream.<br/>
		/// This function writes exactly `size` bytes from the area pointed at by `ptr`<br/>
		/// to the stream. If this fails for any reason, it'll return less than `size`<br/>
		/// to demonstrate how far the write progressed. On success, it returns `size`.<br/>
		/// On error, this function still attempts to write as much as possible, so it<br/>
		/// might return a positive value less than the requested write size.<br/>
		/// The caller can use SDL_GetIOStatus() to determine if the problem is<br/>
		/// recoverable, such as a non-blocking write that can simply be retried later,<br/>
		/// or a fatal error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteIO")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint WriteIO([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void const *")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = WriteIONative((SDLIOStream*)pcontext, ptr, size);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint IOprintfNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte*, nuint>)funcTable[234])(context, fmt);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint>)funcTable[234])((nint)context, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			nuint ret = IOprintfNative(context, fmt);
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = IOprintfNative((SDLIOStream*)pcontext, fmt);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				nuint ret = IOprintfNative(context, (byte*)pfmt);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				nuint ret = IOprintfNative(context, (byte*)pfmt);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = IOprintfNative(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = &fmt)
				{
					nuint ret = IOprintfNative((SDLIOStream*)pcontext, (byte*)pfmt);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = fmt)
				{
					nuint ret = IOprintfNative((SDLIOStream*)pcontext, (byte*)pfmt);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				nuint ret = IOprintfNative((SDLIOStream*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint IOvprintfNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte*, nint, nuint>)funcTable[235])(context, fmt, ap);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint>)funcTable[235])((nint)context, (nint)fmt, ap);
			#endif
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			nuint ret = IOvprintfNative(context, fmt, ap);
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				nuint ret = IOvprintfNative((SDLIOStream*)pcontext, fmt, ap);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				nuint ret = IOvprintfNative(context, (byte*)pfmt, ap);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = fmt)
			{
				nuint ret = IOvprintfNative(context, (byte*)pfmt, ap);
				return ret;
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = IOvprintfNative(context, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = &fmt)
				{
					nuint ret = IOvprintfNative((SDLIOStream*)pcontext, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				fixed (byte* pfmt = fmt)
				{
					nuint ret = IOvprintfNative((SDLIOStream*)pcontext, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		/// <summary>
		/// Print to an SDL_IOStream data stream.<br/>
		/// This function does formatted printing to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IOvprintf")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint IOvprintf([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream context, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (SDLIOStream* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				nuint ret = IOvprintfNative((SDLIOStream*)pcontext, pStr0, ap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadFileIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "SDL_bool")] int closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, nuint*, int, void*>)funcTable[236])(src, datasize, closeio);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)funcTable[236])((nint)src, (nint)datasize, closeio);
			#endif
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "SDL_bool")] int closeio)
		{
			void* ret = LoadFileIONative(src, datasize, closeio);
			return ret;
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "SDL_bool")] int closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				void* ret = LoadFileIONative((SDLIOStream*)psrc, datasize, closeio);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "SDL_bool")] int closeio)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileIONative(src, (nuint*)pdatasize, closeio);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_IO")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFileIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "SDL_bool")] int closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileIONative((SDLIOStream*)psrc, (nuint*)pdatasize, closeio);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* LoadFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint*, void*>)funcTable[237])(file, datasize);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[237])((nint)file, (nint)datasize);
			#endif
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			void* ret = LoadFileNative(file, datasize);
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			fixed (byte* pfile = &file)
			{
				void* ret = LoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			fixed (byte* pfile = file)
			{
				void* ret = LoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] nuint* datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = LoadFileNative(pStr0, datasize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileNative(file, (nuint*)pdatasize);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			fixed (byte* pfile = &file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileNative((byte*)pfile, (nuint*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			fixed (byte* pfile = file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = LoadFileNative((byte*)pfile, (nuint*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* LoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = LoadFileNative(pStr0, (nuint*)pdatasize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadU8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte*, int>)funcTable[238])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[238])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* value)
		{
			int ret = ReadU8Native(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] byte* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadU8Native((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				int ret = ReadU8Native(src, (byte*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8 *")] ref byte value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* pvalue = &value)
				{
					int ret = ReadU8Native((SDLIOStream*)psrc, (byte*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadS8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] sbyte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, sbyte*, int>)funcTable[239])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[239])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] sbyte* value)
		{
			int ret = ReadS8Native(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] sbyte* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadS8Native((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] ref sbyte value)
		{
			fixed (sbyte* pvalue = &value)
			{
				int ret = ReadS8Native(src, (sbyte*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a signed byte from an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8 *")] ref sbyte value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (sbyte* pvalue = &value)
				{
					int ret = ReadS8Native((SDLIOStream*)psrc, (sbyte*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadU16LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ushort*, int>)funcTable[240])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[240])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			int ret = ReadU16LENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadU16LENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort value)
		{
			fixed (ushort* pvalue = &value)
			{
				int ret = ReadU16LENative(src, (ushort*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (ushort* pvalue = &value)
				{
					int ret = ReadU16LENative((SDLIOStream*)psrc, (ushort*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadS16LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, short*, int>)funcTable[241])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[241])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			int ret = ReadS16LENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadS16LENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] ref short value)
		{
			fixed (short* pvalue = &value)
			{
				int ret = ReadS16LENative(src, (short*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] ref short value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (short* pvalue = &value)
				{
					int ret = ReadS16LENative((SDLIOStream*)psrc, (short*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadU16BENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ushort*, int>)funcTable[242])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[242])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			int ret = ReadU16BENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ushort* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadU16BENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort value)
		{
			fixed (ushort* pvalue = &value)
			{
				int ret = ReadU16BENative(src, (ushort*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16 *")] ref ushort value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (ushort* pvalue = &value)
				{
					int ret = ReadU16BENative((SDLIOStream*)psrc, (ushort*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadS16BENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, short*, int>)funcTable[243])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[243])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			int ret = ReadS16BENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] short* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadS16BENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] ref short value)
		{
			fixed (short* pvalue = &value)
			{
				int ret = ReadS16BENative(src, (short*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS16BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16 *")] ref short value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (short* pvalue = &value)
				{
					int ret = ReadS16BENative((SDLIOStream*)psrc, (short*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadU32LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, uint*, int>)funcTable[244])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[244])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* value)
		{
			int ret = ReadU32LENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadU32LENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint value)
		{
			fixed (uint* pvalue = &value)
			{
				int ret = ReadU32LENative(src, (uint*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (uint* pvalue = &value)
				{
					int ret = ReadU32LENative((SDLIOStream*)psrc, (uint*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadS32LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, int*, int>)funcTable[245])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[245])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] int* value)
		{
			int ret = ReadS32LENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] int* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadS32LENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				int ret = ReadS32LENative(src, (int*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] ref int value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (int* pvalue = &value)
				{
					int ret = ReadS32LENative((SDLIOStream*)psrc, (int*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadU32BENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, uint*, int>)funcTable[246])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[246])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* value)
		{
			int ret = ReadU32BENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadU32BENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint value)
		{
			fixed (uint* pvalue = &value)
			{
				int ret = ReadU32BENative(src, (uint*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (uint* pvalue = &value)
				{
					int ret = ReadU32BENative((SDLIOStream*)psrc, (uint*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadS32BENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] int* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, int*, int>)funcTable[247])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[247])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] int* value)
		{
			int ret = ReadS32BENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] int* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadS32BENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				int ret = ReadS32BENative(src, (int*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS32BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32 *")] ref int value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (int* pvalue = &value)
				{
					int ret = ReadS32BENative((SDLIOStream*)psrc, (int*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadU64LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ulong*, int>)funcTable[248])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[248])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* value)
		{
			int ret = ReadU64LENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadU64LENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ref ulong value)
		{
			fixed (ulong* pvalue = &value)
			{
				int ret = ReadU64LENative(src, (ulong*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ref ulong value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (ulong* pvalue = &value)
				{
					int ret = ReadU64LENative((SDLIOStream*)psrc, (ulong*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadS64LENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] long* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long*, int>)funcTable[249])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[249])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] long* value)
		{
			int ret = ReadS64LENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] long* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadS64LENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] ref long value)
		{
			fixed (long* pvalue = &value)
			{
				int ret = ReadS64LENative(src, (long*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an<br/>
		/// SDL_IOStream and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64LE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] ref long value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (long* pvalue = &value)
				{
					int ret = ReadS64LENative((SDLIOStream*)psrc, (long*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadU64BENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ulong*, int>)funcTable[250])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[250])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* value)
		{
			int ret = ReadU64BENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ulong* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadU64BENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ref ulong value)
		{
			fixed (ulong* pvalue = &value)
			{
				int ret = ReadU64BENative(src, (ulong*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadU64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64 *")] ref ulong value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (ulong* pvalue = &value)
				{
					int ret = ReadU64BENative((SDLIOStream*)psrc, (ulong*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadS64BENative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] long* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long*, int>)funcTable[251])(src, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[251])((nint)src, (nint)value);
			#endif
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] long* value)
		{
			int ret = ReadS64BENative(src, value);
			return ret;
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] long* value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				int ret = ReadS64BENative((SDLIOStream*)psrc, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] ref long value)
		{
			fixed (long* pvalue = &value)
			{
				int ret = ReadS64BENative(src, (long*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int ReadS64BE([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64 *")] ref long value)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (long* pvalue = &value)
				{
					int ret = ReadS64BENative((SDLIOStream*)psrc, (long*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteU8Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, int>)funcTable[252])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)funcTable[252])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			int ret = WriteU8Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteU8Native((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write a signed byte to an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteS8Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8")] sbyte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, sbyte, int>)funcTable[253])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, sbyte, int>)funcTable[253])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write a signed byte to an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8")] sbyte value)
		{
			int ret = WriteS8Native(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write a signed byte to an SDL_IOStream.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS8")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint8")] sbyte value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteS8Native((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteU16LENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ushort, int>)funcTable[254])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, int>)funcTable[254])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU16LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			int ret = WriteU16LENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU16LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteU16LENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteS16LENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, short, int>)funcTable[255])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, short, int>)funcTable[255])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS16LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			int ret = WriteS16LENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS16LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS16LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteS16LENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteU16BENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ushort, int>)funcTable[256])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ushort, int>)funcTable[256])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU16BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			int ret = WriteU16BENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU16BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteU16BENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteS16BENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, short, int>)funcTable[257])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, short, int>)funcTable[257])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS16BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			int ret = WriteS16BENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS16BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS16BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteS16BENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteU32LENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, uint, int>)funcTable[258])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[258])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU32LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			int ret = WriteU32LENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU32LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteU32LENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteS32LENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32")] int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, int, int>)funcTable[259])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[259])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS32LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32")] int value)
		{
			int ret = WriteS32LENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS32LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS32LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32")] int value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteS32LENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteU32BENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, uint, int>)funcTable[260])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[260])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU32BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			int ret = WriteU32BENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU32BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteU32BENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteS32BENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32")] int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, int, int>)funcTable[261])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[261])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS32BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32")] int value)
		{
			int ret = WriteS32BENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS32BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS32BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint32")] int value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteS32BENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteU64LENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ulong, int>)funcTable[262])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ulong, int>)funcTable[262])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU64LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			int ret = WriteU64LENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU64LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteU64LENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteS64LENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long, int>)funcTable[263])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, long, int>)funcTable[263])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS64LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			int ret = WriteS64LENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS64LE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS64LE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteS64LENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteU64BENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, ulong, int>)funcTable[264])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, ulong, int>)funcTable[264])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU64BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			int ret = WriteU64BENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteU64BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteU64BENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteS64BENative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, long, int>)funcTable[265])(dst, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, long, int>)funcTable[265])((nint)dst, value);
			#endif
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS64BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			int ret = WriteS64BENative(dst, value);
			return ret;
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteS64BE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static int WriteS64BE([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				int ret = WriteS64BENative((SDLIOStream*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadRuntimeNative([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, int>, byte*, void*, delegate*<void>, delegate*<void>, SDLThread*>)funcTable[266])((delegate*<void*, int>)Utils.GetFunctionPointerForDelegate(fn), name, data, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint>)funcTable[266])((nint)Utils.GetFunctionPointerForDelegate(fn), (nint)name, (nint)data, (nint)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (nint)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#endif
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThread* ret = CreateThreadRuntimeNative(fn, name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			fixed (byte* pname = name)
			{
				SDLThread* ret = CreateThreadRuntimeNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		/// <summary>
		/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros! <br/>
		/// The actual entry point for SDL_CreateThread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadRuntime([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void *")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = CreateThreadRuntimeNative(fn, pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// The actual entry point for SDL_CreateThreadWithProperties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithPropertiesRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLThread* CreateThreadWithPropertiesRuntimeNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, delegate*<void>, delegate*<void>, SDLThread*>)funcTable[267])(props, (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (delegate*<void>)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#else
			return (SDLThread*)((delegate* unmanaged[Cdecl]<uint, nint, nint, nint>)funcTable[267])(props, (nint)Utils.GetFunctionPointerForDelegate(pfnBeginThread), (nint)Utils.GetFunctionPointerForDelegate(pfnEndThread));
			#endif
		}

		/// <summary>
		/// The actual entry point for SDL_CreateThreadWithProperties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithPropertiesRuntime")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread *")]
		public static SDLThread* CreateThreadWithPropertiesRuntime([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "SDL_FunctionPointer")] SDLFunctionPointer pfnEndThread)
		{
			SDLThread* ret = CreateThreadWithPropertiesRuntimeNative(props, pfnBeginThread, pfnEndThread);
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetThreadNameNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, byte*>)funcTable[268])(thread);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[268])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetThreadName([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			byte* ret = GetThreadNameNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetThreadNameS([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			string ret = Utils.DecodeStringUTF8(GetThreadNameNative(thread));
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetThreadName([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				byte* ret = GetThreadNameNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetThreadNameS([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				string ret = Utils.DecodeStringUTF8(GetThreadNameNative((SDLThread*)pthread));
				return ret;
			}
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetCurrentThreadIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[269])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[269])();
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		public static ulong GetCurrentThreadID()
		{
			ulong ret = GetCurrentThreadIDNative();
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetThreadIDNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThread*, ulong>)funcTable[270])(thread);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[270])((nint)thread);
			#endif
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		public static ulong GetThreadID([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			ulong ret = GetThreadIDNative(thread);
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_ThreadID")]
		public static ulong GetThreadID([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				ulong ret = GetThreadIDNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetThreadPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetThreadPriorityNative([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLThreadPriority, int>)funcTable[271])(priority);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLThreadPriority, int>)funcTable[271])(priority);
			#endif
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetThreadPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetThreadPriority([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority)
		{
			int ret = SetThreadPriorityNative(priority);
			return ret;
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] int* status)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, int*, void>)funcTable[272])(thread, status);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[272])((nint)thread, (nint)status);
			#endif
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] int* status)
		{
			WaitThreadNative(thread, status);
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] int* status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				WaitThreadNative((SDLThread*)pthread, status);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] ref int status)
		{
			fixed (int* pstatus = &status)
			{
				WaitThreadNative(thread, (int*)pstatus);
			}
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int *")] ref int status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				fixed (int* pstatus = &status)
				{
					WaitThreadNative((SDLThread*)pthread, (int*)pstatus);
				}
			}
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLThread*, void>)funcTable[273])(thread);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[273])((nint)thread);
			#endif
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] SDLThread* thread)
		{
			DetachThreadNative(thread);
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread *")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				DetachThreadNative((SDLThread*)pthread);
			}
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTLS")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetTLSNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, void*>)funcTable[274])(id);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[274])((nint)id);
			#endif
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTLS")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id)
		{
			void* ret = GetTLSNative(id);
			return ret;
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTLS")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] ref uint id)
		{
			fixed (uint* pid = &id)
			{
				void* ret = GetTLSNative((uint*)pid);
				return ret;
			}
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTLS")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetTLSNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "SDL_TLSDestructorCallback")] SDLTLSDestructorCallback destructor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, void*, delegate*<void*, void>, int>)funcTable[275])(id, value, (delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(destructor));
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[275])((nint)id, (nint)value, (nint)Utils.GetFunctionPointerForDelegate(destructor));
			#endif
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTLS")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] uint* id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "SDL_TLSDestructorCallback")] SDLTLSDestructorCallback destructor)
		{
			int ret = SetTLSNative(id, value, destructor);
			return ret;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
		/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
		/// the same ID will refer to the same local storage.<br/>
		/// Note that replacing a value from a previous call to this function on the<br/>
		/// same thread does _not_ call the previous value's destructor!<br/>
		/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
		/// cleaned up if so.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTLS")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SetTLS([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID *")] ref uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "void const *")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "SDL_TLSDestructorCallback")] SDLTLSDestructorCallback destructor)
		{
			fixed (uint* pid = &id)
			{
				int ret = SetTLSNative((uint*)pid, value, destructor);
				return ret;
			}
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// If you are creating your threads outside of SDL and then calling SDL<br/>
		/// functions, you should call this function before your thread exits, to<br/>
		/// properly clean up SDL memory.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CleanupTLS")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CleanupTLSNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[276])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[276])();
			#endif
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// If you are creating your threads outside of SDL and then calling SDL<br/>
		/// functions, you should call this function before your thread exits, to<br/>
		/// properly clean up SDL memory.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CleanupTLS")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CleanupTLS()
		{
			CleanupTLSNative();
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumAudioDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[277])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[277])();
			#endif
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumAudioDrivers()
		{
			int ret = GetNumAudioDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[278])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[278])(index);
			#endif
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetAudioDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = GetAudioDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetAudioDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCurrentAudioDriverNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[279])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[279])();
			#endif
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetCurrentAudioDriver()
		{
			byte* ret = GetCurrentAudioDriverNative();
			return ret;
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetCurrentAudioDriverS()
		{
			string ret = Utils.DecodeStringUTF8(GetCurrentAudioDriverNative());
			return ret;
		}

		/// <summary>
		/// Get a list of currently-connected audio playback devices.<br/>
		/// This returns of list of available devices that play sound, perhaps to<br/>
		/// speakers or headphones ("playback" devices). If you want devices that<br/>
		/// record audio, like a microphone ("recording" devices), use<br/>
		/// SDL_GetAudioRecordingDevices() instead.<br/>
		/// This only returns a list of physical devices; it will not have any device<br/>
		/// IDs returned by SDL_OpenAudioDevice().<br/>
		/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
		/// zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioPlaybackDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetAudioPlaybackDevicesNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[280])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[280])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently-connected audio playback devices.<br/>
		/// This returns of list of available devices that play sound, perhaps to<br/>
		/// speakers or headphones ("playback" devices). If you want devices that<br/>
		/// record audio, like a microphone ("recording" devices), use<br/>
		/// SDL_GetAudioRecordingDevices() instead.<br/>
		/// This only returns a list of physical devices; it will not have any device<br/>
		/// IDs returned by SDL_OpenAudioDevice().<br/>
		/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
		/// zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioPlaybackDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID *")]
		public static uint* GetAudioPlaybackDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetAudioPlaybackDevicesNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently-connected audio playback devices.<br/>
		/// This returns of list of available devices that play sound, perhaps to<br/>
		/// speakers or headphones ("playback" devices). If you want devices that<br/>
		/// record audio, like a microphone ("recording" devices), use<br/>
		/// SDL_GetAudioRecordingDevices() instead.<br/>
		/// This only returns a list of physical devices; it will not have any device<br/>
		/// IDs returned by SDL_OpenAudioDevice().<br/>
		/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
		/// zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioPlaybackDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID *")]
		public static uint* GetAudioPlaybackDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetAudioPlaybackDevicesNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get a list of currently-connected audio recording devices.<br/>
		/// This returns of list of available devices that record audio, like a<br/>
		/// microphone ("recording" devices). If you want devices that play sound,<br/>
		/// perhaps to speakers or headphones ("playback" devices), use<br/>
		/// SDL_GetAudioPlaybackDevices() instead.<br/>
		/// This only returns a list of physical devices; it will not have any device<br/>
		/// IDs returned by SDL_OpenAudioDevice().<br/>
		/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
		/// zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioRecordingDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetAudioRecordingDevicesNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[281])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[281])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently-connected audio recording devices.<br/>
		/// This returns of list of available devices that record audio, like a<br/>
		/// microphone ("recording" devices). If you want devices that play sound,<br/>
		/// perhaps to speakers or headphones ("playback" devices), use<br/>
		/// SDL_GetAudioPlaybackDevices() instead.<br/>
		/// This only returns a list of physical devices; it will not have any device<br/>
		/// IDs returned by SDL_OpenAudioDevice().<br/>
		/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
		/// zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioRecordingDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID *")]
		public static uint* GetAudioRecordingDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetAudioRecordingDevicesNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently-connected audio recording devices.<br/>
		/// This returns of list of available devices that record audio, like a<br/>
		/// microphone ("recording" devices). If you want devices that play sound,<br/>
		/// perhaps to speakers or headphones ("playback" devices), use<br/>
		/// SDL_GetAudioPlaybackDevices() instead.<br/>
		/// This only returns a list of physical devices; it will not have any device<br/>
		/// IDs returned by SDL_OpenAudioDevice().<br/>
		/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
		/// zero.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioRecordingDevices")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID *")]
		public static uint* GetAudioRecordingDevices([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetAudioRecordingDevicesNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAudioDeviceNameNative([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[282])(devid);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[282])(devid);
			#endif
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetAudioDeviceName([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid)
		{
			byte* ret = GetAudioDeviceNameNative(devid);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetAudioDeviceNameS([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid)
		{
			string ret = Utils.DecodeStringUTF8(GetAudioDeviceNameNative(devid));
			return ret;
		}

		/// <summary>
		/// Get the current audio format of a specific audio device.<br/>
		/// For an opened device, this will report the format the device is currently<br/>
		/// using. If the device isn't yet opened, this will report the device's<br/>
		/// preferred format (or a reasonable default if this can't be determined).<br/>
		/// You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or<br/>
		/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a<br/>
		/// reasonable recommendation before opening the system-recommended default<br/>
		/// device.<br/>
		/// You can also use this to request the current device buffer size. This is<br/>
		/// specified in sample frames and represents the amount of data SDL will feed<br/>
		/// to the physical hardware in each chunk. This can be converted to<br/>
		/// milliseconds of audio with the following equation:<br/>
		/// `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`<br/>
		/// Buffer size is only important if you need low-level control over the audio<br/>
		/// playback timing. Most apps do not need this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceFormat")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAudioDeviceFormatNative([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "sample_frames")] [NativeName(NativeNameType.Type, "int *")] int* sampleFrames)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLAudioSpec*, int*, int>)funcTable[283])(devid, spec, sampleFrames);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, nint, int>)funcTable[283])(devid, (nint)spec, (nint)sampleFrames);
			#endif
		}

		/// <summary>
		/// Get the current audio format of a specific audio device.<br/>
		/// For an opened device, this will report the format the device is currently<br/>
		/// using. If the device isn't yet opened, this will report the device's<br/>
		/// preferred format (or a reasonable default if this can't be determined).<br/>
		/// You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or<br/>
		/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a<br/>
		/// reasonable recommendation before opening the system-recommended default<br/>
		/// device.<br/>
		/// You can also use this to request the current device buffer size. This is<br/>
		/// specified in sample frames and represents the amount of data SDL will feed<br/>
		/// to the physical hardware in each chunk. This can be converted to<br/>
		/// milliseconds of audio with the following equation:<br/>
		/// `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`<br/>
		/// Buffer size is only important if you need low-level control over the audio<br/>
		/// playback timing. Most apps do not need this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceFormat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAudioDeviceFormat([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "sample_frames")] [NativeName(NativeNameType.Type, "int *")] int* sampleFrames)
		{
			int ret = GetAudioDeviceFormatNative(devid, spec, sampleFrames);
			return ret;
		}

		/// <summary>
		/// Get the current audio format of a specific audio device.<br/>
		/// For an opened device, this will report the format the device is currently<br/>
		/// using. If the device isn't yet opened, this will report the device's<br/>
		/// preferred format (or a reasonable default if this can't be determined).<br/>
		/// You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or<br/>
		/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a<br/>
		/// reasonable recommendation before opening the system-recommended default<br/>
		/// device.<br/>
		/// You can also use this to request the current device buffer size. This is<br/>
		/// specified in sample frames and represents the amount of data SDL will feed<br/>
		/// to the physical hardware in each chunk. This can be converted to<br/>
		/// milliseconds of audio with the following equation:<br/>
		/// `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`<br/>
		/// Buffer size is only important if you need low-level control over the audio<br/>
		/// playback timing. Most apps do not need this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceFormat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAudioDeviceFormat([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "sample_frames")] [NativeName(NativeNameType.Type, "int *")] int* sampleFrames)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = GetAudioDeviceFormatNative(devid, (SDLAudioSpec*)pspec, sampleFrames);
				return ret;
			}
		}

		/// <summary>
		/// Get the current audio format of a specific audio device.<br/>
		/// For an opened device, this will report the format the device is currently<br/>
		/// using. If the device isn't yet opened, this will report the device's<br/>
		/// preferred format (or a reasonable default if this can't be determined).<br/>
		/// You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or<br/>
		/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a<br/>
		/// reasonable recommendation before opening the system-recommended default<br/>
		/// device.<br/>
		/// You can also use this to request the current device buffer size. This is<br/>
		/// specified in sample frames and represents the amount of data SDL will feed<br/>
		/// to the physical hardware in each chunk. This can be converted to<br/>
		/// milliseconds of audio with the following equation:<br/>
		/// `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`<br/>
		/// Buffer size is only important if you need low-level control over the audio<br/>
		/// playback timing. Most apps do not need this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceFormat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAudioDeviceFormat([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "sample_frames")] [NativeName(NativeNameType.Type, "int *")] ref int sampleFrames)
		{
			fixed (int* psampleFrames = &sampleFrames)
			{
				int ret = GetAudioDeviceFormatNative(devid, spec, (int*)psampleFrames);
				return ret;
			}
		}

		/// <summary>
		/// Get the current audio format of a specific audio device.<br/>
		/// For an opened device, this will report the format the device is currently<br/>
		/// using. If the device isn't yet opened, this will report the device's<br/>
		/// preferred format (or a reasonable default if this can't be determined).<br/>
		/// You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or<br/>
		/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a<br/>
		/// reasonable recommendation before opening the system-recommended default<br/>
		/// device.<br/>
		/// You can also use this to request the current device buffer size. This is<br/>
		/// specified in sample frames and represents the amount of data SDL will feed<br/>
		/// to the physical hardware in each chunk. This can be converted to<br/>
		/// milliseconds of audio with the following equation:<br/>
		/// `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`<br/>
		/// Buffer size is only important if you need low-level control over the audio<br/>
		/// playback timing. Most apps do not need this.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceFormat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetAudioDeviceFormat([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec *")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "sample_frames")] [NativeName(NativeNameType.Type, "int *")] ref int sampleFrames)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (int* psampleFrames = &sampleFrames)
				{
					int ret = GetAudioDeviceFormatNative(devid, (SDLAudioSpec*)pspec, (int*)psampleFrames);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current channel map of an audio device.<br/>
		/// Channel maps are optional; most things do not need them, instead passing<br/>
		/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
		/// Audio devices usually have no remapping applied. This is represented by<br/>
		/// returning NULL, and does not signify an error.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceChannelMap")]
		[return: NativeName(NativeNameType.Type, "int *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int* GetAudioDeviceChannelMapNative([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int*, int*>)funcTable[284])(devid, count);
			#else
			return (int*)((delegate* unmanaged[Cdecl]<uint, nint, nint>)funcTable[284])(devid, (nint)count);
			#endif
		}

		/// <summary>
		/// Get the current channel map of an audio device.<br/>
		/// Channel maps are optional; most things do not need them, instead passing<br/>
		/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
		/// Audio devices usually have no remapping applied. This is represented by<br/>
		/// returning NULL, and does not signify an error.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceChannelMap")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* GetAudioDeviceChannelMap([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			int* ret = GetAudioDeviceChannelMapNative(devid, count);
			return ret;
		}

		/// <summary>
		/// Get the current channel map of an audio device.<br/>
		/// Channel maps are optional; most things do not need them, instead passing<br/>
		/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
		/// Audio devices usually have no remapping applied. This is represented by<br/>
		/// returning NULL, and does not signify an error.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceChannelMap")]
		[return: NativeName(NativeNameType.Type, "int *")]
		public static int* GetAudioDeviceChannelMap([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				int* ret = GetAudioDeviceChannelMapNative(devid, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// You can open both playback and recording devices through this function.<br/>
		/// Playback devices will take data from bound audio streams, mix it, and send<br/>
		/// it to the hardware. Recording devices will feed any bound audio streams<br/>
		/// with a copy of any incoming data.<br/>
		/// An opened audio device starts out with no audio streams bound. To start<br/>
		/// audio playing, bind a stream and supply audio data to it. Unlike SDL2,<br/>
		/// there is no audio callback; you only bind audio streams and make sure they<br/>
		/// have data flowing into them (however, you can simulate SDL2's semantics<br/>
		/// fairly closely by using SDL_OpenAudioDeviceStream instead of this<br/>
		/// function).<br/>
		/// If you don't care about opening a specific device, pass a `devid` of either<br/>
		/// `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or<br/>
		/// `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick<br/>
		/// the most reasonable default, and may also switch between physical devices<br/>
		/// seamlessly later, if the most reasonable default changes during the<br/>
		/// lifetime of this opened device (user changed the default in the OS's system<br/>
		/// preferences, the default got unplugged so the system jumped to a new<br/>
		/// default, the user plugged in headphones on a mobile device, etc). Unless<br/>
		/// you have a good reason to choose a specific device, this is probably what<br/>
		/// you want.<br/>
		/// You may request a specific format for the audio device, but there is no<br/>
		/// promise the device will honor that request for several reasons. As such,<br/>
		/// it's only meant to be a hint as to what data your app will provide. Audio<br/>
		/// streams will accept data in whatever format you specify and manage<br/>
		/// conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you<br/>
		/// the preferred format for the device before opening and the actual format<br/>
		/// the device is using after opening.<br/>
		/// It's legal to open the same device ID more than once; each successful open<br/>
		/// will generate a new logical SDL_AudioDeviceID that is managed separately<br/>
		/// from others on the same physical device. This allows libraries to open a<br/>
		/// device separately from the main app and bind its own streams without<br/>
		/// conflicting.<br/>
		/// It is also legal to open a device ID returned by a previous call to this<br/>
		/// function; doing so just creates another logical device on the same physical<br/>
		/// device. This may be useful for making logical groupings of audio streams.<br/>
		/// This function returns the opened device ID on success. This is a new,<br/>
		/// unique SDL_AudioDeviceID that represents a logical device.<br/>
		/// Some backends might offer arbitrary devices (for example, a networked audio<br/>
		/// protocol that can connect to an arbitrary server). For these, as a change<br/>
		/// from SDL2, you should open a default device ID and use an SDL hint to<br/>
		/// specify the target if you care, or otherwise let the backend figure out a<br/>
		/// reasonable default. Most backends don't offer anything like this, and often<br/>
		/// this would be an end user setting an environment variable for their custom<br/>
		/// need, and not something an application should specifically manage.<br/>
		/// When done with an audio device, possibly at the end of the app's life, one<br/>
		/// should call SDL_CloseAudioDevice() on the returned device id.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint OpenAudioDeviceNative([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpec* spec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLAudioSpec*, uint>)funcTable[285])(devid, spec);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint>)funcTable[285])(devid, (nint)spec);
			#endif
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// You can open both playback and recording devices through this function.<br/>
		/// Playback devices will take data from bound audio streams, mix it, and send<br/>
		/// it to the hardware. Recording devices will feed any bound audio streams<br/>
		/// with a copy of any incoming data.<br/>
		/// An opened audio device starts out with no audio streams bound. To start<br/>
		/// audio playing, bind a stream and supply audio data to it. Unlike SDL2,<br/>
		/// there is no audio callback; you only bind audio streams and make sure they<br/>
		/// have data flowing into them (however, you can simulate SDL2's semantics<br/>
		/// fairly closely by using SDL_OpenAudioDeviceStream instead of this<br/>
		/// function).<br/>
		/// If you don't care about opening a specific device, pass a `devid` of either<br/>
		/// `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or<br/>
		/// `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick<br/>
		/// the most reasonable default, and may also switch between physical devices<br/>
		/// seamlessly later, if the most reasonable default changes during the<br/>
		/// lifetime of this opened device (user changed the default in the OS's system<br/>
		/// preferences, the default got unplugged so the system jumped to a new<br/>
		/// default, the user plugged in headphones on a mobile device, etc). Unless<br/>
		/// you have a good reason to choose a specific device, this is probably what<br/>
		/// you want.<br/>
		/// You may request a specific format for the audio device, but there is no<br/>
		/// promise the device will honor that request for several reasons. As such,<br/>
		/// it's only meant to be a hint as to what data your app will provide. Audio<br/>
		/// streams will accept data in whatever format you specify and manage<br/>
		/// conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you<br/>
		/// the preferred format for the device before opening and the actual format<br/>
		/// the device is using after opening.<br/>
		/// It's legal to open the same device ID more than once; each successful open<br/>
		/// will generate a new logical SDL_AudioDeviceID that is managed separately<br/>
		/// from others on the same physical device. This allows libraries to open a<br/>
		/// device separately from the main app and bind its own streams without<br/>
		/// conflicting.<br/>
		/// It is also legal to open a device ID returned by a previous call to this<br/>
		/// function; doing so just creates another logical device on the same physical<br/>
		/// device. This may be useful for making logical groupings of audio streams.<br/>
		/// This function returns the opened device ID on success. This is a new,<br/>
		/// unique SDL_AudioDeviceID that represents a logical device.<br/>
		/// Some backends might offer arbitrary devices (for example, a networked audio<br/>
		/// protocol that can connect to an arbitrary server). For these, as a change<br/>
		/// from SDL2, you should open a default device ID and use an SDL hint to<br/>
		/// specify the target if you care, or otherwise let the backend figure out a<br/>
		/// reasonable default. Most backends don't offer anything like this, and often<br/>
		/// this would be an end user setting an environment variable for their custom<br/>
		/// need, and not something an application should specifically manage.<br/>
		/// When done with an audio device, possibly at the end of the app's life, one<br/>
		/// should call SDL_CloseAudioDevice() on the returned device id.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint OpenAudioDevice([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] SDLAudioSpec* spec)
		{
			uint ret = OpenAudioDeviceNative(devid, spec);
			return ret;
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// You can open both playback and recording devices through this function.<br/>
		/// Playback devices will take data from bound audio streams, mix it, and send<br/>
		/// it to the hardware. Recording devices will feed any bound audio streams<br/>
		/// with a copy of any incoming data.<br/>
		/// An opened audio device starts out with no audio streams bound. To start<br/>
		/// audio playing, bind a stream and supply audio data to it. Unlike SDL2,<br/>
		/// there is no audio callback; you only bind audio streams and make sure they<br/>
		/// have data flowing into them (however, you can simulate SDL2's semantics<br/>
		/// fairly closely by using SDL_OpenAudioDeviceStream instead of this<br/>
		/// function).<br/>
		/// If you don't care about opening a specific device, pass a `devid` of either<br/>
		/// `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or<br/>
		/// `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick<br/>
		/// the most reasonable default, and may also switch between physical devices<br/>
		/// seamlessly later, if the most reasonable default changes during the<br/>
		/// lifetime of this opened device (user changed the default in the OS's system<br/>
		/// preferences, the default got unplugged so the system jumped to a new<br/>
		/// default, the user plugged in headphones on a mobile device, etc). Unless<br/>
		/// you have a good reason to choose a specific device, this is probably what<br/>
		/// you want.<br/>
		/// You may request a specific format for the audio device, but there is no<br/>
		/// promise the device will honor that request for several reasons. As such,<br/>
		/// it's only meant to be a hint as to what data your app will provide. Audio<br/>
		/// streams will accept data in whatever format you specify and manage<br/>
		/// conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you<br/>
		/// the preferred format for the device before opening and the actual format<br/>
		/// the device is using after opening.<br/>
		/// It's legal to open the same device ID more than once; each successful open<br/>
		/// will generate a new logical SDL_AudioDeviceID that is managed separately<br/>
		/// from others on the same physical device. This allows libraries to open a<br/>
		/// device separately from the main app and bind its own streams without<br/>
		/// conflicting.<br/>
		/// It is also legal to open a device ID returned by a previous call to this<br/>
		/// function; doing so just creates another logical device on the same physical<br/>
		/// device. This may be useful for making logical groupings of audio streams.<br/>
		/// This function returns the opened device ID on success. This is a new,<br/>
		/// unique SDL_AudioDeviceID that represents a logical device.<br/>
		/// Some backends might offer arbitrary devices (for example, a networked audio<br/>
		/// protocol that can connect to an arbitrary server). For these, as a change<br/>
		/// from SDL2, you should open a default device ID and use an SDL hint to<br/>
		/// specify the target if you care, or otherwise let the backend figure out a<br/>
		/// reasonable default. Most backends don't offer anything like this, and often<br/>
		/// this would be an end user setting an environment variable for their custom<br/>
		/// need, and not something an application should specifically manage.<br/>
		/// When done with an audio device, possibly at the end of the app's life, one<br/>
		/// should call SDL_CloseAudioDevice() on the returned device id.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint OpenAudioDevice([NativeName(NativeNameType.Param, "devid")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint devid, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec const *")] ref SDLAudioSpec spec)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				uint ret = OpenAudioDeviceNative(devid, (SDLAudioSpec*)pspec);
				return ret;
			}
		}
	}
}
