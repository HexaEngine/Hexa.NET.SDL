// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Compute the arc tangent of `x`.<br/>
		/// The definition of `y = atan(x)` is `x = tan(y)`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-Pi/2 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi/2`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_atan for dboule-precision floats.<br/>
		/// To calculate the arc tangent of y / x, use SDL_atan2f.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_atanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float AtanfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[117])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[117])(x);
			#endif
		}

		/// <summary>
		/// Compute the arc tangent of `x`.<br/>
		/// The definition of `y = atan(x)` is `x = tan(y)`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-Pi/2 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi/2`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_atan for dboule-precision floats.<br/>
		/// To calculate the arc tangent of y / x, use SDL_atan2f.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_atanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Atanf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = AtanfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the arc tangent of `y / x`, using the signs of x and y to adjust<br/>
		/// the result's quadrant.<br/>
		/// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant<br/>
		/// of z is determined based on the signs of x and y.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-Pi <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_atan2f for single-precision floats.<br/>
		/// To calculate the arc tangent of a single value, use SDL_atan.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_atan2")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Atan2Native([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[118])(y, x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[118])(y, x);
			#endif
		}

		/// <summary>
		/// Compute the arc tangent of `y / x`, using the signs of x and y to adjust<br/>
		/// the result's quadrant.<br/>
		/// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant<br/>
		/// of z is determined based on the signs of x and y.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-Pi <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_atan2f for single-precision floats.<br/>
		/// To calculate the arc tangent of a single value, use SDL_atan.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_atan2")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Atan2([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = Atan2Native(y, x);
			return ret;
		}

		/// <summary>
		/// Compute the arc tangent of `y / x`, using the signs of x and y to adjust<br/>
		/// the result's quadrant.<br/>
		/// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant<br/>
		/// of z is determined based on the signs of x and y.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-Pi <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_atan2 for double-precision floats.<br/>
		/// To calculate the arc tangent of a single value, use SDL_atanf.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_atan2f")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float Atan2FNative([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[119])(y, x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[119])(y, x);
			#endif
		}

		/// <summary>
		/// Compute the arc tangent of `y / x`, using the signs of x and y to adjust<br/>
		/// the result's quadrant.<br/>
		/// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant<br/>
		/// of z is determined based on the signs of x and y.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-Pi <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_atan2 for double-precision floats.<br/>
		/// To calculate the arc tangent of a single value, use SDL_atanf.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_atan2f")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Atan2F([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = Atan2FNative(y, x);
			return ret;
		}

		/// <summary>
		/// Compute the ceiling of `x`.<br/>
		/// The ceiling of `x` is the smallest integer `y` such that `y >= x`, i.e `x`<br/>
		/// rounded up to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_ceilf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ceil")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double CeilNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[120])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[120])(x);
			#endif
		}

		/// <summary>
		/// Compute the ceiling of `x`.<br/>
		/// The ceiling of `x` is the smallest integer `y` such that `y >= x`, i.e `x`<br/>
		/// rounded up to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_ceilf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ceil")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Ceil([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = CeilNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the ceiling of `x`.<br/>
		/// The ceiling of `x` is the smallest integer `y` such that `y >= x`, i.e `x`<br/>
		/// rounded up to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_ceil for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ceilf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CeilfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[121])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[121])(x);
			#endif
		}

		/// <summary>
		/// Compute the ceiling of `x`.<br/>
		/// The ceiling of `x` is the smallest integer `y` such that `y >= x`, i.e `x`<br/>
		/// rounded up to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_ceil for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ceilf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Ceilf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = CeilfNative(x);
			return ret;
		}

		/// <summary>
		/// Copy the sign of one floating-point value to another.<br/>
		/// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, ``-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = f``<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_copysignf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_copysign")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double CopysignNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[122])(x, y);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[122])(x, y);
			#endif
		}

		/// <summary>
		/// Copy the sign of one floating-point value to another.<br/>
		/// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, ``-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = f``<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_copysignf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_copysign")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Copysign([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			double ret = CopysignNative(x, y);
			return ret;
		}

		/// <summary>
		/// Copy the sign of one floating-point value to another.<br/>
		/// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, ``-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = f``<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_copysign for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_copysignf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CopysignfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[123])(x, y);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[123])(x, y);
			#endif
		}

		/// <summary>
		/// Copy the sign of one floating-point value to another.<br/>
		/// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, ``-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = f``<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_copysign for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_copysignf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Copysignf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			float ret = CopysignfNative(x, y);
			return ret;
		}

		/// <summary>
		/// Compute the cosine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_cosf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_cos")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double CosNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[124])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[124])(x);
			#endif
		}

		/// <summary>
		/// Compute the cosine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_cosf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_cos")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Cos([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = CosNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the cosine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_cos for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_cosf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CosfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[125])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[125])(x);
			#endif
		}

		/// <summary>
		/// Compute the cosine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_cos for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_cosf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Cosf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = CosfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the exponential of `x`.<br/>
		/// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the<br/>
		/// natural logarithm. The inverse is the natural logarithm, SDL_log.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// The output will overflow if `exp(x)` is too large to be represented.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_expf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_exp")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ExpNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[126])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[126])(x);
			#endif
		}

		/// <summary>
		/// Compute the exponential of `x`.<br/>
		/// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the<br/>
		/// natural logarithm. The inverse is the natural logarithm, SDL_log.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// The output will overflow if `exp(x)` is too large to be represented.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_expf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_exp")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Exp([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = ExpNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the exponential of `x`.<br/>
		/// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the<br/>
		/// natural logarithm. The inverse is the natural logarithm, SDL_logf.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// The output will overflow if `exp(x)` is too large to be represented.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_exp for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_expf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ExpfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[127])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[127])(x);
			#endif
		}

		/// <summary>
		/// Compute the exponential of `x`.<br/>
		/// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the<br/>
		/// natural logarithm. The inverse is the natural logarithm, SDL_logf.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// The output will overflow if `exp(x)` is too large to be represented.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_exp for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_expf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Expf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = ExpfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the absolute value of `x`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_fabsf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fabs")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double FabsNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[128])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[128])(x);
			#endif
		}

		/// <summary>
		/// Compute the absolute value of `x`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_fabsf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fabs")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Fabs([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = FabsNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the absolute value of `x`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_fabs for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fabsf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float FabsfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[129])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[129])(x);
			#endif
		}

		/// <summary>
		/// Compute the absolute value of `x`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_fabs for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fabsf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Fabsf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = FabsfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the floor of `x`.<br/>
		/// The floor of `x` is the largest integer `y` such that `y <br/>
		/// <<br/>
		/// = x`, i.e `x`<br/>
		/// rounded down to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_floorf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_floor")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double FloorNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[130])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[130])(x);
			#endif
		}

		/// <summary>
		/// Compute the floor of `x`.<br/>
		/// The floor of `x` is the largest integer `y` such that `y <br/>
		/// <<br/>
		/// = x`, i.e `x`<br/>
		/// rounded down to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_floorf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_floor")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Floor([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = FloorNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the floor of `x`.<br/>
		/// The floor of `x` is the largest integer `y` such that `y <br/>
		/// <<br/>
		/// = x`, i.e `x`<br/>
		/// rounded down to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_floor for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_floorf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float FloorfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[131])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[131])(x);
			#endif
		}

		/// <summary>
		/// Compute the floor of `x`.<br/>
		/// The floor of `x` is the largest integer `y` such that `y <br/>
		/// <<br/>
		/// = x`, i.e `x`<br/>
		/// rounded down to the nearest integer.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_floor for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_floorf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Floorf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = FloorfNative(x);
			return ret;
		}

		/// <summary>
		/// Truncate `x` to an integer.<br/>
		/// Rounds `x` to the next closest integer to 0. This is equivalent to removing<br/>
		/// the fractional part of `x`, leaving only the integer part.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_truncf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_trunc")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TruncNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[132])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[132])(x);
			#endif
		}

		/// <summary>
		/// Truncate `x` to an integer.<br/>
		/// Rounds `x` to the next closest integer to 0. This is equivalent to removing<br/>
		/// the fractional part of `x`, leaving only the integer part.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_truncf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_trunc")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Trunc([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = TruncNative(x);
			return ret;
		}

		/// <summary>
		/// Truncate `x` to an integer.<br/>
		/// Rounds `x` to the next closest integer to 0. This is equivalent to removing<br/>
		/// the fractional part of `x`, leaving only the integer part.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_trunc for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_truncf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TruncfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[133])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[133])(x);
			#endif
		}

		/// <summary>
		/// Truncate `x` to an integer.<br/>
		/// Rounds `x` to the next closest integer to 0. This is equivalent to removing<br/>
		/// the fractional part of `x`, leaving only the integer part.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_trunc for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_truncf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Truncf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = TruncfNative(x);
			return ret;
		}

		/// <summary>
		/// Return the floating-point remainder of `x / y`<br/>
		/// Divides `x` by `y`, and returns the remainder.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, `y != 0`<br/>
		/// Range: `-y <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = y`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_fmodf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fmod")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double FmodNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[134])(x, y);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[134])(x, y);
			#endif
		}

		/// <summary>
		/// Return the floating-point remainder of `x / y`<br/>
		/// Divides `x` by `y`, and returns the remainder.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, `y != 0`<br/>
		/// Range: `-y <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = y`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_fmodf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fmod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Fmod([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			double ret = FmodNative(x, y);
			return ret;
		}

		/// <summary>
		/// Return the floating-point remainder of `x / y`<br/>
		/// Divides `x` by `y`, and returns the remainder.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, `y != 0`<br/>
		/// Range: `-y <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = y`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_fmod for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fmodf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float FmodfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[135])(x, y);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[135])(x, y);
			#endif
		}

		/// <summary>
		/// Return the floating-point remainder of `x / y`<br/>
		/// Divides `x` by `y`, and returns the remainder.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, `y != 0`<br/>
		/// Range: `-y <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = y`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_fmod for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_fmodf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Fmodf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			float ret = FmodfNative(x, y);
			return ret;
		}

		/// <summary>
		/// Return whether the value is infinity.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isinf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsinfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[136])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[136])(x);
			#endif
		}

		/// <summary>
		/// Return whether the value is infinity.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isinf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isinf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			int ret = IsinfNative(x);
			return ret;
		}

		/// <summary>
		/// Return whether the value is infinity.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isinff")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsinffNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int>)funcTable[137])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<float, int>)funcTable[137])(x);
			#endif
		}

		/// <summary>
		/// Return whether the value is infinity.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isinff")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isinff([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			int ret = IsinffNative(x);
			return ret;
		}

		/// <summary>
		/// Return whether the value is NaN.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isnan")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsnanNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[138])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[138])(x);
			#endif
		}

		/// <summary>
		/// Return whether the value is NaN.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isnan")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isnan([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			int ret = IsnanNative(x);
			return ret;
		}

		/// <summary>
		/// Return whether the value is NaN.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isnanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsnanfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int>)funcTable[139])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<float, int>)funcTable[139])(x);
			#endif
		}

		/// <summary>
		/// Return whether the value is NaN.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_isnanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Isnanf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			int ret = IsnanfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the natural logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_logf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_log")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double LogNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[140])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[140])(x);
			#endif
		}

		/// <summary>
		/// Compute the natural logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_logf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_log")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Log([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = LogNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the natural logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_log for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_logf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float LogfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[141])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[141])(x);
			#endif
		}

		/// <summary>
		/// Compute the natural logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_log for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_logf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Logf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = LogfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the base-10 logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_log10f for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_log10")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double Log10Native([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[142])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[142])(x);
			#endif
		}

		/// <summary>
		/// Compute the base-10 logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_log10f for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_log10")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Log10([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = Log10Native(x);
			return ret;
		}

		/// <summary>
		/// Compute the base-10 logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_log10 for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_log10f")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float Log10FNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[143])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[143])(x);
			#endif
		}

		/// <summary>
		/// Compute the base-10 logarithm of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// It is an error for `x` to be less than or equal to 0.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_log10 for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_log10f")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Log10F([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = Log10FNative(x);
			return ret;
		}

		/// <summary>
		/// Split `x` into integer and fractional parts<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_modff for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_modf")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ModfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double *")] double* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double*, double>)funcTable[144])(x, y);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[144])(x, (nint)y);
			#endif
		}

		/// <summary>
		/// Split `x` into integer and fractional parts<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_modff for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_modf")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Modf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double *")] double* y)
		{
			double ret = ModfNative(x, y);
			return ret;
		}

		/// <summary>
		/// Split `x` into integer and fractional parts<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_modff for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_modf")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Modf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double *")] ref double y)
		{
			fixed (double* py = &y)
			{
				double ret = ModfNative(x, (double*)py);
				return ret;
			}
		}

		/// <summary>
		/// Split `x` into integer and fractional parts<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_modf for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_modff")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ModffNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float*, float>)funcTable[145])(x, y);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, nint, float>)funcTable[145])(x, (nint)y);
			#endif
		}

		/// <summary>
		/// Split `x` into integer and fractional parts<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_modf for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_modff")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Modff([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y)
		{
			float ret = ModffNative(x, y);
			return ret;
		}

		/// <summary>
		/// Split `x` into integer and fractional parts<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_modf for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_modff")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Modff([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y)
		{
			fixed (float* py = &y)
			{
				float ret = ModffNative(x, (float*)py);
				return ret;
			}
		}

		/// <summary>
		/// Raise `x` to the power `y`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// If `y` is the base of the natural logarithm (e), consider using SDL_exp<br/>
		/// instead.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_powf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_pow")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double PowNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[146])(x, y);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double, double>)funcTable[146])(x, y);
			#endif
		}

		/// <summary>
		/// Raise `x` to the power `y`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// If `y` is the base of the natural logarithm (e), consider using SDL_exp<br/>
		/// instead.<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_powf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_pow")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Pow([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			double ret = PowNative(x, y);
			return ret;
		}

		/// <summary>
		/// Raise `x` to the power `y`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// If `y` is the base of the natural logarithm (e), consider using SDL_exp<br/>
		/// instead.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_pow for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_powf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float PowfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[147])(x, y);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float, float>)funcTable[147])(x, y);
			#endif
		}

		/// <summary>
		/// Raise `x` to the power `y`<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = z <br/>
		/// <<br/>
		/// = INF`<br/>
		/// If `y` is the base of the natural logarithm (e), consider using SDL_exp<br/>
		/// instead.<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_pow for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_powf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Powf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			float ret = PowfNative(x, y);
			return ret;
		}

		/// <summary>
		/// Round `x` to the nearest integer.<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_roundf for single-precision floats. To get the result as an integer<br/>
		/// type, use SDL_lround.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_round")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double RoundNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[148])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[148])(x);
			#endif
		}

		/// <summary>
		/// Round `x` to the nearest integer.<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_roundf for single-precision floats. To get the result as an integer<br/>
		/// type, use SDL_lround.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_round")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Round([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = RoundNative(x);
			return ret;
		}

		/// <summary>
		/// Round `x` to the nearest integer.<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_round for double-precision floats. To get the result as an integer<br/>
		/// type, use SDL_lroundf.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_roundf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float RoundfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[149])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[149])(x);
			#endif
		}

		/// <summary>
		/// Round `x` to the nearest integer.<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`, y integer<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_round for double-precision floats. To get the result as an integer<br/>
		/// type, use SDL_lroundf.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_roundf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Roundf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = RoundfNative(x);
			return ret;
		}

		/// <summary>
		/// Round `x` to the nearest integer representable as a long<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `MIN_LONG <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = MAX_LONG`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_lroundf for single-precision floats. To get the result as a<br/>
		/// floating-point type, use SDL_round.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_lround")]
		[return: NativeName(NativeNameType.Type, "long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LroundNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[150])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[150])(x);
			#endif
		}

		/// <summary>
		/// Round `x` to the nearest integer representable as a long<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `MIN_LONG <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = MAX_LONG`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_lroundf for single-precision floats. To get the result as a<br/>
		/// floating-point type, use SDL_round.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_lround")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Lround([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			int ret = LroundNative(x);
			return ret;
		}

		/// <summary>
		/// Round `x` to the nearest integer representable as a long<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `MIN_LONG <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = MAX_LONG`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_lround for double-precision floats. To get the result as a<br/>
		/// floating-point type, use SDL_roundf.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_lroundf")]
		[return: NativeName(NativeNameType.Type, "long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LroundfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int>)funcTable[151])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<float, int>)funcTable[151])(x);
			#endif
		}

		/// <summary>
		/// Round `x` to the nearest integer representable as a long<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `MIN_LONG <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = MAX_LONG`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_lround for double-precision floats. To get the result as a<br/>
		/// floating-point type, use SDL_roundf.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_lroundf")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Lroundf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			int ret = LroundfNative(x);
			return ret;
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_scalbnf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbn")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ScalbnNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[152])(x, n);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[152])(x, n);
			#endif
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_scalbnf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbn")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Scalbn([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			double ret = ScalbnNative(x, n);
			return ret;
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_scalbn for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbnf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ScalbnfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int, float>)funcTable[153])(x, n);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, int, float>)funcTable[153])(x, n);
			#endif
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_scalbn for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbnf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Scalbnf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			float ret = ScalbnfNative(x, n);
			return ret;
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sinf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sin")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double SinNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[154])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[154])(x);
			#endif
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sinf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sin")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Sin([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SinNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sin for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float SinfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[155])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[155])(x);
			#endif
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sin for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Sinf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SinfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sqrtf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrt")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double SqrtNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[156])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[156])(x);
			#endif
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sqrtf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrt")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Sqrt([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SqrtNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sqrt for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrtf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float SqrtfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[157])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[157])(x);
			#endif
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sqrt for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrtf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Sqrtf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SqrtfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_tanf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tan")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TanNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[158])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[158])(x);
			#endif
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_tanf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tan")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Tan([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = TanNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_tan for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TanfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[159])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[159])(x);
			#endif
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_tan for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Tanf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = TanfNative(x);
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIconvT IconvOpenNative([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLIconvT>)funcTable[160])(tocode, fromcode);
			#else
			return (SDLIconvT)((delegate* unmanaged[Cdecl]<nint, nint, SDLIconvT>)funcTable[160])((nint)tocode, (nint)fromcode);
			#endif
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			SDLIconvT ret = IconvOpenNative(tocode, fromcode);
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				SDLIconvT ret = IconvOpenNative((byte*)ptocode, fromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			fixed (byte* ptocode = tocode)
			{
				SDLIconvT ret = IconvOpenNative((byte*)ptocode, fromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconvT ret = IconvOpenNative(pStr0, fromcode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				SDLIconvT ret = IconvOpenNative(tocode, (byte*)pfromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode)
		{
			fixed (byte* pfromcode = fromcode)
			{
				SDLIconvT ret = IconvOpenNative(tocode, (byte*)pfromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconvT ret = IconvOpenNative(tocode, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					SDLIconvT ret = IconvOpenNative((byte*)ptocode, (byte*)pfromcode);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					SDLIconvT ret = IconvOpenNative((byte*)ptocode, (byte*)pfromcode);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconvT IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLIconvT ret = IconvOpenNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function frees a context used for character set conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IconvCloseNative([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIconvT, int>)funcTable[161])(cd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLIconvT, int>)funcTable[161])(cd);
			#endif
		}

		/// <summary>
		/// This function frees a context used for character set conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IconvClose([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd)
		{
			int ret = IconvCloseNative(cd);
			return ret;
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint IconvNative([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIconvT, byte**, nuint*, byte**, nuint*, nuint>)funcTable[162])(cd, inbuf, inbytesleft, outbuf, outbytesleft);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<SDLIconvT, nint, nint, nint, nint, nuint>)funcTable[162])(cd, (nint)inbuf, (nint)inbytesleft, (nint)outbuf, (nint)outbytesleft);
			#endif
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			nuint ret = IconvNative(cd, inbuf, inbytesleft, outbuf, outbytesleft);
			return ret;
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				nuint ret = IconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (nuint* poutbytesleft = &outbytesleft)
			{
				nuint ret = IconvNative(cd, inbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of successful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconvT cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						fixed (nuint* poutbytesleft = &outbytesleft)
						{
							nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* IconvStringNative([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, nuint, byte*>)funcTable[163])(tocode, fromcode, inbuf, inbytesleft);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint, nint>)funcTable[163])((nint)tocode, (nint)fromcode, (nint)inbuf, inbytesleft);
			#endif
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* ret = IconvStringNative(tocode, fromcode, inbuf, inbytesleft);
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, inbuf, inbytesleft));
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				byte* ret = IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				byte* ret = IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(pStr0, fromcode, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, fromcode, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				byte* ret = IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				byte* ret = IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(tocode, pStr0, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, pStr0, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(pStr0, pStr1, inbuf, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, pStr1, inbuf, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				byte* ret = IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = inbuf)
			{
				byte* ret = IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = inbuf)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(tocode, fromcode, pStr0, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, pStr0, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					byte* ret = IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(pStr0, fromcode, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, fromcode, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					byte* ret = IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(tocode, pStr0, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, pStr0, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] in byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] in byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] in byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
						return ret;
					}
				}
			}
		}
	}
}
