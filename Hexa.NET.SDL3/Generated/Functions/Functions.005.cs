// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Round `x` to the nearest integer representable as a long<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `MIN_LONG <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = MAX_LONG`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_lround for double-precision floats. To get the result as a<br/>
		/// floating-point type, use SDL_roundf.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_lroundf")]
		[return: NativeName(NativeNameType.Type, "long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int LroundfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int>)funcTable[151])(x);
			#else
			return (int)((delegate* unmanaged[Cdecl]<float, int>)funcTable[151])(x);
			#endif
		}

		/// <summary>
		/// Round `x` to the nearest integer representable as a long<br/>
		/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
		/// rounded away from zero.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `MIN_LONG <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = MAX_LONG`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_lround for double-precision floats. To get the result as a<br/>
		/// floating-point type, use SDL_roundf.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_lroundf")]
		[return: NativeName(NativeNameType.Type, "long")]
		public static int Lroundf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			int ret = LroundfNative(x);
			return ret;
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_scalbnf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbn")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ScalbnNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[152])(x, n);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[152])(x, n);
			#endif
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_scalbnf for single-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbn")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Scalbn([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			double ret = ScalbnNative(x, n);
			return ret;
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_scalbn for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbnf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ScalbnfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, int, float>)funcTable[153])(x, n);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, int, float>)funcTable[153])(x, n);
			#endif
		}

		/// <summary>
		/// Scale `x` by an integer power of two.<br/>
		/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`, `n` integer<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_scalbn for double-precision floats.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_scalbnf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Scalbnf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			float ret = ScalbnfNative(x, n);
			return ret;
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sinf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sin")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double SinNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[154])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[154])(x);
			#endif
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sinf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sin")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Sin([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SinNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sin for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float SinfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[155])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[155])(x);
			#endif
		}

		/// <summary>
		/// Compute the sine of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-1 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = 1`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sin for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Sinf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SinfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sqrtf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrt")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double SqrtNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[156])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[156])(x);
			#endif
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_sqrtf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrt")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Sqrt([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SqrtNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sqrt for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrtf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float SqrtfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[157])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[157])(x);
			#endif
		}

		/// <summary>
		/// Compute the square root of `x`.<br/>
		/// Domain: `0 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_sqrt for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_sqrtf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Sqrtf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SqrtfNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_tanf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tan")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TanNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, double>)funcTable[158])(x);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, double>)funcTable[158])(x);
			#endif
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on double-precision floating point values, use<br/>
		/// SDL_tanf for single-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tan")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double Tan([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = TanNative(x);
			return ret;
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_tan for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TanfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float>)funcTable[159])(x);
			#else
			return (float)((delegate* unmanaged[Cdecl]<float, float>)funcTable[159])(x);
			#endif
		}

		/// <summary>
		/// Compute the tangent of `x`.<br/>
		/// Domain: `-INF <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = INF`<br/>
		/// Range: `-INF <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = INF`<br/>
		/// This function operates on single-precision floating point values, use<br/>
		/// SDL_tan for double-precision floats.<br/>
		/// This function may use a different approximation across different versions,<br/>
		/// platforms and configurations. i.e, it can return a different value given<br/>
		/// the same input on different machines or operating systems, or if SDL is<br/>
		/// updated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_tanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float Tanf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = TanfNative(x);
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLIconv IconvOpenNative([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLIconv>)funcTable[160])(tocode, fromcode);
			#else
			return (SDLIconv)((delegate* unmanaged[Cdecl]<nint, nint, SDLIconv>)funcTable[160])((nint)tocode, (nint)fromcode);
			#endif
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			SDLIconv ret = IconvOpenNative(tocode, fromcode);
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				SDLIconv ret = IconvOpenNative((byte*)ptocode, fromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			fixed (byte* ptocode = tocode)
			{
				SDLIconv ret = IconvOpenNative((byte*)ptocode, fromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconv ret = IconvOpenNative(pStr0, fromcode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				SDLIconv ret = IconvOpenNative(tocode, (byte*)pfromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode)
		{
			fixed (byte* pfromcode = fromcode)
			{
				SDLIconv ret = IconvOpenNative(tocode, (byte*)pfromcode);
				return ret;
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconv ret = IconvOpenNative(tocode, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					SDLIconv ret = IconvOpenNative((byte*)ptocode, (byte*)pfromcode);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					SDLIconv ret = IconvOpenNative((byte*)ptocode, (byte*)pfromcode);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function allocates a context for the specified character set<br/>
		/// conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv IconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLIconv ret = IconvOpenNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// This function frees a context used for character set conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IconvCloseNative([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIconv, int>)funcTable[161])(cd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLIconv, int>)funcTable[161])(cd);
			#endif
		}

		/// <summary>
		/// This function frees a context used for character set conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IconvClose([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd)
		{
			int ret = IconvCloseNative(cd);
			return ret;
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint IconvNative([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIconv, byte**, nuint*, byte**, nuint*, nuint>)funcTable[162])(cd, inbuf, inbytesleft, outbuf, outbytesleft);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<SDLIconv, nint, nint, nint, nint, nuint>)funcTable[162])(cd, (nint)inbuf, (nint)inbytesleft, (nint)outbuf, (nint)outbytesleft);
			#endif
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			nuint ret = IconvNative(cd, inbuf, inbytesleft, outbuf, outbytesleft);
			return ret;
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				nuint ret = IconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (nuint* poutbytesleft = &outbytesleft)
			{
				nuint ret = IconvNative(cd, inbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = IconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = IconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// This function converts text between encodings, reading from and writing to<br/>
		/// a buffer.<br/>
		/// It returns the number of succesful conversions on success. On error,<br/>
		/// SDL_ICONV_E2BIG is returned when the output buffer is too small, or<br/>
		/// SDL_ICONV_EILSEQ is returned when an invalid input sequence is encountered,<br/>
		/// or SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
		/// encountered.<br/>
		/// On exit:<br/>
		/// - inbuf will point to the beginning of the next multibyte sequence. On<br/>
		/// error, this is the location of the problematic input sequence. On<br/>
		/// success, this is the end of the input sequence.<br/>
		/// - inbytesleft will be set to the number of bytes left to convert, which<br/>
		/// will be 0 on success.<br/>
		/// - outbuf will point to the location where to store the next output byte.<br/>
		/// - outbytesleft will be set to the number of bytes left in the output<br/>
		/// buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint Iconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const * *")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char * *")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t *")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						fixed (nuint* poutbytesleft = &outbytesleft)
						{
							nuint ret = IconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* IconvStringNative([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, nuint, byte*>)funcTable[163])(tocode, fromcode, inbuf, inbytesleft);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint, nint>)funcTable[163])((nint)tocode, (nint)fromcode, (nint)inbuf, inbytesleft);
			#endif
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* ret = IconvStringNative(tocode, fromcode, inbuf, inbytesleft);
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, inbuf, inbytesleft));
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				byte* ret = IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				byte* ret = IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(pStr0, fromcode, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, fromcode, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				byte* ret = IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				byte* ret = IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(tocode, pStr0, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, pStr0, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(pStr0, pStr1, inbuf, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, pStr1, inbuf, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				byte* ret = IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = inbuf)
			{
				byte* ret = IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = inbuf)
			{
				string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = IconvStringNative(tocode, fromcode, pStr0, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, fromcode, pStr0, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					byte* ret = IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(pStr0, fromcode, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, fromcode, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					byte* ret = IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = fromcode)
			{
				fixed (byte* pinbuf = inbuf)
				{
					string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = IconvStringNative(tocode, pStr0, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(tocode, pStr0, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					fixed (byte* pinbuf = inbuf)
					{
						byte* ret = IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = tocode)
			{
				fixed (byte* pfromcode = fromcode)
				{
					fixed (byte* pinbuf = inbuf)
					{
						string ret = Utils.DecodeStringUTF8(IconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* IconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = IconvStringNative(pStr0, pStr1, pStr2, inbytesleft);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Helper function to convert a string's encoding in one call.<br/>
		/// This function converts a buffer or string between encodings in one pass.<br/>
		/// The string does not need to be NULL-terminated; this function operates on<br/>
		/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
		/// character anywhere in the buffer.<br/>
		/// The returned string is owned by the caller, and should be passed to<br/>
		/// SDL_free when no longer needed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string IconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "char const *")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "char const *")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "char const *")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(IconvStringNative(pStr0, pStr1, pStr2, inbytesleft));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugbreakNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[164])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[164])();
			#endif
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Debugbreak()
		{
			DebugbreakNative();
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAssertionHandlerNative([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SDLAssertionHandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<SDLAssertData*, void*, SDLAssertState>, void*, void>)funcTable[165])((delegate*<SDLAssertData*, void*, SDLAssertState>)Utils.GetFunctionPointerForDelegate(handler), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[165])((nint)Utils.GetFunctionPointerForDelegate(handler), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAssertionHandler([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SDLAssertionHandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			SetAssertionHandlerNative(handler, userdata);
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<SDLAssertData*, void*, SDLAssertState> GetDefaultAssertionHandlerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<SDLAssertData*, void*, SDLAssertState>>)funcTable[166])();
			#else
			return (delegate*<SDLAssertData*, void*, SDLAssertState>)((delegate* unmanaged[Cdecl]<nint>)funcTable[166])();
			#endif
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetDefaultAssertionHandler()
		{
			delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetDefaultAssertionHandlerNative();
			return ret;
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandlerNative([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void * *")] void** puserdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void**, delegate*<SDLAssertData*, void*, SDLAssertState>>)funcTable[167])(puserdata);
			#else
			return (delegate*<SDLAssertData*, void*, SDLAssertState>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[167])((nint)puserdata);
			#endif
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static delegate*<SDLAssertData*, void*, SDLAssertState> GetAssertionHandler([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void * *")] void** puserdata)
		{
			delegate*<SDLAssertData*, void*, SDLAssertState> ret = GetAssertionHandlerNative(puserdata);
			return ret;
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe. Other threads calling<br/>
		/// SDL_ResetAssertionReport() simultaneously, may render the<br/>
		/// returned pointer invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertData const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAssertData* GetAssertionReportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAssertData*>)funcTable[168])();
			#else
			return (SDLAssertData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[168])();
			#endif
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe. Other threads calling<br/>
		/// SDL_ResetAssertionReport() simultaneously, may render the<br/>
		/// returned pointer invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertData const *")]
		public static SDLAssertData* GetAssertionReport()
		{
			SDLAssertData* ret = GetAssertionReportNative();
			return ret;
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// This function is not thread safe. Other threads triggering an<br/>
		/// assertion, or simultaneously calling this function may cause<br/>
		/// memory leaks or crashes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetAssertionReportNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[169])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[169])();
			#endif
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// This function is not thread safe. Other threads triggering an<br/>
		/// assertion, or simultaneously calling this function may cause<br/>
		/// memory leaks or crashes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetAssertionReport()
		{
			ResetAssertionReportNative();
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAsyncIO* AsyncIOFromFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLAsyncIO*>)funcTable[170])(file, mode);
			#else
			return (SDLAsyncIO*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[170])((nint)file, (nint)mode);
			#endif
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			SDLAsyncIO* ret = AsyncIOFromFileNative(file, mode);
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLAsyncIO* ret = AsyncIOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			fixed (byte* pfile = file)
			{
				SDLAsyncIO* ret = AsyncIOFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLAsyncIO* ret = AsyncIOFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLAsyncIO* ret = AsyncIOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				SDLAsyncIO* ret = AsyncIOFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLAsyncIO* ret = AsyncIOFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ref byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLAsyncIO* ret = AsyncIOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfile = file)
			{
				fixed (byte* pmode = mode)
				{
					SDLAsyncIO* ret = AsyncIOFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Use this function to create a new SDL_AsyncIO object for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string understands the following values:<br/>
		/// - "r": Open a file for reading only. It must exist.<br/>
		/// - "w": Open a file for writing only. It will create missing files or<br/>
		/// truncate existing ones.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// There is no "b" mode, as there is only "binary" style I/O, and no "a" mode<br/>
		/// for appending, since you specify the position when starting a task.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// This call is _not_ asynchronous; it will open the file before returning,<br/>
		/// under the assumption that doing so is generally a fast operation. Future<br/>
		/// reads and writes to the opened file will be async, however.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AsyncIOFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIO *")]
		public static SDLAsyncIO* AsyncIOFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "char const *")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLAsyncIO* ret = AsyncIOFromFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_AsyncIO.<br/>
		/// This call is _not_ asynchronous; it assumes that obtaining this info is a<br/>
		/// non-blocking operation in most reasonable cases.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long GetAsyncIOSizeNative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, long>)funcTable[171])(asyncio);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)funcTable[171])((nint)asyncio);
			#endif
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_AsyncIO.<br/>
		/// This call is _not_ asynchronous; it assumes that obtaining this info is a<br/>
		/// non-blocking operation in most reasonable cases.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetAsyncIOSize([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio)
		{
			long ret = GetAsyncIOSizeNative(asyncio);
			return ret;
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_AsyncIO.<br/>
		/// This call is _not_ asynchronous; it assumes that obtaining this info is a<br/>
		/// non-blocking operation in most reasonable cases.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOSize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long GetAsyncIOSize([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				long ret = GetAsyncIOSizeNative((SDLAsyncIO*)pasyncio);
				return ret;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReadAsyncIONative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, void*, ulong, ulong, SDLAsyncIOQueue*, void*, byte>)funcTable[172])(asyncio, ptr, offset, size, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ulong, ulong, nint, nint, byte>)funcTable[172])((nint)asyncio, (nint)ptr, offset, size, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = ReadAsyncIONative(asyncio, ptr, offset, size, queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = ReadAsyncIONative(asyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async read.<br/>
		/// This function reads up to `size` bytes from `offset` position in the data<br/>
		/// source to the area pointed at by `ptr`. This function may read less bytes<br/>
		/// than requested.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ReadAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = ReadAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WriteAsyncIONative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, void*, ulong, ulong, SDLAsyncIOQueue*, void*, byte>)funcTable[173])(asyncio, ptr, offset, size, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ulong, ulong, nint, nint, byte>)funcTable[173])((nint)asyncio, (nint)ptr, offset, size, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = WriteAsyncIONative(asyncio, ptr, offset, size, queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = WriteAsyncIONative(asyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start an async write.<br/>
		/// This function writes `size` bytes from `offset` position in the data source<br/>
		/// to the area pointed at by `ptr`.<br/>
		/// This function returns as quickly as possible; it does not wait for the<br/>
		/// write to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// `ptr` must remain available until the work is done, and may be accessed by<br/>
		/// the system at any time until then. Do not allocate it on the stack, as this<br/>
		/// might take longer than the life of the calling function to complete!<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WriteAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void *")] void* ptr, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint64")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint64")] ulong size, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = WriteAsyncIONative((SDLAsyncIO*)pasyncio, ptr, offset, size, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CloseAsyncIONative([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] byte flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIO*, byte, SDLAsyncIOQueue*, void*, byte>)funcTable[174])(asyncio, flush, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, nint, nint, byte>)funcTable[174])((nint)asyncio, flush, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = CloseAsyncIONative(asyncio, flush ? (byte)1 : (byte)0, queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				byte ret = CloseAsyncIONative((SDLAsyncIO*)pasyncio, flush ? (byte)1 : (byte)0, queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] SDLAsyncIO* asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = CloseAsyncIONative(asyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)pqueue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close and free any allocated resources for an async I/O object.<br/>
		/// Closing a file is _also_ an asynchronous task! If a write failure were to<br/>
		/// happen during the closing process, for example, the task results will<br/>
		/// report it as usual.<br/>
		/// Closing a file that has been written to does not guarantee the data has<br/>
		/// made it to physical media; it may remain in the operating system's file<br/>
		/// cache, for later writing to disk. This means that a successfully-closed<br/>
		/// file can be lost if the system crashes or loses power in this small window.<br/>
		/// To prevent this, call this function with the `flush` parameter set to true.<br/>
		/// This will make the operation take longer, and perhaps increase system load<br/>
		/// in general, but a successful result guarantees that the data has made it to<br/>
		/// physical storage. Don't use this for temporary files, caches, and<br/>
		/// unimportant data, and definitely use it for crucial irreplaceable files,<br/>
		/// like game saves.<br/>
		/// This function guarantees that the close will happen after any other pending<br/>
		/// tasks to `asyncio`, so it's safe to open a file, start several operations,<br/>
		/// close the file immediately, then check for all results later. This function<br/>
		/// will not block until the tasks have completed.<br/>
		/// Once this function returns true, `asyncio` is no longer valid, regardless<br/>
		/// of any future outcomes. Any completed tasks might still contain this<br/>
		/// pointer in their SDL_AsyncIOOutcome data, in case the app was using this<br/>
		/// value to track information, but it should not be used again.<br/>
		/// If this function returns false, the close wasn't started at all, and it's<br/>
		/// safe to attempt to close again later.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but two<br/>
		/// threads should not attempt to close the same object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAsyncIO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CloseAsyncIO([NativeName(NativeNameType.Param, "asyncio")] [NativeName(NativeNameType.Type, "SDL_AsyncIO *")] ref SDLAsyncIO asyncio, [NativeName(NativeNameType.Param, "flush")] [NativeName(NativeNameType.Type, "bool")] bool flush, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (SDLAsyncIO* pasyncio = &asyncio)
			{
				fixed (SDLAsyncIOQueue* pqueue = &queue)
				{
					byte ret = CloseAsyncIONative((SDLAsyncIO*)pasyncio, flush ? (byte)1 : (byte)0, (SDLAsyncIOQueue*)pqueue, userdata);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a task queue for tracking multiple I/O operations.<br/>
		/// Async I/O operations are assigned to a queue when started. The queue can be<br/>
		/// checked for completed tasks thereafter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLAsyncIOQueue* CreateAsyncIOQueueNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*>)funcTable[175])();
			#else
			return (SDLAsyncIOQueue*)((delegate* unmanaged[Cdecl]<nint>)funcTable[175])();
			#endif
		}

		/// <summary>
		/// Create a task queue for tracking multiple I/O operations.<br/>
		/// Async I/O operations are assigned to a queue when started. The queue can be<br/>
		/// checked for completed tasks thereafter.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")]
		public static SDLAsyncIOQueue* CreateAsyncIOQueue()
		{
			SDLAsyncIOQueue* ret = CreateAsyncIOQueueNative();
			return ret;
		}

		/// <summary>
		/// Destroy a previously-created async I/O task queue.<br/>
		/// If there are still tasks pending for this queue, this call will block until<br/>
		/// those tasks are finished. All those tasks will be deallocated. Their<br/>
		/// results will be lost to the app.<br/>
		/// Any pending reads from SDL_LoadFileAsync() that are still in this queue<br/>
		/// will have their buffers deallocated by this function, to prevent a memory<br/>
		/// leak.<br/>
		/// Once this function is called, the queue is no longer valid and should not<br/>
		/// be used, including by other threads that might access it while destruction<br/>
		/// is blocking on pending tasks.<br/>
		/// Do not destroy a queue that still has threads waiting on it through<br/>
		/// SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to<br/>
		/// unblock those threads, and take measures (such as SDL_WaitThread()) to make<br/>
		/// sure they have finished their wait and won't wait on the queue again.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, so long as<br/>
		/// no other thread is waiting on the queue with<br/>
		/// SDL_WaitAsyncIOResult.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyAsyncIOQueueNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, void>)funcTable[176])(queue);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[176])((nint)queue);
			#endif
		}

		/// <summary>
		/// Destroy a previously-created async I/O task queue.<br/>
		/// If there are still tasks pending for this queue, this call will block until<br/>
		/// those tasks are finished. All those tasks will be deallocated. Their<br/>
		/// results will be lost to the app.<br/>
		/// Any pending reads from SDL_LoadFileAsync() that are still in this queue<br/>
		/// will have their buffers deallocated by this function, to prevent a memory<br/>
		/// leak.<br/>
		/// Once this function is called, the queue is no longer valid and should not<br/>
		/// be used, including by other threads that might access it while destruction<br/>
		/// is blocking on pending tasks.<br/>
		/// Do not destroy a queue that still has threads waiting on it through<br/>
		/// SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to<br/>
		/// unblock those threads, and take measures (such as SDL_WaitThread()) to make<br/>
		/// sure they have finished their wait and won't wait on the queue again.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, so long as<br/>
		/// no other thread is waiting on the queue with<br/>
		/// SDL_WaitAsyncIOResult.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue)
		{
			DestroyAsyncIOQueueNative(queue);
		}

		/// <summary>
		/// Destroy a previously-created async I/O task queue.<br/>
		/// If there are still tasks pending for this queue, this call will block until<br/>
		/// those tasks are finished. All those tasks will be deallocated. Their<br/>
		/// results will be lost to the app.<br/>
		/// Any pending reads from SDL_LoadFileAsync() that are still in this queue<br/>
		/// will have their buffers deallocated by this function, to prevent a memory<br/>
		/// leak.<br/>
		/// Once this function is called, the queue is no longer valid and should not<br/>
		/// be used, including by other threads that might access it while destruction<br/>
		/// is blocking on pending tasks.<br/>
		/// Do not destroy a queue that still has threads waiting on it through<br/>
		/// SDL_WaitAsyncIOResult(). You can call SDL_SignalAsyncIOQueue() first to<br/>
		/// unblock those threads, and take measures (such as SDL_WaitThread()) to make<br/>
		/// sure they have finished their wait and won't wait on the queue again.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, so long as<br/>
		/// no other thread is waiting on the queue with<br/>
		/// SDL_WaitAsyncIOResult.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				DestroyAsyncIOQueueNative((SDLAsyncIOQueue*)pqueue);
			}
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetAsyncIOResultNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, SDLAsyncIOOutcome*, byte>)funcTable[177])(queue, outcome);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[177])((nint)queue, (nint)outcome);
			#endif
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome)
		{
			byte ret = GetAsyncIOResultNative(queue, outcome);
			return ret != 0;
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = GetAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, outcome);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome)
		{
			fixed (SDLAsyncIOOutcome* poutcome = &outcome)
			{
				byte ret = GetAsyncIOResultNative(queue, (SDLAsyncIOOutcome*)poutcome);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query an async I/O task queue for completed tasks.<br/>
		/// If a task assigned to this queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false. This function does not block.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				fixed (SDLAsyncIOOutcome* poutcome = &outcome)
				{
					byte ret = GetAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, (SDLAsyncIOOutcome*)poutcome);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitAsyncIOResultNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, SDLAsyncIOOutcome*, int, byte>)funcTable[178])(queue, outcome, timeoutMS);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[178])((nint)queue, (nint)outcome, timeoutMS);
			#endif
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			byte ret = WaitAsyncIOResultNative(queue, outcome, timeoutMS);
			return ret != 0;
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] SDLAsyncIOOutcome* outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				byte ret = WaitAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, outcome, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLAsyncIOOutcome* poutcome = &outcome)
			{
				byte ret = WaitAsyncIOResultNative(queue, (SDLAsyncIOOutcome*)poutcome, timeoutMS);
				return ret != 0;
			}
		}

		/// <summary>
		/// Block until an async I/O task queue has a completed task.<br/>
		/// This function puts the calling thread to sleep until there a task assigned<br/>
		/// to the queue that has finished.<br/>
		/// If a task assigned to the queue has finished, this will return true and<br/>
		/// fill in `outcome` with the details of the task. If no task in the queue has<br/>
		/// finished, this function will return false.<br/>
		/// If a task has completed, this function will free its resources and the task<br/>
		/// pointer will no longer be valid. The task will be removed from the queue.<br/>
		/// It is safe for multiple threads to call this function on the same queue at<br/>
		/// once; a completed task will only go to one of the threads.<br/>
		/// Note that by the nature of various platforms, more than one waiting thread<br/>
		/// may wake to handle a single task, but only one will obtain it, so<br/>
		/// `timeoutMS` is a _maximum_ wait time, and this function may return false<br/>
		/// sooner.<br/>
		/// This function may return false if there was a system error, the OS<br/>
		/// inadvertently awoke multiple threads, or if SDL_SignalAsyncIOQueue() was<br/>
		/// called to wake up all waiting threads without a finished task.<br/>
		/// A timeout can be used to specify a maximum wait time, but rather than<br/>
		/// polling, it is possible to have a timeout of -1 to wait forever, and use<br/>
		/// SDL_SignalAsyncIOQueue() to wake up the waiting threads later.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitAsyncIOResult")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WaitAsyncIOResult([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue, [NativeName(NativeNameType.Param, "outcome")] [NativeName(NativeNameType.Type, "SDL_AsyncIOOutcome *")] ref SDLAsyncIOOutcome outcome, [NativeName(NativeNameType.Param, "timeoutMS")] [NativeName(NativeNameType.Type, "Sint32")] int timeoutMS)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				fixed (SDLAsyncIOOutcome* poutcome = &outcome)
				{
					byte ret = WaitAsyncIOResultNative((SDLAsyncIOQueue*)pqueue, (SDLAsyncIOOutcome*)poutcome, timeoutMS);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Wake up any threads that are blocking in SDL_WaitAsyncIOResult().<br/>
		/// This will unblock any threads that are sleeping in a call to<br/>
		/// SDL_WaitAsyncIOResult for the specified queue, and cause them to return<br/>
		/// from that function.<br/>
		/// This can be useful when destroying a queue to make sure nothing is touching<br/>
		/// it indefinitely. In this case, once this call completes, the caller should<br/>
		/// take measures to make sure any previously-blocked threads have returned<br/>
		/// from their wait and will not touch the queue again (perhaps by setting a<br/>
		/// flag to tell the threads to terminate and then using SDL_WaitThread() to<br/>
		/// make sure they've done so).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalAsyncIOQueueNative([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLAsyncIOQueue*, void>)funcTable[179])(queue);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[179])((nint)queue);
			#endif
		}

		/// <summary>
		/// Wake up any threads that are blocking in SDL_WaitAsyncIOResult().<br/>
		/// This will unblock any threads that are sleeping in a call to<br/>
		/// SDL_WaitAsyncIOResult for the specified queue, and cause them to return<br/>
		/// from that function.<br/>
		/// This can be useful when destroying a queue to make sure nothing is touching<br/>
		/// it indefinitely. In this case, once this call completes, the caller should<br/>
		/// take measures to make sure any previously-blocked threads have returned<br/>
		/// from their wait and will not touch the queue again (perhaps by setting a<br/>
		/// flag to tell the threads to terminate and then using SDL_WaitThread() to<br/>
		/// make sure they've done so).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue)
		{
			SignalAsyncIOQueueNative(queue);
		}

		/// <summary>
		/// Wake up any threads that are blocking in SDL_WaitAsyncIOResult().<br/>
		/// This will unblock any threads that are sleeping in a call to<br/>
		/// SDL_WaitAsyncIOResult for the specified queue, and cause them to return<br/>
		/// from that function.<br/>
		/// This can be useful when destroying a queue to make sure nothing is touching<br/>
		/// it indefinitely. In this case, once this call completes, the caller should<br/>
		/// take measures to make sure any previously-blocked threads have returned<br/>
		/// from their wait and will not touch the queue again (perhaps by setting a<br/>
		/// flag to tell the threads to terminate and then using SDL_WaitThread() to<br/>
		/// make sure they've done so).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SignalAsyncIOQueue")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SignalAsyncIOQueue([NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] ref SDLAsyncIOQueue queue)
		{
			fixed (SDLAsyncIOQueue* pqueue = &queue)
			{
				SignalAsyncIOQueueNative((SDLAsyncIOQueue*)pqueue);
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte LoadFileAsyncNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLAsyncIOQueue*, void*, byte>)funcTable[180])(file, queue, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[180])((nint)file, (nint)queue, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = LoadFileAsyncNative(file, queue, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = LoadFileAsyncNative((byte*)pfile, queue, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load all the data from a file path, asynchronously.<br/>
		/// This function returns as quickly as possible; it does not wait for the read<br/>
		/// to complete. On a successful return, this work will continue in the<br/>
		/// background. If the work begins, even failure is asynchronous: a failing<br/>
		/// return value from this function only means the work couldn't start at all.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in SDL_AsyncIOOutcome's<br/>
		/// bytes_transferred value.<br/>
		/// This function will allocate the buffer to contain the file. It must be<br/>
		/// deallocated by calling SDL_free() on SDL_AsyncIOOutcome's buffer field<br/>
		/// after completion.<br/>
		/// An SDL_AsyncIOQueue must be specified. The newly-created task will be added<br/>
		/// to it when it completes its work.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFileAsync")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool LoadFileAsync([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "queue")] [NativeName(NativeNameType.Type, "SDL_AsyncIOQueue *")] SDLAsyncIOQueue* queue, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pfile = file)
			{
				byte ret = LoadFileAsyncNative((byte*)pfile, queue, userdata);
				return ret != 0;
			}
		}
	}
}
