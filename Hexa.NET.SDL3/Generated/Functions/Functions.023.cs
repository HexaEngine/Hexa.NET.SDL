// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Wait for a process to finish.<br/>
		/// This can be called multiple times to get the status of a process.<br/>
		/// The exit code will be the exit code of the process if it terminates<br/>
		/// normally, a negative signal if it terminated due to a signal, or -255<br/>
		/// otherwise. It will not be changed if the process is still running.<br/>
		/// If you create a process with standard output piped to the application<br/>
		/// (`pipe_stdio` being true) then you should read all of the process output<br/>
		/// before calling SDL_WaitProcess(). If you don't do this the process might be<br/>
		/// blocked indefinitely waiting for output to be read and SDL_WaitProcess()<br/>
		/// will never return true;<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitProcess(SDLProcess* process, bool block, ref int exitcode)
		{
			fixed (int* pexitcode = &exitcode)
			{
				byte ret = WaitProcessNative(process, block ? (byte)1 : (byte)0, (int*)pexitcode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Wait for a process to finish.<br/>
		/// This can be called multiple times to get the status of a process.<br/>
		/// The exit code will be the exit code of the process if it terminates<br/>
		/// normally, a negative signal if it terminated due to a signal, or -255<br/>
		/// otherwise. It will not be changed if the process is still running.<br/>
		/// If you create a process with standard output piped to the application<br/>
		/// (`pipe_stdio` being true) then you should read all of the process output<br/>
		/// before calling SDL_WaitProcess(). If you don't do this the process might be<br/>
		/// blocked indefinitely waiting for output to be read and SDL_WaitProcess()<br/>
		/// will never return true;<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitProcess(ref SDLProcess process, bool block, ref int exitcode)
		{
			fixed (SDLProcess* pprocess = &process)
			{
				fixed (int* pexitcode = &exitcode)
				{
					byte ret = WaitProcessNative((SDLProcess*)pprocess, block ? (byte)1 : (byte)0, (int*)pexitcode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Destroy a previously created process object.<br/>
		/// Note that this does not stop the process, just destroys the SDL object used<br/>
		/// to track it. If you want to stop the process you should use<br/>
		/// SDL_KillProcess().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyProcessNative(SDLProcess* process)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLProcess*, void>)funcTable[1031])(process);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1031])((nint)process);
			#endif
		}

		/// <summary>
		/// Destroy a previously created process object.<br/>
		/// Note that this does not stop the process, just destroys the SDL object used<br/>
		/// to track it. If you want to stop the process you should use<br/>
		/// SDL_KillProcess().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyProcess(SDLProcess* process)
		{
			DestroyProcessNative(process);
		}

		/// <summary>
		/// Destroy a previously created process object.<br/>
		/// Note that this does not stop the process, just destroys the SDL object used<br/>
		/// to track it. If you want to stop the process you should use<br/>
		/// SDL_KillProcess().<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DestroyProcess(ref SDLProcess process)
		{
			fixed (SDLProcess* pprocess = &process)
			{
				DestroyProcessNative((SDLProcess*)pprocess);
			}
		}

		/// <summary>
		/// Get the number of 2D rendering drivers available for the current display.<br/>
		/// A render driver is a set of code that handles rendering and texture<br/>
		/// management on a particular display. Normally there is only one, but some<br/>
		/// drivers may have several available with different capabilities.<br/>
		/// There may be none if SDL was compiled without render support.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumRenderDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1032])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1032])();
			#endif
		}

		/// <summary>
		/// Get the number of 2D rendering drivers available for the current display.<br/>
		/// A render driver is a set of code that handles rendering and texture<br/>
		/// management on a particular display. Normally there is only one, but some<br/>
		/// drivers may have several available with different capabilities.<br/>
		/// There may be none if SDL was compiled without render support.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumRenderDrivers()
		{
			int ret = GetNumRenderDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in 2D rendering driver.<br/>
		/// The list of rendering drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "opengl",<br/>
		/// "direct3d12" or "metal". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetRenderDriverNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[1033])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[1033])(index);
			#endif
		}

		/// <summary>
		/// Use this function to get the name of a built in 2D rendering driver.<br/>
		/// The list of rendering drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "opengl",<br/>
		/// "direct3d12" or "metal". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetRenderDriver(int index)
		{
			byte* ret = GetRenderDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in 2D rendering driver.<br/>
		/// The list of rendering drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "opengl",<br/>
		/// "direct3d12" or "metal". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetRenderDriverS(int index)
		{
			string ret = Utils.DecodeStringUTF8(GetRenderDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CreateWindowAndRendererNative(byte* title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int, SDLWindowFlags, SDLWindow**, SDLRenderer**, byte>)funcTable[1034])(title, width, height, windowFlags, window, renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, SDLWindowFlags, nint, nint, byte>)funcTable[1034])((nint)title, width, height, windowFlags, (nint)window, (nint)renderer);
			#endif
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(byte* title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			byte ret = CreateWindowAndRendererNative(title, width, height, windowFlags, window, renderer);
			return ret != 0;
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ref byte title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			fixed (byte* ptitle = &title)
			{
				byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, window, renderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ReadOnlySpan<byte> title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			fixed (byte* ptitle = title)
			{
				byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, window, renderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(string title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, SDLRenderer** renderer)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CreateWindowAndRendererNative(pStr0, width, height, windowFlags, window, renderer);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(byte* title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, SDLRenderer** renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				byte ret = CreateWindowAndRendererNative(title, width, height, windowFlags, (SDLWindow**)pwindow, renderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ref byte title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, SDLRenderer** renderer)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (SDLWindow** pwindow = &window)
				{
					byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, (SDLWindow**)pwindow, renderer);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ReadOnlySpan<byte> title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, SDLRenderer** renderer)
		{
			fixed (byte* ptitle = title)
			{
				fixed (SDLWindow** pwindow = &window)
				{
					byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, (SDLWindow**)pwindow, renderer);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(string title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, SDLRenderer** renderer)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow** pwindow = &window)
			{
				byte ret = CreateWindowAndRendererNative(pStr0, width, height, windowFlags, (SDLWindow**)pwindow, renderer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(byte* title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, ref SDLRenderer* renderer)
		{
			fixed (SDLRenderer** prenderer = &renderer)
			{
				byte ret = CreateWindowAndRendererNative(title, width, height, windowFlags, window, (SDLRenderer**)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ref byte title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, ref SDLRenderer* renderer)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (SDLRenderer** prenderer = &renderer)
				{
					byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, window, (SDLRenderer**)prenderer);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ReadOnlySpan<byte> title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, ref SDLRenderer* renderer)
		{
			fixed (byte* ptitle = title)
			{
				fixed (SDLRenderer** prenderer = &renderer)
				{
					byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, window, (SDLRenderer**)prenderer);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(string title, int width, int height, SDLWindowFlags windowFlags, SDLWindow** window, ref SDLRenderer* renderer)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLRenderer** prenderer = &renderer)
			{
				byte ret = CreateWindowAndRendererNative(pStr0, width, height, windowFlags, window, (SDLRenderer**)prenderer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(byte* title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, ref SDLRenderer* renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				fixed (SDLRenderer** prenderer = &renderer)
				{
					byte ret = CreateWindowAndRendererNative(title, width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)prenderer);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ref byte title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, ref SDLRenderer* renderer)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (SDLWindow** pwindow = &window)
				{
					fixed (SDLRenderer** prenderer = &renderer)
					{
						byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)prenderer);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(ReadOnlySpan<byte> title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, ref SDLRenderer* renderer)
		{
			fixed (byte* ptitle = title)
			{
				fixed (SDLWindow** pwindow = &window)
				{
					fixed (SDLRenderer** prenderer = &renderer)
					{
						byte ret = CreateWindowAndRendererNative((byte*)ptitle, width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)prenderer);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CreateWindowAndRenderer(string title, int width, int height, SDLWindowFlags windowFlags, ref SDLWindow* window, ref SDLRenderer* renderer)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow** pwindow = &window)
			{
				fixed (SDLRenderer** prenderer = &renderer)
				{
					byte ret = CreateWindowAndRendererNative(pStr0, width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)prenderer);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* CreateRendererNative(SDLWindow* window, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte*, SDLRenderer*>)funcTable[1035])(window, name);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[1035])((nint)window, (nint)name);
			#endif
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(SDLWindow* window, byte* name)
		{
			SDLRenderer* ret = CreateRendererNative(window, name);
			return ret;
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(ref SDLWindow window, byte* name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRenderer* ret = CreateRendererNative((SDLWindow*)pwindow, name);
				return ret;
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(SDLWindow* window, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLRenderer* ret = CreateRendererNative(window, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(SDLWindow* window, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLRenderer* ret = CreateRendererNative(window, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(SDLWindow* window, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRenderer* ret = CreateRendererNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(ref SDLWindow window, ref byte name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					SDLRenderer* ret = CreateRendererNative((SDLWindow*)pwindow, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(ref SDLWindow window, ReadOnlySpan<byte> name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = name)
				{
					SDLRenderer* ret = CreateRendererNative((SDLWindow*)pwindow, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// If you want a specific renderer, you can specify its name here. A list of<br/>
		/// available renderers can be obtained by calling SDL_GetRenderDriver()<br/>
		/// multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you<br/>
		/// don't need a specific renderer, specify NULL and SDL will attempt to choose<br/>
		/// the best option for you, based on what is available on the user's system.<br/>
		/// If `name` is a comma-separated list, SDL will try each name, in the order<br/>
		/// listed, until one succeeds or all of them fail.<br/>
		/// By default the rendering size matches the window size in pixels, but you<br/>
		/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
		/// scaling options.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRenderer(ref SDLWindow window, string name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLRenderer* ret = CreateRendererNative((SDLWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window, with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver<br/>
		/// to use, if a specific one is desired<br/>
		/// - `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is<br/>
		/// displayed, required if this isn't a software renderer using a surface<br/>
		/// - `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering<br/>
		/// is displayed, if you want a software renderer without a window<br/>
		/// - `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace<br/>
		/// value describing the colorspace for output to the display, defaults to<br/>
		/// SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers<br/>
		/// support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and<br/>
		/// supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing<br/>
		/// still uses the sRGB colorspace, but values can go beyond 1.0 and float<br/>
		/// (linear) format textures can be used for HDR content.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want<br/>
		/// present synchronized with the refresh rate. This property can take any<br/>
		/// value that is supported by SDL_SetRenderVSync() for the renderer.<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use<br/>
		/// with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use<br/>
		/// with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the<br/>
		/// VkPhysicalDevice to use with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use<br/>
		/// with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the<br/>
		/// queue family index used for rendering.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the<br/>
		/// queue family index used for presentation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* CreateRendererWithPropertiesNative(uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLRenderer*>)funcTable[1036])(props);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[1036])(props);
			#endif
		}

		/// <summary>
		/// Create a 2D rendering context for a window, with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver<br/>
		/// to use, if a specific one is desired<br/>
		/// - `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is<br/>
		/// displayed, required if this isn't a software renderer using a surface<br/>
		/// - `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering<br/>
		/// is displayed, if you want a software renderer without a window<br/>
		/// - `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace<br/>
		/// value describing the colorspace for output to the display, defaults to<br/>
		/// SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers<br/>
		/// support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and<br/>
		/// supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing<br/>
		/// still uses the sRGB colorspace, but values can go beyond 1.0 and float<br/>
		/// (linear) format textures can be used for HDR content.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want<br/>
		/// present synchronized with the refresh rate. This property can take any<br/>
		/// value that is supported by SDL_SetRenderVSync() for the renderer.<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use<br/>
		/// with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use<br/>
		/// with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the<br/>
		/// VkPhysicalDevice to use with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use<br/>
		/// with the renderer, optional.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the<br/>
		/// queue family index used for rendering.<br/>
		/// - `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the<br/>
		/// queue family index used for presentation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateRendererWithProperties(uint props)
		{
			SDLRenderer* ret = CreateRendererWithPropertiesNative(props);
			return ret;
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* CreateSoftwareRendererNative(SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRenderer*>)funcTable[1037])(surface);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1037])((nint)surface);
			#endif
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateSoftwareRenderer(SDLSurface* surface)
		{
			SDLRenderer* ret = CreateSoftwareRendererNative(surface);
			return ret;
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* CreateSoftwareRenderer(ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLRenderer* ret = CreateSoftwareRendererNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* GetRendererNative(SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, SDLRenderer*>)funcTable[1038])(window);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1038])((nint)window);
			#endif
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* GetRenderer(SDLWindow* window)
		{
			SDLRenderer* ret = GetRendererNative(window);
			return ret;
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* GetRenderer(ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRenderer* ret = GetRendererNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetRenderWindowNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLWindow*>)funcTable[1039])(renderer);
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1039])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GetRenderWindow(SDLRenderer* renderer)
		{
			SDLWindow* ret = GetRenderWindowNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLWindow* GetRenderWindow(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLWindow* ret = GetRenderWindowNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the name of a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetRendererNameNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte*>)funcTable[1040])(renderer);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1040])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the name of a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetRendererName(SDLRenderer* renderer)
		{
			byte* ret = GetRendererNameNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the name of a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetRendererNameS(SDLRenderer* renderer)
		{
			string ret = Utils.DecodeStringUTF8(GetRendererNameNative(renderer));
			return ret;
		}

		/// <summary>
		/// Get the name of a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetRendererName(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* ret = GetRendererNameNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the name of a renderer.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetRendererNameS(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				string ret = Utils.DecodeStringUTF8(GetRendererNameNative((SDLRenderer*)prenderer));
				return ret;
			}
		}

		/// <summary>
		/// Get the properties associated with a renderer.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver<br/>
		/// - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is<br/>
		/// displayed, if any<br/>
		/// - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is<br/>
		/// displayed, if this is a software renderer without a window<br/>
		/// - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting<br/>
		/// - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width<br/>
		/// and height<br/>
		/// - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat *)<br/>
		/// array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,<br/>
		/// representing the available texture formats for this renderer.<br/>
		/// - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace value<br/>
		/// describing the colorspace for output to the display, defaults to<br/>
		/// SDL_COLORSPACE_SRGB.<br/>
		/// - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is<br/>
		/// SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with<br/>
		/// HDR enabled. This property can change dynamically when<br/>
		/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the<br/>
		/// SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is<br/>
		/// automatically multiplied into the color scale. This property can change<br/>
		/// dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range<br/>
		/// that can be displayed, in terms of the SDR white point. When HDR is not<br/>
		/// enabled, this will be 1.0. This property can change dynamically when<br/>
		/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// With the direct3d renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated<br/>
		/// with the renderer<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1<br/>
		/// associated with the renderer. This may change when the window is resized.<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4<br/>
		/// associated with the renderer.<br/>
		/// - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue<br/>
		/// associated with the renderer<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice<br/>
		/// associated with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with<br/>
		/// the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
		/// family index used for rendering<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
		/// family index used for presentation<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of<br/>
		/// swapchain images, or potential frames in flight, used by the Vulkan<br/>
		/// renderer<br/>
		/// With the gpu renderer:<br/>
		/// - `SDL_PROP_RENDERER_GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with<br/>
		/// the renderer<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetRendererPropertiesNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, uint>)funcTable[1041])(renderer);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[1041])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a renderer.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver<br/>
		/// - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is<br/>
		/// displayed, if any<br/>
		/// - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is<br/>
		/// displayed, if this is a software renderer without a window<br/>
		/// - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting<br/>
		/// - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width<br/>
		/// and height<br/>
		/// - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat *)<br/>
		/// array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,<br/>
		/// representing the available texture formats for this renderer.<br/>
		/// - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace value<br/>
		/// describing the colorspace for output to the display, defaults to<br/>
		/// SDL_COLORSPACE_SRGB.<br/>
		/// - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is<br/>
		/// SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with<br/>
		/// HDR enabled. This property can change dynamically when<br/>
		/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the<br/>
		/// SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is<br/>
		/// automatically multiplied into the color scale. This property can change<br/>
		/// dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range<br/>
		/// that can be displayed, in terms of the SDR white point. When HDR is not<br/>
		/// enabled, this will be 1.0. This property can change dynamically when<br/>
		/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// With the direct3d renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated<br/>
		/// with the renderer<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1<br/>
		/// associated with the renderer. This may change when the window is resized.<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4<br/>
		/// associated with the renderer.<br/>
		/// - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue<br/>
		/// associated with the renderer<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice<br/>
		/// associated with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with<br/>
		/// the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
		/// family index used for rendering<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
		/// family index used for presentation<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of<br/>
		/// swapchain images, or potential frames in flight, used by the Vulkan<br/>
		/// renderer<br/>
		/// With the gpu renderer:<br/>
		/// - `SDL_PROP_RENDERER_GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with<br/>
		/// the renderer<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static uint GetRendererProperties(SDLRenderer* renderer)
		{
			uint ret = GetRendererPropertiesNative(renderer);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a renderer.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver<br/>
		/// - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is<br/>
		/// displayed, if any<br/>
		/// - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is<br/>
		/// displayed, if this is a software renderer without a window<br/>
		/// - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting<br/>
		/// - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width<br/>
		/// and height<br/>
		/// - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat *)<br/>
		/// array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,<br/>
		/// representing the available texture formats for this renderer.<br/>
		/// - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace value<br/>
		/// describing the colorspace for output to the display, defaults to<br/>
		/// SDL_COLORSPACE_SRGB.<br/>
		/// - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is<br/>
		/// SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with<br/>
		/// HDR enabled. This property can change dynamically when<br/>
		/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the<br/>
		/// SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is<br/>
		/// automatically multiplied into the color scale. This property can change<br/>
		/// dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range<br/>
		/// that can be displayed, in terms of the SDR white point. When HDR is not<br/>
		/// enabled, this will be 1.0. This property can change dynamically when<br/>
		/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
		/// With the direct3d renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated<br/>
		/// with the renderer<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1<br/>
		/// associated with the renderer. This may change when the window is resized.<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4<br/>
		/// associated with the renderer.<br/>
		/// - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue<br/>
		/// associated with the renderer<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated<br/>
		/// with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice<br/>
		/// associated with the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with<br/>
		/// the renderer<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
		/// family index used for rendering<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
		/// family index used for presentation<br/>
		/// - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of<br/>
		/// swapchain images, or potential frames in flight, used by the Vulkan<br/>
		/// renderer<br/>
		/// With the gpu renderer:<br/>
		/// - `SDL_PROP_RENDERER_GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with<br/>
		/// the renderer<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static uint GetRendererProperties(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				uint ret = GetRendererPropertiesNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderOutputSizeNative(SDLRenderer* renderer, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int*, int*, byte>)funcTable[1042])(renderer, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[1042])((nint)renderer, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(SDLRenderer* renderer, int* w, int* h)
		{
			byte ret = GetRenderOutputSizeNative(renderer, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(ref SDLRenderer renderer, int* w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderOutputSizeNative((SDLRenderer*)prenderer, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(SDLRenderer* renderer, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetRenderOutputSizeNative(renderer, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(ref SDLRenderer renderer, ref int w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetRenderOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(SDLRenderer* renderer, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetRenderOutputSizeNative(renderer, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(ref SDLRenderer renderer, int* w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetRenderOutputSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(SDLRenderer* renderer, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetRenderOutputSizeNative(renderer, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// This returns the true output size in pixels, ignoring any render targets or<br/>
		/// logical size and presentation.<br/>
		/// For the output size of the current rendering target, with logical size<br/>
		/// adjustments, use SDL_GetCurrentRenderOutputSize() instead.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderOutputSize(ref SDLRenderer renderer, ref int w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetRenderOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetCurrentRenderOutputSizeNative(SDLRenderer* renderer, int* w, int* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, int*, int*, byte>)funcTable[1043])(renderer, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[1043])((nint)renderer, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(SDLRenderer* renderer, int* w, int* h)
		{
			byte ret = GetCurrentRenderOutputSizeNative(renderer, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(ref SDLRenderer renderer, int* w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetCurrentRenderOutputSizeNative((SDLRenderer*)prenderer, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(SDLRenderer* renderer, ref int w, int* h)
		{
			fixed (int* pw = &w)
			{
				byte ret = GetCurrentRenderOutputSizeNative(renderer, (int*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(ref SDLRenderer renderer, ref int w, int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					byte ret = GetCurrentRenderOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(SDLRenderer* renderer, int* w, ref int h)
		{
			fixed (int* ph = &h)
			{
				byte ret = GetCurrentRenderOutputSizeNative(renderer, w, (int*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(ref SDLRenderer renderer, int* w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetCurrentRenderOutputSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(SDLRenderer* renderer, ref int w, ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					byte ret = GetCurrentRenderOutputSizeNative(renderer, (int*)pw, (int*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current output size in pixels of a rendering context.<br/>
		/// If a rendering target is active, this will return the size of the rendering<br/>
		/// target in pixels, otherwise return the value of SDL_GetRenderOutputSize().<br/>
		/// Rendering target or not, the output will be adjusted by the current logical<br/>
		/// presentation state, dictated by SDL_SetRenderLogicalPresentation().<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetCurrentRenderOutputSize(ref SDLRenderer renderer, ref int w, ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						byte ret = GetCurrentRenderOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// The contents of a texture when first created are not defined.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* CreateTextureNative(SDLRenderer* renderer, SDLPixelFormat format, SDLTextureAccess access, int w, int h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLPixelFormat, SDLTextureAccess, int, int, SDLTexture*>)funcTable[1044])(renderer, format, access, w, h);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, SDLPixelFormat, SDLTextureAccess, int, int, nint>)funcTable[1044])((nint)renderer, format, access, w, h);
			#endif
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// The contents of a texture when first created are not defined.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTexture(SDLRenderer* renderer, SDLPixelFormat format, SDLTextureAccess access, int w, int h)
		{
			SDLTexture* ret = CreateTextureNative(renderer, format, access, w, h);
			return ret;
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// The contents of a texture when first created are not defined.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTexture(ref SDLRenderer renderer, SDLPixelFormat format, SDLTextureAccess access, int w, int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = CreateTextureNative((SDLRenderer*)prenderer, format, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface, and can be queried using the<br/>
		/// SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* CreateTextureFromSurfaceNative(SDLRenderer* renderer, SDLSurface* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLSurface*, SDLTexture*>)funcTable[1045])(renderer, surface);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[1045])((nint)renderer, (nint)surface);
			#endif
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface, and can be queried using the<br/>
		/// SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(SDLRenderer* renderer, SDLSurface* surface)
		{
			SDLTexture* ret = CreateTextureFromSurfaceNative(renderer, surface);
			return ret;
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface, and can be queried using the<br/>
		/// SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(ref SDLRenderer renderer, SDLSurface* surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, surface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface, and can be queried using the<br/>
		/// SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(SDLRenderer* renderer, ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLTexture* ret = CreateTextureFromSurfaceNative(renderer, (SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface, and can be queried using the<br/>
		/// SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureFromSurface(ref SDLRenderer renderer, ref SDLSurface surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLSurface* psurface = &surface)
				{
					SDLTexture* ret = CreateTextureFromSurfaceNative((SDLRenderer*)prenderer, (SDLSurface*)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a texture for a rendering context with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_Colorspace value<br/>
		/// describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR<br/>
		/// for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,<br/>
		/// SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for<br/>
		/// YUV textures.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in<br/>
		/// SDL_PixelFormat, defaults to the best RGBA format for the renderer<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in<br/>
		/// SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in<br/>
		/// pixels, required<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in<br/>
		/// pixels, required<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating<br/>
		/// point textures, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 100 for HDR10 textures and 1.0 for floating point textures.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating<br/>
		/// point textures, this defines the maximum dynamic range used by the<br/>
		/// content, in terms of the SDR white point. This would be equivalent to<br/>
		/// maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.<br/>
		/// If this is defined, any values outside the range supported by the display<br/>
		/// will be scaled into the available HDR headroom, otherwise they are<br/>
		/// clipped.<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the metal renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef<br/>
		/// associated with the texture, if you want to create a texture from an<br/>
		/// existing pixel buffer.<br/>
		/// With the opengl renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the opengles2 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout<br/>
		/// VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if<br/>
		/// you want to wrap an existing texture.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* CreateTextureWithPropertiesNative(SDLRenderer* renderer, uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, uint, SDLTexture*>)funcTable[1046])(renderer, props);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[1046])((nint)renderer, props);
			#endif
		}

		/// <summary>
		/// Create a texture for a rendering context with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_Colorspace value<br/>
		/// describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR<br/>
		/// for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,<br/>
		/// SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for<br/>
		/// YUV textures.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in<br/>
		/// SDL_PixelFormat, defaults to the best RGBA format for the renderer<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in<br/>
		/// SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in<br/>
		/// pixels, required<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in<br/>
		/// pixels, required<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating<br/>
		/// point textures, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 100 for HDR10 textures and 1.0 for floating point textures.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating<br/>
		/// point textures, this defines the maximum dynamic range used by the<br/>
		/// content, in terms of the SDR white point. This would be equivalent to<br/>
		/// maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.<br/>
		/// If this is defined, any values outside the range supported by the display<br/>
		/// will be scaled into the available HDR headroom, otherwise they are<br/>
		/// clipped.<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the metal renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef<br/>
		/// associated with the texture, if you want to create a texture from an<br/>
		/// existing pixel buffer.<br/>
		/// With the opengl renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the opengles2 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout<br/>
		/// VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if<br/>
		/// you want to wrap an existing texture.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureWithProperties(SDLRenderer* renderer, uint props)
		{
			SDLTexture* ret = CreateTextureWithPropertiesNative(renderer, props);
			return ret;
		}

		/// <summary>
		/// Create a texture for a rendering context with the specified properties.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_Colorspace value<br/>
		/// describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR<br/>
		/// for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,<br/>
		/// SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for<br/>
		/// YUV textures.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in<br/>
		/// SDL_PixelFormat, defaults to the best RGBA format for the renderer<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in<br/>
		/// SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in<br/>
		/// pixels, required<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in<br/>
		/// pixels, required<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating<br/>
		/// point textures, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 100 for HDR10 textures and 1.0 for floating point textures.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating<br/>
		/// point textures, this defines the maximum dynamic range used by the<br/>
		/// content, in terms of the SDR white point. This would be equivalent to<br/>
		/// maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.<br/>
		/// If this is defined, any values outside the range supported by the display<br/>
		/// will be scaled into the available HDR headroom, otherwise they are<br/>
		/// clipped.<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the metal renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef<br/>
		/// associated with the texture, if you want to create a texture from an<br/>
		/// existing pixel buffer.<br/>
		/// With the opengl renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the opengles2 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture, if you want to wrap an existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
		/// existing texture.<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout<br/>
		/// VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if<br/>
		/// you want to wrap an existing texture.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLTexture* CreateTextureWithProperties(ref SDLRenderer renderer, uint props)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = CreateTextureWithPropertiesNative((SDLRenderer*)prenderer, props);
				return ret;
			}
		}

		/// <summary>
		/// Get the properties associated with a texture.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_Colorspace value describing<br/>
		/// the texture colorspace.<br/>
		/// - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in<br/>
		/// SDL_PixelFormat.<br/>
		/// - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in<br/>
		/// SDL_TextureAccess.<br/>
		/// - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.<br/>
		/// - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.<br/>
		/// - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// textures, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 100 for HDR10 textures and 1.0 for other textures.<br/>
		/// - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// textures, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. If this is defined, any values outside the<br/>
		/// range supported by the display will be scaled into the available HDR<br/>
		/// headroom, otherwise they are clipped. This defaults to 1.0 for SDR<br/>
		/// textures, 4.0 for HDR10 textures, and no default for floating point<br/>
		/// textures.<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the V plane of a YUV texture<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated<br/>
		/// with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated<br/>
		/// with the V plane of a YUV texture<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the<br/>
		/// texture<br/>
		/// With the opengl renderer:<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated<br/>
		/// with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated<br/>
		/// with the V plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
		/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of<br/>
		/// the texture (0.0 - 1.0)<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of<br/>
		/// the texture (0.0 - 1.0)<br/>
		/// With the opengles2 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
		/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetTexturePropertiesNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, uint>)funcTable[1047])(texture);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[1047])((nint)texture);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a texture.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_Colorspace value describing<br/>
		/// the texture colorspace.<br/>
		/// - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in<br/>
		/// SDL_PixelFormat.<br/>
		/// - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in<br/>
		/// SDL_TextureAccess.<br/>
		/// - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.<br/>
		/// - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.<br/>
		/// - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// textures, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 100 for HDR10 textures and 1.0 for other textures.<br/>
		/// - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// textures, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. If this is defined, any values outside the<br/>
		/// range supported by the display will be scaled into the available HDR<br/>
		/// headroom, otherwise they are clipped. This defaults to 1.0 for SDR<br/>
		/// textures, 4.0 for HDR10 textures, and no default for floating point<br/>
		/// textures.<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the V plane of a YUV texture<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated<br/>
		/// with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated<br/>
		/// with the V plane of a YUV texture<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the<br/>
		/// texture<br/>
		/// With the opengl renderer:<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated<br/>
		/// with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated<br/>
		/// with the V plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
		/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of<br/>
		/// the texture (0.0 - 1.0)<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of<br/>
		/// the texture (0.0 - 1.0)<br/>
		/// With the opengles2 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
		/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static uint GetTextureProperties(SDLTexture* texture)
		{
			uint ret = GetTexturePropertiesNative(texture);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a texture.<br/>
		/// The following read-only properties are provided by SDL:<br/>
		/// - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_Colorspace value describing<br/>
		/// the texture colorspace.<br/>
		/// - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in<br/>
		/// SDL_PixelFormat.<br/>
		/// - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in<br/>
		/// SDL_TextureAccess.<br/>
		/// - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.<br/>
		/// - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.<br/>
		/// - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
		/// textures, this defines the value of 100% diffuse white, with higher<br/>
		/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
		/// to 100 for HDR10 textures and 1.0 for other textures.<br/>
		/// - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
		/// textures, this defines the maximum dynamic range used by the content, in<br/>
		/// terms of the SDR white point. If this is defined, any values outside the<br/>
		/// range supported by the display will be scaled into the available HDR<br/>
		/// headroom, otherwise they are clipped. This defaults to 1.0 for SDR<br/>
		/// textures, 4.0 for HDR10 textures, and no default for floating point<br/>
		/// textures.<br/>
		/// With the direct3d11 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
		/// associated with the V plane of a YUV texture<br/>
		/// With the direct3d12 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated<br/>
		/// with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated<br/>
		/// with the V plane of a YUV texture<br/>
		/// With the vulkan renderer:<br/>
		/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the<br/>
		/// texture<br/>
		/// With the opengl renderer:<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated<br/>
		/// with the texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated<br/>
		/// with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated<br/>
		/// with the V plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
		/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of<br/>
		/// the texture (0.0 - 1.0)<br/>
		/// - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of<br/>
		/// the texture (0.0 - 1.0)<br/>
		/// With the opengles2 renderer:<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
		/// associated with the texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
		/// associated with the UV plane of an NV12 texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
		/// associated with the U plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
		/// associated with the V plane of a YUV texture<br/>
		/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
		/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static uint GetTextureProperties(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				uint ret = GetTexturePropertiesNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Get the renderer that created an SDL_Texture.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLRenderer* GetRendererFromTextureNative(SDLTexture* texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRenderer*>)funcTable[1048])(texture);
			#else
			return (SDLRenderer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1048])((nint)texture);
			#endif
		}

		/// <summary>
		/// Get the renderer that created an SDL_Texture.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* GetRendererFromTexture(SDLTexture* texture)
		{
			SDLRenderer* ret = GetRendererFromTextureNative(texture);
			return ret;
		}

		/// <summary>
		/// Get the renderer that created an SDL_Texture.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		public static SDLRenderer* GetRendererFromTexture(ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				SDLRenderer* ret = GetRendererFromTextureNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextureSizeNative(SDLTexture* texture, float* w, float* h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, float*, float*, byte>)funcTable[1049])(texture, w, h);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[1049])((nint)texture, (nint)w, (nint)h);
			#endif
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(SDLTexture* texture, float* w, float* h)
		{
			byte ret = GetTextureSizeNative(texture, w, h);
			return ret != 0;
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(ref SDLTexture texture, float* w, float* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = GetTextureSizeNative((SDLTexture*)ptexture, w, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(SDLTexture* texture, ref float w, float* h)
		{
			fixed (float* pw = &w)
			{
				byte ret = GetTextureSizeNative(texture, (float*)pw, h);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(ref SDLTexture texture, ref float w, float* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pw = &w)
				{
					byte ret = GetTextureSizeNative((SDLTexture*)ptexture, (float*)pw, h);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(SDLTexture* texture, float* w, ref float h)
		{
			fixed (float* ph = &h)
			{
				byte ret = GetTextureSizeNative(texture, w, (float*)ph);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(ref SDLTexture texture, float* w, ref float h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ph = &h)
				{
					byte ret = GetTextureSizeNative((SDLTexture*)ptexture, w, (float*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(SDLTexture* texture, ref float w, ref float h)
		{
			fixed (float* pw = &w)
			{
				fixed (float* ph = &h)
				{
					byte ret = GetTextureSizeNative(texture, (float*)pw, (float*)ph);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the size of a texture, as floating point values.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureSize(ref SDLTexture texture, ref float w, ref float h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pw = &w)
				{
					fixed (float* ph = &h)
					{
						byte ret = GetTextureSizeNative((SDLTexture*)ptexture, (float*)pw, (float*)ph);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return<br/>
		/// false if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTextureColorModNative(SDLTexture* texture, byte r, byte g, byte b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, byte, byte, byte>)funcTable[1050])(texture, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte>)funcTable[1050])((nint)texture, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return<br/>
		/// false if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureColorMod(SDLTexture* texture, byte r, byte g, byte b)
		{
			byte ret = SetTextureColorModNative(texture, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return<br/>
		/// false if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureColorMod(ref SDLTexture texture, byte r, byte g, byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = SetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * color`<br/>
		/// Color modulation is not always supported by the renderer; it will return<br/>
		/// false if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTextureColorModFloatNative(SDLTexture* texture, float r, float g, float b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, float, float, float, byte>)funcTable[1051])(texture, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, float, byte>)funcTable[1051])((nint)texture, r, g, b);
			#endif
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * color`<br/>
		/// Color modulation is not always supported by the renderer; it will return<br/>
		/// false if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureColorModFloat(SDLTexture* texture, float r, float g, float b)
		{
			byte ret = SetTextureColorModFloatNative(texture, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * color`<br/>
		/// Color modulation is not always supported by the renderer; it will return<br/>
		/// false if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureColorModFloat(ref SDLTexture texture, float r, float g, float b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = SetTextureColorModFloatNative((SDLTexture*)ptexture, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextureColorModNative(SDLTexture* texture, byte* r, byte* g, byte* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, byte*, byte*, byte>)funcTable[1052])(texture, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[1052])((nint)texture, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, byte* r, byte* g, byte* b)
		{
			byte ret = GetTextureColorModNative(texture, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, byte* r, byte* g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, ref byte r, byte* g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				byte ret = GetTextureColorModNative(texture, (byte*)pr, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, ref byte r, byte* g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					byte ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, byte* r, ref byte g, byte* b)
		{
			fixed (byte* pg = &g)
			{
				byte ret = GetTextureColorModNative(texture, r, (byte*)pg, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, byte* r, ref byte g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, ref byte r, ref byte g, byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					byte ret = GetTextureColorModNative(texture, (byte*)pr, (byte*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, ref byte r, ref byte g, byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						byte ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, b);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, byte* r, byte* g, ref byte b)
		{
			fixed (byte* pb = &b)
			{
				byte ret = GetTextureColorModNative(texture, r, g, (byte*)pb);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, byte* r, byte* g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetTextureColorModNative((SDLTexture*)ptexture, r, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, ref byte r, byte* g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetTextureColorModNative(texture, (byte*)pr, g, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, ref byte r, byte* g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, byte* r, ref byte g, ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					byte ret = GetTextureColorModNative(texture, r, (byte*)pg, (byte*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, byte* r, ref byte g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(SDLTexture* texture, ref byte r, ref byte g, ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						byte ret = GetTextureColorModNative(texture, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorMod(ref SDLTexture texture, ref byte r, ref byte g, ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							byte ret = GetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextureColorModFloatNative(SDLTexture* texture, float* r, float* g, float* b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, float*, float*, float*, byte>)funcTable[1053])(texture, r, g, b);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[1053])((nint)texture, (nint)r, (nint)g, (nint)b);
			#endif
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, float* r, float* g, float* b)
		{
			byte ret = GetTextureColorModFloatNative(texture, r, g, b);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, float* r, float* g, float* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, r, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, ref float r, float* g, float* b)
		{
			fixed (float* pr = &r)
			{
				byte ret = GetTextureColorModFloatNative(texture, (float*)pr, g, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, ref float r, float* g, float* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pr = &r)
				{
					byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, (float*)pr, g, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, float* r, ref float g, float* b)
		{
			fixed (float* pg = &g)
			{
				byte ret = GetTextureColorModFloatNative(texture, r, (float*)pg, b);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, float* r, ref float g, float* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pg = &g)
				{
					byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, r, (float*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, ref float r, ref float g, float* b)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					byte ret = GetTextureColorModFloatNative(texture, (float*)pr, (float*)pg, b);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, ref float r, ref float g, float* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, (float*)pr, (float*)pg, b);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, float* r, float* g, ref float b)
		{
			fixed (float* pb = &b)
			{
				byte ret = GetTextureColorModFloatNative(texture, r, g, (float*)pb);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, float* r, float* g, ref float b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pb = &b)
				{
					byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, r, g, (float*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, ref float r, float* g, ref float b)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pb = &b)
				{
					byte ret = GetTextureColorModFloatNative(texture, (float*)pr, g, (float*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, ref float r, float* g, ref float b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pb = &b)
					{
						byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, (float*)pr, g, (float*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, float* r, ref float g, ref float b)
		{
			fixed (float* pg = &g)
			{
				fixed (float* pb = &b)
				{
					byte ret = GetTextureColorModFloatNative(texture, r, (float*)pg, (float*)pb);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, float* r, ref float g, ref float b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, r, (float*)pg, (float*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(SDLTexture* texture, ref float r, ref float g, ref float b)
		{
			fixed (float* pr = &r)
			{
				fixed (float* pg = &g)
				{
					fixed (float* pb = &b)
					{
						byte ret = GetTextureColorModFloatNative(texture, (float*)pr, (float*)pg, (float*)pb);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureColorModFloat(ref SDLTexture texture, ref float r, ref float g, ref float b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pr = &r)
				{
					fixed (float* pg = &g)
					{
						fixed (float* pb = &b)
						{
							byte ret = GetTextureColorModFloatNative((SDLTexture*)ptexture, (float*)pr, (float*)pg, (float*)pb);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return<br/>
		/// false if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTextureAlphaModNative(SDLTexture* texture, byte alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte, byte>)funcTable[1054])(texture, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[1054])((nint)texture, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return<br/>
		/// false if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureAlphaMod(SDLTexture* texture, byte alpha)
		{
			byte ret = SetTextureAlphaModNative(texture, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return<br/>
		/// false if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureAlphaMod(ref SDLTexture texture, byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = SetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * alpha`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return<br/>
		/// false if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTextureAlphaModFloatNative(SDLTexture* texture, float alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, float, byte>)funcTable[1055])(texture, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, byte>)funcTable[1055])((nint)texture, alpha);
			#endif
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * alpha`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return<br/>
		/// false if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureAlphaModFloat(SDLTexture* texture, float alpha)
		{
			byte ret = SetTextureAlphaModFloatNative(texture, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * alpha`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return<br/>
		/// false if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureAlphaModFloat(ref SDLTexture texture, float alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = SetTextureAlphaModFloatNative((SDLTexture*)ptexture, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextureAlphaModNative(SDLTexture* texture, byte* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, byte*, byte>)funcTable[1056])(texture, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1056])((nint)texture, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaMod(SDLTexture* texture, byte* alpha)
		{
			byte ret = GetTextureAlphaModNative(texture, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaMod(ref SDLTexture texture, byte* alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = GetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaMod(SDLTexture* texture, ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				byte ret = GetTextureAlphaModNative(texture, (byte*)palpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaMod(ref SDLTexture texture, ref byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* palpha = &alpha)
				{
					byte ret = GetTextureAlphaModNative((SDLTexture*)ptexture, (byte*)palpha);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextureAlphaModFloatNative(SDLTexture* texture, float* alpha)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, float*, byte>)funcTable[1057])(texture, alpha);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1057])((nint)texture, (nint)alpha);
			#endif
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaModFloat(SDLTexture* texture, float* alpha)
		{
			byte ret = GetTextureAlphaModFloatNative(texture, alpha);
			return ret != 0;
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaModFloat(ref SDLTexture texture, float* alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = GetTextureAlphaModFloatNative((SDLTexture*)ptexture, alpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaModFloat(SDLTexture* texture, ref float alpha)
		{
			fixed (float* palpha = &alpha)
			{
				byte ret = GetTextureAlphaModFloatNative(texture, (float*)palpha);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureAlphaModFloat(ref SDLTexture texture, ref float alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* palpha = &alpha)
				{
					byte ret = GetTextureAlphaModFloatNative((SDLTexture*)ptexture, (float*)palpha);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderTexture().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTextureBlendModeNative(SDLTexture* texture, SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode, byte>)funcTable[1058])(texture, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, byte>)funcTable[1058])((nint)texture, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderTexture().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureBlendMode(SDLTexture* texture, SDLBlendMode blendMode)
		{
			byte ret = SetTextureBlendModeNative(texture, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderTexture().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns false.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureBlendMode(ref SDLTexture texture, SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = SetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextureBlendModeNative(SDLTexture* texture, SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLBlendMode*, byte>)funcTable[1059])(texture, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1059])((nint)texture, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureBlendMode(SDLTexture* texture, SDLBlendMode* blendMode)
		{
			byte ret = GetTextureBlendModeNative(texture, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureBlendMode(ref SDLTexture texture, SDLBlendMode* blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = GetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureBlendMode(SDLTexture* texture, ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				byte ret = GetTextureBlendModeNative(texture, (SDLBlendMode*)pblendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureBlendMode(ref SDLTexture texture, ref SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					byte ret = GetTextureBlendModeNative((SDLTexture*)ptexture, (SDLBlendMode*)pblendMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// The default texture scale mode is SDL_SCALEMODE_LINEAR.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetTextureScaleModeNative(SDLTexture* texture, SDLScaleMode scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode, byte>)funcTable[1060])(texture, scaleMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLScaleMode, byte>)funcTable[1060])((nint)texture, scaleMode);
			#endif
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// The default texture scale mode is SDL_SCALEMODE_LINEAR.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureScaleMode(SDLTexture* texture, SDLScaleMode scaleMode)
		{
			byte ret = SetTextureScaleModeNative(texture, scaleMode);
			return ret != 0;
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// The default texture scale mode is SDL_SCALEMODE_LINEAR.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetTextureScaleMode(ref SDLTexture texture, SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = SetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetTextureScaleModeNative(SDLTexture* texture, SDLScaleMode* scaleMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLScaleMode*, byte>)funcTable[1061])(texture, scaleMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1061])((nint)texture, (nint)scaleMode);
			#endif
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureScaleMode(SDLTexture* texture, SDLScaleMode* scaleMode)
		{
			byte ret = GetTextureScaleModeNative(texture, scaleMode);
			return ret != 0;
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureScaleMode(ref SDLTexture texture, SDLScaleMode* scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = GetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureScaleMode(SDLTexture* texture, ref SDLScaleMode scaleMode)
		{
			fixed (SDLScaleMode* pscaleMode = &scaleMode)
			{
				byte ret = GetTextureScaleModeNative(texture, (SDLScaleMode*)pscaleMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetTextureScaleMode(ref SDLTexture texture, ref SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLScaleMode* pscaleMode = &scaleMode)
				{
					byte ret = GetTextureScaleModeNative((SDLTexture*)ptexture, (SDLScaleMode*)pscaleMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture, which can be<br/>
		/// queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateTextureNative(SDLTexture* texture, SDLRect* rect, void* pixels, int pitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, void*, int, byte>)funcTable[1062])(texture, rect, pixels, pitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, byte>)funcTable[1062])((nint)texture, (nint)rect, (nint)pixels, pitch);
			#endif
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture, which can be<br/>
		/// queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateTexture(SDLTexture* texture, SDLRect* rect, void* pixels, int pitch)
		{
			byte ret = UpdateTextureNative(texture, rect, pixels, pitch);
			return ret != 0;
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture, which can be<br/>
		/// queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateTexture(ref SDLTexture texture, SDLRect* rect, void* pixels, int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = UpdateTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture, which can be<br/>
		/// queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateTexture(SDLTexture* texture, ref SDLRect rect, void* pixels, int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = UpdateTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture, which can be<br/>
		/// queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateTexture(ref SDLTexture texture, ref SDLRect rect, void* pixels, int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = UpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UpdateYUVTextureNative(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTexture*, SDLRect*, byte*, int, byte*, int, byte*, int, byte>)funcTable[1063])(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int, byte>)funcTable[1063])((nint)texture, (nint)rect, (nint)yplane, ypitch, (nint)uplane, upitch, (nint)vplane, vpitch);
			#endif
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			byte ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			return ret != 0;
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, ref byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				byte ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, ref byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, ref byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, ref byte yplane, int ypitch, byte* uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				byte ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, byte* yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, byte* yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, byte* yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					byte ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, byte* vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (byte* pvplane = &vplane)
			{
				byte ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, byte* yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pvplane = &vplane)
				{
					byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pvplane = &vplane)
				{
					byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, byte* yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pvplane = &vplane)
					{
						byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, ref byte yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					byte ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, ref byte yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, ref byte yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, ref byte yplane, int ypitch, byte* uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, byte* yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					byte ret = UpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, SDLRect* rect, byte* yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, ref SDLRect rect, byte* yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						byte ret = UpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(ref SDLTexture texture, ref SDLRect rect, byte* yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							byte ret = UpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool UpdateYUVTexture(SDLTexture* texture, SDLRect* rect, ref byte yplane, int ypitch, ref byte uplane, int upitch, ref byte vplane, int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						byte ret = UpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret != 0;
					}
				}
			}
		}
	}
}
