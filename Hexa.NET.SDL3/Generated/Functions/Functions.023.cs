// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[966])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[966])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidGetFeatureReportNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidGetFeatureReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidGetFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetInputReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[967])(dev, data, length);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[967])((nint)dev, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = HidGetInputReportNative(dev, data, length);
			return ret;
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetInputReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = HidGetInputReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>
		/// Get an input report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_input_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetInputReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = HidGetInputReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidCloseNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int>)funcTable[968])(dev);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[968])((nint)dev);
			#endif
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			int ret = HidCloseNative(dev);
			return ret;
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidCloseNative((SDLHidDevice*)pdev);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetManufacturerStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[969])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[969])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetManufacturerStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetManufacturerStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetManufacturerStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetManufacturerStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetProductStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[970])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[970])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetProductStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetProductStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetProductStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetProductStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetProductStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetProductStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetSerialNumberStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, char*, nuint, int>)funcTable[971])(dev, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[971])((nint)dev, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetSerialNumberStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetSerialNumberStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetSerialNumberStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetSerialNumberStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetSerialNumberStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetSerialNumberStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetIndexedStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, int, char*, nuint, int>)funcTable[972])(dev, stringIndex, str, maxlen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nuint, int>)funcTable[972])((nint)dev, stringIndex, (nint)str, maxlen);
			#endif
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = HidGetIndexedStringNative(dev, stringIndex, str, maxlen);
			return ret;
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, str, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = HidGetIndexedStringNative(dev, stringIndex, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = HidGetIndexedStringNative(dev, stringIndex, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = HidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar *")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = HidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get the device info from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_device_info")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHidDeviceInfo* HidGetDeviceInfoNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, SDLHidDeviceInfo*>)funcTable[973])(dev);
			#else
			return (SDLHidDeviceInfo*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[973])((nint)dev);
			#endif
		}

		/// <summary>
		/// Get the device info from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_device_info")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		public static SDLHidDeviceInfo* HidGetDeviceInfo([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev)
		{
			SDLHidDeviceInfo* ret = HidGetDeviceInfoNative(dev);
			return ret;
		}

		/// <summary>
		/// Get the device info from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_device_info")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info *")]
		public static SDLHidDeviceInfo* HidGetDeviceInfo([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				SDLHidDeviceInfo* ret = HidGetDeviceInfoNative((SDLHidDevice*)pdev);
				return ret;
			}
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HidGetReportDescriptorNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHidDevice*, byte*, nuint, int>)funcTable[974])(dev, buf, bufSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[974])((nint)dev, (nint)buf, bufSize);
			#endif
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			int ret = HidGetReportDescriptorNative(dev, buf, bufSize);
			return ret;
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = HidGetReportDescriptorNative((SDLHidDevice*)pdev, buf, bufSize);
				return ret;
			}
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			fixed (byte* pbuf = &buf)
			{
				int ret = HidGetReportDescriptorNative(dev, (byte*)pbuf, bufSize);
				return ret;
			}
		}

		/// <summary>
		/// Get a report descriptor from a HID device.<br/>
		/// User has to provide a preallocated buffer where descriptor will be copied<br/>
		/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_report_descriptor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int HidGetReportDescriptor([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device *")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte buf, [NativeName(NativeNameType.Param, "buf_size")] [NativeName(NativeNameType.Type, "size_t")] nuint bufSize)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pbuf = &buf)
				{
					int ret = HidGetReportDescriptorNative((SDLHidDevice*)pdev, (byte*)pbuf, bufSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_ble_scan")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HidBleScanNative([NativeName(NativeNameType.Param, "active")] [NativeName(NativeNameType.Type, "bool")] byte active)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[975])(active);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[975])(active);
			#endif
		}

		/// <summary>
		/// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_ble_scan")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void HidBleScan([NativeName(NativeNameType.Param, "active")] [NativeName(NativeNameType.Type, "bool")] bool active)
		{
			HidBleScanNative(active ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetHintWithPriorityNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, SDLHintPriority, byte>)funcTable[976])(name, value, priority);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLHintPriority, byte>)funcTable[976])((nint)name, (nint)value, priority);
			#endif
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte ret = SetHintWithPriorityNative(name, value, priority);
			return ret != 0;
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetHintWithPriorityNative((byte*)pname, value, priority);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetHintWithPriorityNative((byte*)pname, value, priority);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetHintWithPriorityNative(pStr0, value, priority);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pvalue = &value)
			{
				byte ret = SetHintWithPriorityNative(name, (byte*)pvalue, priority);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pvalue = value)
			{
				byte ret = SetHintWithPriorityNative(name, (byte*)pvalue, priority);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetHintWithPriorityNative(name, pStr0, priority);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = SetHintWithPriorityNative((byte*)pname, (byte*)pvalue, priority);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetHintWithPriorityNative((byte*)pname, (byte*)pvalue, priority);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetHintWithPriorityNative(pStr0, pStr1, priority);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)funcTable[977])(name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[977])((nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte ret = SetHintNative(name, value);
			return ret != 0;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetHintNative((byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetHintNative((byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetHintNative(pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				byte ret = SetHintNative(name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pvalue = value)
			{
				byte ret = SetHintNative(name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetHintNative(name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = SetHintNative((byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetHintNative((byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetHintNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ResetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[978])(name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[978])((nint)name);
			#endif
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = ResetHintNative(name);
			return ret != 0;
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ResetHintNative((byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = ResetHintNative((byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ResetHintNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Reset all hints to the default values.<br/>
		/// This will reset all hints to the value of the associated environment<br/>
		/// variable, or NULL if the environment isn't set. Callbacks will be called<br/>
		/// normally with this change.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetHintsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[979])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[979])();
			#endif
		}

		/// <summary>
		/// Reset all hints to the default values.<br/>
		/// This will reset all hints to the value of the associated environment<br/>
		/// variable, or NULL if the environment isn't set. Callbacks will be called<br/>
		/// normally with this change.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetHints()
		{
			ResetHintsNative();
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[980])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[980])((nint)name);
			#endif
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte* ret = GetHintNative(name);
			return ret;
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(GetHintNative(name));
			return ret;
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetHintNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetHintNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetHintNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, however the<br/>
		/// return value only remains valid until the hint is changed; if<br/>
		/// another thread might do so, the app should supply locks<br/>
		/// and/or make a copy of the string. Note that using a hint<br/>
		/// callback instead is always thread-safe, as SDL holds a lock<br/>
		/// on the thread subsystem during the callback.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetHintNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetHintBooleanNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] byte defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte, byte>)funcTable[981])(name, defaultValue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte>)funcTable[981])((nint)name, defaultValue);
			#endif
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			byte ret = GetHintBooleanNative(name, defaultValue ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			fixed (byte* pname = &name)
			{
				byte ret = GetHintBooleanNative((byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			fixed (byte* pname = name)
			{
				byte ret = GetHintBooleanNative((byte*)pname, defaultValue ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "bool")] bool defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GetHintBooleanNative(pStr0, defaultValue ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AddHintCallbackNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, byte*, byte*, byte*, void>, void*, byte>)funcTable[982])(name, (delegate*<void*, byte*, byte*, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[982])((nint)name, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = AddHintCallbackNative(name, callback, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				byte ret = AddHintCallbackNative((byte*)pname, callback, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				byte ret = AddHintCallbackNative((byte*)pname, callback, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// The callback function is called _during_ this function, to provide it an<br/>
		/// initial value, and again each time the hint's value changes.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = AddHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RemoveHintCallbackNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, byte*, byte*, byte*, void>, void*, void>)funcTable[983])(name, (delegate*<void*, byte*, byte*, byte*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[983])((nint)name, (nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata);
			#endif
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			RemoveHintCallbackNative(name, callback, userdata);
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				RemoveHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* pname = name)
			{
				RemoveHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void RemoveHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RemoveHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Initialize the SDL library.<br/>
		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
		/// two may be used interchangeably. Though for readability of your code<br/>
		/// SDL_InitSubSystem() might be preferred.<br/>
		/// The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)<br/>
		/// subsystems are initialized by default. Message boxes<br/>
		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
		/// use them in your application.<br/>
		/// Logging (such as SDL_Log) works without initialization, too.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
		/// subsystem, should be initialized on the main thread.<br/>
		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
		/// events subsystem<br/>
		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
		/// - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the<br/>
		/// joystick subsystem<br/>
		/// - `SDL_INIT_EVENTS`: events subsystem<br/>
		/// - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
		/// this call will increase the ref-count and return.<br/>
		/// Consider reporting some basic metadata about your application before<br/>
		/// calling SDL_Init, using either SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitFlags, byte>)funcTable[984])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLInitFlags, byte>)funcTable[984])(flags);
			#endif
		}

		/// <summary>
		/// Initialize the SDL library.<br/>
		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
		/// two may be used interchangeably. Though for readability of your code<br/>
		/// SDL_InitSubSystem() might be preferred.<br/>
		/// The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)<br/>
		/// subsystems are initialized by default. Message boxes<br/>
		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
		/// use them in your application.<br/>
		/// Logging (such as SDL_Log) works without initialization, too.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
		/// subsystem, should be initialized on the main thread.<br/>
		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
		/// events subsystem<br/>
		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
		/// - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the<br/>
		/// joystick subsystem<br/>
		/// - `SDL_INIT_EVENTS`: events subsystem<br/>
		/// - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
		/// this call will increase the ref-count and return.<br/>
		/// Consider reporting some basic metadata about your application before<br/>
		/// calling SDL_Init, using either SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Init")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Init([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			byte ret = InitNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// Compatibility function to initialize the SDL library.<br/>
		/// This function and SDL_Init() are interchangeable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitSubSystem")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte InitSubSystemNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitFlags, byte>)funcTable[985])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLInitFlags, byte>)funcTable[985])(flags);
			#endif
		}

		/// <summary>
		/// Compatibility function to initialize the SDL library.<br/>
		/// This function and SDL_Init() are interchangeable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitSubSystem")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool InitSubSystem([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			byte ret = InitSubSystemNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// Shut down specific SDL subsystems.<br/>
		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
		/// with SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QuitSubSystem")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuitSubSystemNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLInitFlags, void>)funcTable[986])(flags);
			#else
			((delegate* unmanaged[Cdecl]<SDLInitFlags, void>)funcTable[986])(flags);
			#endif
		}

		/// <summary>
		/// Shut down specific SDL subsystems.<br/>
		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
		/// with SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QuitSubSystem")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void QuitSubSystem([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			QuitSubSystemNative(flags);
		}

		/// <summary>
		/// Get a mask of the specified subsystems which are currently initialized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WasInit")]
		[return: NativeName(NativeNameType.Type, "SDL_InitFlags")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLInitFlags WasInitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLInitFlags, SDLInitFlags>)funcTable[987])(flags);
			#else
			return (SDLInitFlags)((delegate* unmanaged[Cdecl]<SDLInitFlags, SDLInitFlags>)funcTable[987])(flags);
			#endif
		}

		/// <summary>
		/// Get a mask of the specified subsystems which are currently initialized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WasInit")]
		[return: NativeName(NativeNameType.Type, "SDL_InitFlags")]
		public static SDLInitFlags WasInit([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_InitFlags")] SDLInitFlags flags)
		{
			SDLInitFlags ret = WasInitNative(flags);
			return ret;
		}

		/// <summary>
		/// Clean up all initialized subsystems.<br/>
		/// You should call this function even if you have already shutdown each<br/>
		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
		/// function even in the case of errors in initialization.<br/>
		/// You can use this function with atexit() to ensure that it is run when your<br/>
		/// application is shutdown, but it is not wise to do this from a library or<br/>
		/// other dynamically loaded code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[988])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[988])();
			#endif
		}

		/// <summary>
		/// Clean up all initialized subsystems.<br/>
		/// You should call this function even if you have already shutdown each<br/>
		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
		/// function even in the case of errors in initialization.<br/>
		/// You can use this function with atexit() to ensure that it is run when your<br/>
		/// application is shutdown, but it is not wise to do this from a library or<br/>
		/// other dynamically loaded code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Quit()
		{
			QuitNative();
		}

		/// <summary>
		/// Return whether this is the main thread.<br/>
		/// On Apple platforms, the main thread is the thread that runs your program's<br/>
		/// main() entry point. On other platforms, the main thread is the one that<br/>
		/// calls SDL_Init(SDL_INIT_VIDEO), which should usually be the one that runs<br/>
		/// your program's main() entry point. If you are using the main callbacks,<br/>
		/// SDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the<br/>
		/// main thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMainThread")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMainThreadNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[989])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[989])();
			#endif
		}

		/// <summary>
		/// Return whether this is the main thread.<br/>
		/// On Apple platforms, the main thread is the thread that runs your program's<br/>
		/// main() entry point. On other platforms, the main thread is the one that<br/>
		/// calls SDL_Init(SDL_INIT_VIDEO), which should usually be the one that runs<br/>
		/// your program's main() entry point. If you are using the main callbacks,<br/>
		/// SDL_AppInit(), SDL_AppIterate(), and SDL_AppQuit() are all called on the<br/>
		/// main thread.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsMainThread")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMainThread()
		{
			byte ret = IsMainThreadNative();
			return ret != 0;
		}

		/// <summary>
		/// Call a function on the main thread during event processing.<br/>
		/// If this is called on the main thread, the callback is executed immediately.<br/>
		/// If this is called on another thread, this callback is queued for execution<br/>
		/// on the main thread during event processing.<br/>
		/// Be careful of deadlocks when using this functionality. You should not have<br/>
		/// the main thread wait for the current thread while this function is being<br/>
		/// called with `wait_complete` true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunOnMainThread")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RunOnMainThreadNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_MainThreadCallback")] SDLMainThreadCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "wait_complete")] [NativeName(NativeNameType.Type, "bool")] byte waitComplete)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void*, void>, void*, byte, byte>)funcTable[990])((delegate*<void*, void>)Utils.GetFunctionPointerForDelegate(callback), userdata, waitComplete);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte>)funcTable[990])((nint)Utils.GetFunctionPointerForDelegate(callback), (nint)userdata, waitComplete);
			#endif
		}

		/// <summary>
		/// Call a function on the main thread during event processing.<br/>
		/// If this is called on the main thread, the callback is executed immediately.<br/>
		/// If this is called on another thread, this callback is queued for execution<br/>
		/// on the main thread during event processing.<br/>
		/// Be careful of deadlocks when using this functionality. You should not have<br/>
		/// the main thread wait for the current thread while this function is being<br/>
		/// called with `wait_complete` true.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RunOnMainThread")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RunOnMainThread([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_MainThreadCallback")] SDLMainThreadCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata, [NativeName(NativeNameType.Param, "wait_complete")] [NativeName(NativeNameType.Type, "bool")] bool waitComplete)
		{
			byte ret = RunOnMainThreadNative(callback, userdata, waitComplete ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetAppMetadataNative([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte*, byte>)funcTable[991])(appname, appversion, appidentifier);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[991])((nint)appname, (nint)appversion, (nint)appidentifier);
			#endif
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			byte ret = SetAppMetadataNative(appname, appversion, appidentifier);
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ref byte appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = &appname)
			{
				byte ret = SetAppMetadataNative((byte*)pappname, appversion, appidentifier);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = appname)
			{
				byte ret = SetAppMetadataNative((byte*)pappname, appversion, appidentifier);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] string appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetAppMetadataNative(pStr0, appversion, appidentifier);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ref byte appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappversion = &appversion)
			{
				byte ret = SetAppMetadataNative(appname, (byte*)pappversion, appidentifier);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappversion = appversion)
			{
				byte ret = SetAppMetadataNative(appname, (byte*)pappversion, appidentifier);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] string appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appversion != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appversion);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appversion, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetAppMetadataNative(appname, pStr0, appidentifier);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ref byte appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ref byte appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = &appname)
			{
				fixed (byte* pappversion = &appversion)
				{
					byte ret = SetAppMetadataNative((byte*)pappname, (byte*)pappversion, appidentifier);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			fixed (byte* pappname = appname)
			{
				fixed (byte* pappversion = appversion)
				{
					byte ret = SetAppMetadataNative((byte*)pappname, (byte*)pappversion, appidentifier);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] string appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] string appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] byte* appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (appversion != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(appversion);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(appversion, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetAppMetadataNative(pStr0, pStr1, appidentifier);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ref byte appidentifier)
		{
			fixed (byte* pappidentifier = &appidentifier)
			{
				byte ret = SetAppMetadataNative(appname, appversion, (byte*)pappidentifier);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appidentifier)
		{
			fixed (byte* pappidentifier = appidentifier)
			{
				byte ret = SetAppMetadataNative(appname, appversion, (byte*)pappidentifier);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] string appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appidentifier != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appidentifier);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appidentifier, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetAppMetadataNative(appname, appversion, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ref byte appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ref byte appidentifier)
		{
			fixed (byte* pappname = &appname)
			{
				fixed (byte* pappidentifier = &appidentifier)
				{
					byte ret = SetAppMetadataNative((byte*)pappname, appversion, (byte*)pappidentifier);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appidentifier)
		{
			fixed (byte* pappname = appname)
			{
				fixed (byte* pappidentifier = appidentifier)
				{
					byte ret = SetAppMetadataNative((byte*)pappname, appversion, (byte*)pappidentifier);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] string appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] byte* appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] string appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (appidentifier != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(appidentifier);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(appidentifier, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetAppMetadataNative(pStr0, appversion, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ref byte appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ref byte appidentifier)
		{
			fixed (byte* pappversion = &appversion)
			{
				fixed (byte* pappidentifier = &appidentifier)
				{
					byte ret = SetAppMetadataNative(appname, (byte*)pappversion, (byte*)pappidentifier);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appidentifier)
		{
			fixed (byte* pappversion = appversion)
			{
				fixed (byte* pappidentifier = appidentifier)
				{
					byte ret = SetAppMetadataNative(appname, (byte*)pappversion, (byte*)pappidentifier);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] byte* appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] string appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] string appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appversion != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appversion);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appversion, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (appidentifier != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(appidentifier);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(appidentifier, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetAppMetadataNative(appname, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ref byte appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ref byte appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ref byte appidentifier)
		{
			fixed (byte* pappname = &appname)
			{
				fixed (byte* pappversion = &appversion)
				{
					fixed (byte* pappidentifier = &appidentifier)
					{
						byte ret = SetAppMetadataNative((byte*)pappname, (byte*)pappversion, (byte*)pappidentifier);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> appidentifier)
		{
			fixed (byte* pappname = appname)
			{
				fixed (byte* pappversion = appversion)
				{
					fixed (byte* pappidentifier = appidentifier)
					{
						byte ret = SetAppMetadataNative((byte*)pappname, (byte*)pappversion, (byte*)pappidentifier);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Specify basic metadata about your app.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
		/// detail doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Passing a NULL removes any previous metadata.<br/>
		/// This is a simplified interface for the most important information. You can<br/>
		/// supply significantly more detailed metadata with<br/>
		/// SDL_SetAppMetadataProperty().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadata")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadata([NativeName(NativeNameType.Param, "appname")] [NativeName(NativeNameType.Type, "char const *")] string appname, [NativeName(NativeNameType.Param, "appversion")] [NativeName(NativeNameType.Type, "char const *")] string appversion, [NativeName(NativeNameType.Param, "appidentifier")] [NativeName(NativeNameType.Type, "char const *")] string appidentifier)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (appname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(appname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(appname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (appversion != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(appversion);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(appversion, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (appidentifier != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(appidentifier);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(appidentifier, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = SetAppMetadataNative(pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetAppMetadataPropertyNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)funcTable[992])(name, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[992])((nint)name, (nint)value);
			#endif
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte ret = SetAppMetadataPropertyNative(name, value);
			return ret != 0;
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetAppMetadataPropertyNative((byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetAppMetadataPropertyNative((byte*)pname, value);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] byte* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetAppMetadataPropertyNative(pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				byte ret = SetAppMetadataPropertyNative(name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pvalue = value)
			{
				byte ret = SetAppMetadataPropertyNative(name, (byte*)pvalue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetAppMetadataPropertyNative(name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ref byte value)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					byte ret = SetAppMetadataPropertyNative((byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> value)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pvalue = value)
				{
					byte ret = SetAppMetadataPropertyNative((byte*)pname, (byte*)pvalue);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Specify metadata about your app through a set of properties.<br/>
		/// You can optionally provide metadata about your app to SDL. This is not<br/>
		/// required, but strongly encouraged.<br/>
		/// There are several locations where SDL can make use of metadata (an "About"<br/>
		/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
		/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
		/// doesn't make sense for the app.<br/>
		/// This function should be called as early as possible, before SDL_Init.<br/>
		/// Multiple calls to this function are allowed, but various state might not<br/>
		/// change once it has been set up with a previous call to this function.<br/>
		/// Once set, this metadata can be read using SDL_GetAppMetadataProperty().<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
		/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
		/// anywhere the OS shows the name of the application separately from window<br/>
		/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
		/// Application".<br/>
		/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
		/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
		/// 2024" and a git hash are all valid options. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
		/// identifies this app. This must be in reverse-domain format, like<br/>
		/// "com.example.mygame2". This string is used by desktop compositors to<br/>
		/// identify and group windows together, as well as match applications with<br/>
		/// associated desktop settings and icons. If you plan to package your<br/>
		/// application in a container such as Flatpak, the app ID should match the<br/>
		/// name of your Flatpak container as well. This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
		/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
		/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
		/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
		/// to one line, don't paste a copy of a whole software license in here. This<br/>
		/// has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
		/// product page, or a storefront, or even a GitHub repository, for user's<br/>
		/// further information This has no default.<br/>
		/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
		/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
		/// media player, or generically "application" if nothing else applies.<br/>
		/// Future versions of SDL might add new types. This defaults to<br/>
		/// "application".<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "char const *")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = SetAppMetadataPropertyNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetAppMetadataPropertyNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*>)funcTable[993])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[993])((nint)name);
			#endif
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte* ret = GetAppMetadataPropertyNative(name);
			return ret;
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetAppMetadataPropertyS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(GetAppMetadataPropertyNative(name));
			return ret;
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = GetAppMetadataPropertyNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetAppMetadataPropertyS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(GetAppMetadataPropertyNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte* ret = GetAppMetadataPropertyNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetAppMetadataPropertyS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(GetAppMetadataPropertyNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetAppMetadataProperty([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetAppMetadataPropertyNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get metadata about your app.<br/>
		/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
		/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
		/// of available properties and their meanings.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, although<br/>
		/// the string returned is not protected and could potentially be<br/>
		/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
		/// property from another thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAppMetadataProperty")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetAppMetadataPropertyS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetAppMetadataPropertyNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "SDL_SharedObject *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSharedObject* LoadObjectNative([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "char const *")] byte* sofile)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSharedObject*>)funcTable[994])(sofile);
			#else
			return (SDLSharedObject*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[994])((nint)sofile);
			#endif
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "SDL_SharedObject *")]
		public static SDLSharedObject* LoadObject([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "char const *")] byte* sofile)
		{
			SDLSharedObject* ret = LoadObjectNative(sofile);
			return ret;
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "SDL_SharedObject *")]
		public static SDLSharedObject* LoadObject([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "char const *")] ref byte sofile)
		{
			fixed (byte* psofile = &sofile)
			{
				SDLSharedObject* ret = LoadObjectNative((byte*)psofile);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "SDL_SharedObject *")]
		public static SDLSharedObject* LoadObject([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> sofile)
		{
			fixed (byte* psofile = sofile)
			{
				SDLSharedObject* ret = LoadObjectNative((byte*)psofile);
				return ret;
			}
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "SDL_SharedObject *")]
		public static SDLSharedObject* LoadObject([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "char const *")] string sofile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sofile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sofile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sofile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSharedObject* ret = LoadObjectNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> LoadFunctionNative([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "SDL_SharedObject *")] SDLSharedObject* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSharedObject*, byte*, delegate*<void>>)funcTable[995])(handle, name);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[995])((nint)handle, (nint)name);
			#endif
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> LoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "SDL_SharedObject *")] SDLSharedObject* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			delegate*<void> ret = LoadFunctionNative(handle, name);
			return ret;
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> LoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "SDL_SharedObject *")] ref SDLSharedObject handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			fixed (SDLSharedObject* phandle = &handle)
			{
				delegate*<void> ret = LoadFunctionNative((SDLSharedObject*)phandle, name);
				return ret;
			}
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> LoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "SDL_SharedObject *")] SDLSharedObject* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				delegate*<void> ret = LoadFunctionNative(handle, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> LoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "SDL_SharedObject *")] SDLSharedObject* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				delegate*<void> ret = LoadFunctionNative(handle, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> LoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "SDL_SharedObject *")] SDLSharedObject* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = LoadFunctionNative(handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
