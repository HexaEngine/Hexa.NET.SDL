// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetPrefPathNative(pStr0, app);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] byte* app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetPrefPathNative(pStr0, app));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] in byte app)
		{
			fixed (byte* papp = &app)
			{
				byte* ret = GetPrefPathNative(org, (byte*)papp);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] in byte app)
		{
			fixed (byte* papp = &app)
			{
				string ret = Utils.DecodeStringUTF8(GetPrefPathNative(org, (byte*)papp));
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> app)
		{
			fixed (byte* papp = app)
			{
				byte* ret = GetPrefPathNative(org, (byte*)papp);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> app)
		{
			fixed (byte* papp = app)
			{
				string ret = Utils.DecodeStringUTF8(GetPrefPathNative(org, (byte*)papp));
				return ret;
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (app != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(app);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(app, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetPrefPathNative(org, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (app != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(app);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(app, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetPrefPathNative(org, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] in byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] in byte app)
		{
			fixed (byte* porg = &org)
			{
				fixed (byte* papp = &app)
				{
					byte* ret = GetPrefPathNative((byte*)porg, (byte*)papp);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] in byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] in byte app)
		{
			fixed (byte* porg = &org)
			{
				fixed (byte* papp = &app)
				{
					string ret = Utils.DecodeStringUTF8(GetPrefPathNative((byte*)porg, (byte*)papp));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> app)
		{
			fixed (byte* porg = org)
			{
				fixed (byte* papp = app)
				{
					byte* ret = GetPrefPathNative((byte*)porg, (byte*)papp);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> app)
		{
			fixed (byte* porg = org)
			{
				fixed (byte* papp = app)
				{
					string ret = Utils.DecodeStringUTF8(GetPrefPathNative((byte*)porg, (byte*)papp));
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (app != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(app);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(app, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = GetPrefPathNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On macOS, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// Due to historical mistakes, `org` is allowed to be NULL or "". In such<br/>
		/// cases, SDL will omit the org subdirectory, including on platforms where it<br/>
		/// shouldn't, and including on platforms where this would make your app fail<br/>
		/// certification for an app store. New apps should definitely specify a real<br/>
		/// string for `org`.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "char const *")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "char const *")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (app != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(app);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(app, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetPrefPathNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Finds the most suitable user folder for a specific purpose.<br/>
		/// Many OSes provide certain standard folders for certain purposes, such as<br/>
		/// storing pictures, music or videos for a certain user. This function gives<br/>
		/// the path for many of those special locations.<br/>
		/// This function is specifically for _user_ folders, which are meant for the<br/>
		/// user to access and manage. For application-specific folders, meant to hold<br/>
		/// data for the application to manage, see SDL_GetBasePath() and<br/>
		/// SDL_GetPrefPath().<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// If NULL is returned, the error may be obtained with SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetUserFolder")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetUserFolderNative([NativeName(NativeNameType.Param, "folder")] [NativeName(NativeNameType.Type, "SDL_Folder")] SDLFolder folder)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLFolder, byte*>)funcTable[842])(folder);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLFolder, nint>)funcTable[842])(folder);
			#endif
		}

		/// <summary>
		/// Finds the most suitable user folder for a specific purpose.<br/>
		/// Many OSes provide certain standard folders for certain purposes, such as<br/>
		/// storing pictures, music or videos for a certain user. This function gives<br/>
		/// the path for many of those special locations.<br/>
		/// This function is specifically for _user_ folders, which are meant for the<br/>
		/// user to access and manage. For application-specific folders, meant to hold<br/>
		/// data for the application to manage, see SDL_GetBasePath() and<br/>
		/// SDL_GetPrefPath().<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// If NULL is returned, the error may be obtained with SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetUserFolder")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetUserFolder([NativeName(NativeNameType.Param, "folder")] [NativeName(NativeNameType.Type, "SDL_Folder")] SDLFolder folder)
		{
			byte* ret = GetUserFolderNative(folder);
			return ret;
		}

		/// <summary>
		/// Finds the most suitable user folder for a specific purpose.<br/>
		/// Many OSes provide certain standard folders for certain purposes, such as<br/>
		/// storing pictures, music or videos for a certain user. This function gives<br/>
		/// the path for many of those special locations.<br/>
		/// This function is specifically for _user_ folders, which are meant for the<br/>
		/// user to access and manage. For application-specific folders, meant to hold<br/>
		/// data for the application to manage, see SDL_GetBasePath() and<br/>
		/// SDL_GetPrefPath().<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// If NULL is returned, the error may be obtained with SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetUserFolder")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetUserFolderS([NativeName(NativeNameType.Param, "folder")] [NativeName(NativeNameType.Type, "SDL_Folder")] SDLFolder folder)
		{
			string ret = Utils.DecodeStringUTF8(GetUserFolderNative(folder));
			return ret;
		}

		/// <summary>
		/// Create a directory, and any missing parent directories.<br/>
		/// This reports success if `path` already exists as a directory.<br/>
		/// If parent directories are missing, it will also create them. Note that if<br/>
		/// this fails, it will not remove any parent directories it already made.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CreateDirectoryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[843])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[843])((nint)path);
			#endif
		}

		/// <summary>
		/// Create a directory, and any missing parent directories.<br/>
		/// This reports success if `path` already exists as a directory.<br/>
		/// If parent directories are missing, it will also create them. Note that if<br/>
		/// this fails, it will not remove any parent directories it already made.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CreateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			byte ret = CreateDirectoryNative(path);
			return ret != 0;
		}

		/// <summary>
		/// Create a directory, and any missing parent directories.<br/>
		/// This reports success if `path` already exists as a directory.<br/>
		/// If parent directories are missing, it will also create them. Note that if<br/>
		/// this fails, it will not remove any parent directories it already made.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CreateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = CreateDirectoryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a directory, and any missing parent directories.<br/>
		/// This reports success if `path` already exists as a directory.<br/>
		/// If parent directories are missing, it will also create them. Note that if<br/>
		/// this fails, it will not remove any parent directories it already made.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CreateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				byte ret = CreateDirectoryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a directory, and any missing parent directories.<br/>
		/// This reports success if `path` already exists as a directory.<br/>
		/// If parent directories are missing, it will also create them. Note that if<br/>
		/// this fails, it will not remove any parent directories it already made.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CreateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CreateDirectoryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte EnumerateDirectoryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, byte*, byte*, SDLEnumerationResult>, void*, byte>)funcTable[844])(path, callback, userdata);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)funcTable[844])((nint)path, (nint)callback, (nint)userdata);
			#endif
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = EnumerateDirectoryNative(path, callback, userdata);
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, callback, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* ppath = path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, callback, userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = EnumerateDirectoryNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte ret = EnumerateDirectoryNative(path, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			fixed (byte* ppath = path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = EnumerateDirectoryNative(pStr0, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = EnumerateDirectoryNative(path, callback, (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, callback, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* ppath = path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, callback, (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] delegate*<void*, byte*, byte*, SDLEnumerationResult> callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = EnumerateDirectoryNative(pStr0, callback, (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte ret = EnumerateDirectoryNative(path, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			return ret != 0;
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			fixed (byte* ppath = path)
			{
				byte ret = EnumerateDirectoryNative((byte*)ppath, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory through a callback function.<br/>
		/// This function provides every directory entry through an app-provided<br/>
		/// callback, called once for each directory entry, until all results have been<br/>
		/// provided or the callback returns either SDL_ENUM_SUCCESS or<br/>
		/// SDL_ENUM_FAILURE.<br/>
		/// This will return false if there was a system problem in general, or if a<br/>
		/// callback returns SDL_ENUM_FAILURE. A successful return means a callback<br/>
		/// returned SDL_ENUM_SUCCESS to halt enumeration, or all directory entries<br/>
		/// were enumerated.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnumerateDirectory")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool EnumerateDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_EnumerateDirectoryCallback")] SDLEnumerateDirectoryCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void *")] nint userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = EnumerateDirectoryNative(pStr0, (delegate*<void*, byte*, byte*, SDLEnumerationResult>)Utils.GetFunctionPointerForDelegate(callback), (void*)userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Remove a file or an empty directory.<br/>
		/// Directories that are not empty will fail; this function will not recursely<br/>
		/// delete directory trees.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemovePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RemovePathNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[845])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[845])((nint)path);
			#endif
		}

		/// <summary>
		/// Remove a file or an empty directory.<br/>
		/// Directories that are not empty will fail; this function will not recursely<br/>
		/// delete directory trees.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemovePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RemovePath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			byte ret = RemovePathNative(path);
			return ret != 0;
		}

		/// <summary>
		/// Remove a file or an empty directory.<br/>
		/// Directories that are not empty will fail; this function will not recursely<br/>
		/// delete directory trees.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemovePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RemovePath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = RemovePathNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Remove a file or an empty directory.<br/>
		/// Directories that are not empty will fail; this function will not recursely<br/>
		/// delete directory trees.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemovePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RemovePath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				byte ret = RemovePathNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Remove a file or an empty directory.<br/>
		/// Directories that are not empty will fail; this function will not recursely<br/>
		/// delete directory trees.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemovePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RemovePath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RemovePathNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenamePathNative([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)funcTable[846])(oldpath, newpath);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[846])((nint)oldpath, (nint)newpath);
			#endif
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			byte ret = RenamePathNative(oldpath, newpath);
			return ret != 0;
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] in byte oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			fixed (byte* poldpath = &oldpath)
			{
				byte ret = RenamePathNative((byte*)poldpath, newpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			fixed (byte* poldpath = oldpath)
			{
				byte ret = RenamePathNative((byte*)poldpath, newpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] string oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldpath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldpath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldpath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RenamePathNative(pStr0, newpath);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] in byte newpath)
		{
			fixed (byte* pnewpath = &newpath)
			{
				byte ret = RenamePathNative(oldpath, (byte*)pnewpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> newpath)
		{
			fixed (byte* pnewpath = newpath)
			{
				byte ret = RenamePathNative(oldpath, (byte*)pnewpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] string newpath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (newpath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(newpath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(newpath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = RenamePathNative(oldpath, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] in byte oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] in byte newpath)
		{
			fixed (byte* poldpath = &oldpath)
			{
				fixed (byte* pnewpath = &newpath)
				{
					byte ret = RenamePathNative((byte*)poldpath, (byte*)pnewpath);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> newpath)
		{
			fixed (byte* poldpath = oldpath)
			{
				fixed (byte* pnewpath = newpath)
				{
					byte ret = RenamePathNative((byte*)poldpath, (byte*)pnewpath);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Rename a file or directory.<br/>
		/// If the file at `newpath` already exists, it will be replaced.<br/>
		/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
		/// that is a much more complicated (and possibly time-consuming) operation.<br/>
		/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
		/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
		/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
		/// for files. Renaming a non-empty directory across filesystems is<br/>
		/// dramatically more complex, however.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenamePath")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RenamePath([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] string oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] string newpath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldpath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldpath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldpath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (newpath != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(newpath);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(newpath, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = RenamePathNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CopyFileNative([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)funcTable[847])(oldpath, newpath);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[847])((nint)oldpath, (nint)newpath);
			#endif
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			byte ret = CopyFileNative(oldpath, newpath);
			return ret != 0;
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] in byte oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			fixed (byte* poldpath = &oldpath)
			{
				byte ret = CopyFileNative((byte*)poldpath, newpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			fixed (byte* poldpath = oldpath)
			{
				byte ret = CopyFileNative((byte*)poldpath, newpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] string oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] byte* newpath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldpath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldpath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldpath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CopyFileNative(pStr0, newpath);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] in byte newpath)
		{
			fixed (byte* pnewpath = &newpath)
			{
				byte ret = CopyFileNative(oldpath, (byte*)pnewpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> newpath)
		{
			fixed (byte* pnewpath = newpath)
			{
				byte ret = CopyFileNative(oldpath, (byte*)pnewpath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] byte* oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] string newpath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (newpath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(newpath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(newpath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CopyFileNative(oldpath, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] in byte oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] in byte newpath)
		{
			fixed (byte* poldpath = &oldpath)
			{
				fixed (byte* pnewpath = &newpath)
				{
					byte ret = CopyFileNative((byte*)poldpath, (byte*)pnewpath);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> newpath)
		{
			fixed (byte* poldpath = oldpath)
			{
				fixed (byte* pnewpath = newpath)
				{
					byte ret = CopyFileNative((byte*)poldpath, (byte*)pnewpath);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a file.<br/>
		/// If the file at `newpath` already exists, it will be overwritten with the<br/>
		/// contents of the file at `oldpath`.<br/>
		/// This function will block until the copy is complete, which might be a<br/>
		/// significant time for large files on slow disks. On some platforms, the copy<br/>
		/// can be handed off to the OS itself, but on others SDL might just open both<br/>
		/// paths, and read from one and write to the other.<br/>
		/// Note that this is not an atomic operation! If something tries to read from<br/>
		/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
		/// the data, and if the calling thread terminates (or the power goes out)<br/>
		/// during the copy, `newpath`'s previous contents will be gone, replaced with<br/>
		/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
		/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
		/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
		/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
		/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
		/// This function attempts to synchronize the newly-copied data to disk before<br/>
		/// returning, if the platform allows it, so that the renaming trick will not<br/>
		/// have a problem in a system crash or power failure, where the file could be<br/>
		/// renamed but the contents never made it from the system file cache to the<br/>
		/// physical disk.<br/>
		/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
		/// might be half a copy, it might be the untouched data of what was already<br/>
		/// there, or it might be a zero-byte file, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread, but this<br/>
		/// operation is not atomic, so the app might need to protect<br/>
		/// access to specific paths from other threads if appropriate.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyFile")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CopyFile([NativeName(NativeNameType.Param, "oldpath")] [NativeName(NativeNameType.Type, "char const *")] string oldpath, [NativeName(NativeNameType.Param, "newpath")] [NativeName(NativeNameType.Type, "char const *")] string newpath)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldpath != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldpath);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldpath, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (newpath != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(newpath);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(newpath, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = CopyFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetPathInfoNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfo* info)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLPathInfo*, byte>)funcTable[848])(path, info);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[848])((nint)path, (nint)info);
			#endif
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfoPtr info)
		{
			byte ret = GetPathInfoNative(path, (SDLPathInfo*)info);
			return ret != 0;
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfoPtr info)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = GetPathInfoNative((byte*)ppath, (SDLPathInfo*)info);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfoPtr info)
		{
			fixed (byte* ppath = path)
			{
				byte ret = GetPathInfoNative((byte*)ppath, (SDLPathInfo*)info);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] SDLPathInfoPtr info)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GetPathInfoNative(pStr0, (SDLPathInfo*)info);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (SDLPathInfo* pinfo = &info)
			{
				byte ret = GetPathInfoNative(path, (SDLPathInfo*)pinfo);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (byte* ppath = &path)
			{
				fixed (SDLPathInfo* pinfo = &info)
				{
					byte ret = GetPathInfoNative((byte*)ppath, (SDLPathInfo*)pinfo);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			fixed (byte* ppath = path)
			{
				fixed (SDLPathInfo* pinfo = &info)
				{
					byte ret = GetPathInfoNative((byte*)ppath, (SDLPathInfo*)pinfo);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get information about a filesystem path.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPathInfo")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetPathInfo([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_PathInfo *")] ref SDLPathInfo info)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLPathInfo* pinfo = &info)
			{
				byte ret = GetPathInfoNative(pStr0, (SDLPathInfo*)pinfo);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GlobDirectoryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, uint, int*, byte**>)funcTable[849])(path, pattern, flags, count);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, nint>)funcTable[849])((nint)path, (nint)pattern, flags, (nint)count);
			#endif
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte** ret = GlobDirectoryNative(path, pattern, flags, count);
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = &path)
			{
				byte** ret = GlobDirectoryNative((byte*)ppath, pattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = path)
			{
				byte** ret = GlobDirectoryNative((byte*)ppath, pattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** ret = GlobDirectoryNative(pStr0, pattern, flags, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppattern = &pattern)
			{
				byte** ret = GlobDirectoryNative(path, (byte*)ppattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppattern = pattern)
			{
				byte** ret = GlobDirectoryNative(path, (byte*)ppattern, flags, count);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** ret = GlobDirectoryNative(path, pStr0, flags, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte* ppattern = &pattern)
				{
					byte** ret = GlobDirectoryNative((byte*)ppath, (byte*)ppattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte* ppattern = pattern)
				{
					byte** ret = GlobDirectoryNative((byte*)ppath, (byte*)ppattern, flags, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pattern != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pattern, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte** ret = GlobDirectoryNative(pStr0, pStr1, flags, count);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				byte** ret = GlobDirectoryNative(path, pattern, flags, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = &path)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobDirectoryNative((byte*)ppath, pattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = path)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobDirectoryNative((byte*)ppath, pattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] byte* pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobDirectoryNative(pStr0, pattern, flags, (int*)pcount);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppattern = &pattern)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobDirectoryNative(path, (byte*)ppattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppattern = pattern)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobDirectoryNative(path, (byte*)ppattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobDirectoryNative(path, pStr0, flags, (int*)pcount);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] in byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] in byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte* ppattern = &pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobDirectoryNative((byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte* ppattern = pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobDirectoryNative((byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters `*` (match everything) and `?` (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of `/`. Wildcard characters `*` and `?` never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] uint flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pattern != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pattern, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobDirectoryNative(pStr0, pStr1, flags, (int*)pcount);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get what the system believes is the "current working directory."<br/>
		/// For systems without a concept of a current working directory, this will<br/>
		/// still attempt to provide something reasonable.<br/>
		/// SDL does not provide a means to _change_ the current working directory; for<br/>
		/// platforms without this concept, this would cause surprises with file access<br/>
		/// outside of SDL.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDirectory")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCurrentDirectoryNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[850])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[850])();
			#endif
		}

		/// <summary>
		/// Get what the system believes is the "current working directory."<br/>
		/// For systems without a concept of a current working directory, this will<br/>
		/// still attempt to provide something reasonable.<br/>
		/// SDL does not provide a means to _change_ the current working directory; for<br/>
		/// platforms without this concept, this would cause surprises with file access<br/>
		/// outside of SDL.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDirectory")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetCurrentDirectory()
		{
			byte* ret = GetCurrentDirectoryNative();
			return ret;
		}

		/// <summary>
		/// Get what the system believes is the "current working directory."<br/>
		/// For systems without a concept of a current working directory, this will<br/>
		/// still attempt to provide something reasonable.<br/>
		/// SDL does not provide a means to _change_ the current working directory; for<br/>
		/// platforms without this concept, this would cause surprises with file access<br/>
		/// outside of SDL.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDirectory")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetCurrentDirectoryS()
		{
			string ret = Utils.DecodeStringUTF8(GetCurrentDirectoryNative());
			return ret;
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUSupportsShaderFormatsNative([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, byte>)funcTable[851])(formatFlags, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, nint, byte>)funcTable[851])(formatFlags, (nint)name);
			#endif
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = GPUSupportsShaderFormatsNative(formatFlags, name);
			return ret != 0;
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = GPUSupportsShaderFormatsNative(formatFlags, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = GPUSupportsShaderFormatsNative(formatFlags, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GPUSupportsShaderFormatsNative(formatFlags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUSupportsPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[852])(props);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[852])(props);
			#endif
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			byte ret = GPUSupportsPropertiesNative(props);
			return ret != 0;
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// The GPU driver name can be one of the following:<br/>
		/// - "vulkan": [Vulkan](CategoryGPU#vulkan)<br/>
		/// - "direct3d12": [D3D12](CategoryGPU#d3d12)<br/>
		/// - "metal": [Metal](CategoryGPU#metal)<br/>
		/// - NULL: let SDL pick the optimal driver<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUDevice* CreateGPUDeviceNative([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] byte debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte, byte*, SDLGPUDevice*>)funcTable[853])(formatFlags, debugMode, name);
			#else
			return (SDLGPUDevice*)((delegate* unmanaged[Cdecl]<uint, byte, nint, nint>)funcTable[853])(formatFlags, debugMode, (nint)name);
			#endif
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// The GPU driver name can be one of the following:<br/>
		/// - "vulkan": [Vulkan](CategoryGPU#vulkan)<br/>
		/// - "direct3d12": [D3D12](CategoryGPU#d3d12)<br/>
		/// - "metal": [Metal](CategoryGPU#metal)<br/>
		/// - NULL: let SDL pick the optimal driver<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevicePtr CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			SDLGPUDevicePtr ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, name);
			return ret;
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// The GPU driver name can be one of the following:<br/>
		/// - "vulkan": [Vulkan](CategoryGPU#vulkan)<br/>
		/// - "direct3d12": [D3D12](CategoryGPU#d3d12)<br/>
		/// - "metal": [Metal](CategoryGPU#metal)<br/>
		/// - NULL: let SDL pick the optimal driver<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevicePtr CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLGPUDevicePtr ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// The GPU driver name can be one of the following:<br/>
		/// - "vulkan": [Vulkan](CategoryGPU#vulkan)<br/>
		/// - "direct3d12": [D3D12](CategoryGPU#d3d12)<br/>
		/// - "metal": [Metal](CategoryGPU#metal)<br/>
		/// - NULL: let SDL pick the optimal driver<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevicePtr CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLGPUDevicePtr ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// The GPU driver name can be one of the following:<br/>
		/// - "vulkan": [Vulkan](CategoryGPU#vulkan)<br/>
		/// - "direct3d12": [D3D12](CategoryGPU#d3d12)<br/>
		/// - "metal": [Metal](CategoryGPU#metal)<br/>
		/// - NULL: let SDL pick the optimal driver<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevicePtr CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] uint formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGPUDevicePtr ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode<br/>
		/// properties and validations, defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer<br/>
		/// energy efficiency over maximum GPU performance, defaults to false.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_VERBOSE_BOOLEAN`: enable to automatically log<br/>
		/// useful debug information on device creation, defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to<br/>
		/// use, if a specific one is desired.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_CLIP_DISTANCE_BOOLEAN`: Enable Vulkan<br/>
		/// device feature shaderClipDistance. If disabled, clip distances are not<br/>
		/// supported in shader code: gl_ClipDistance[] built-ins of GLSL,<br/>
		/// SV_ClipDistance0/1 semantics of HLSL and [[clip_distance]] attribute of<br/>
		/// Metal. Disabling optional features allows the application to run on some<br/>
		/// older Android devices. Defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_DEPTH_CLAMPING_BOOLEAN`: Enable<br/>
		/// Vulkan device feature depthClamp. If disabled, there is no depth clamp<br/>
		/// support and enable_depth_clip in SDL_GPURasterizerState must always be<br/>
		/// set to true. Disabling optional features allows the application to run on<br/>
		/// some older Android devices. Defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_INDIRECT_DRAW_FIRST_INSTANCE_BOOLEAN`:<br/>
		/// Enable Vulkan device feature drawIndirectFirstInstance. If disabled, the<br/>
		/// argument first_instance of SDL_GPUIndirectDrawCommand must be set to<br/>
		/// zero. Disabling optional features allows the application to run on some<br/>
		/// older Android devices. Defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_ANISOTROPY_BOOLEAN`: Enable Vulkan<br/>
		/// device feature samplerAnisotropy. If disabled, enable_anisotropy of<br/>
		/// SDL_GPUSamplerCreateInfo must be set to false. Disabling optional<br/>
		/// features allows the application to run on some older Android devices.<br/>
		/// Defaults to true.<br/>
		/// These are the current shader format properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to<br/>
		/// provide shaders for an NDA platform.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to<br/>
		/// provide SPIR-V shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to<br/>
		/// provide DXBC shaders if applicable<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to<br/>
		/// provide DXIL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to<br/>
		/// provide MSL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to<br/>
		/// provide Metal shader libraries if applicable.<br/>
		/// With the D3D12 backend:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to<br/>
		/// use for all vertex semantics, default is "TEXCOORD".<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_ALLOW_FEWER_RESOURCE_SLOTS_BOOLEAN`: By<br/>
		/// default, Resourcing Binding Tier 2 is required for D3D12 support.<br/>
		/// However, an application can set this property to true to enable Tier 1<br/>
		/// support, if (and only if) the application uses 8 or fewer storage<br/>
		/// resources across all shader stages. As of writing, this property is<br/>
		/// useful for targeting Intel Haswell and Broadwell GPUs; other hardware<br/>
		/// either supports Tier 2 Resource Binding or does not support D3D12 in any<br/>
		/// capacity. Defaults to false.<br/>
		/// With the Vulkan backend:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_VULKAN_REQUIRE_HARDWARE_ACCELERATION_BOOLEAN`:<br/>
		/// By default, Vulkan device enumeration includes drivers of all types,<br/>
		/// including software renderers (for example, the Lavapipe Mesa driver).<br/>
		/// This can be useful if your application _requires_ SDL_GPU, but if you can<br/>
		/// provide your own fallback renderer (for example, an OpenGL renderer) this<br/>
		/// property can be set to true. Defaults to false.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_VULKAN_OPTIONS_POINTER`: a pointer to an<br/>
		/// SDL_GPUVulkanOptions structure to be processed during device creation.<br/>
		/// This allows configuring a variety of Vulkan-specific options such as<br/>
		/// increasing the API version and opting into extensions aside from the<br/>
		/// minimal set SDL requires.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDeviceWithProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUDevice* CreateGPUDeviceWithPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLGPUDevice*>)funcTable[854])(props);
			#else
			return (SDLGPUDevice*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[854])(props);
			#endif
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode<br/>
		/// properties and validations, defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer<br/>
		/// energy efficiency over maximum GPU performance, defaults to false.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_VERBOSE_BOOLEAN`: enable to automatically log<br/>
		/// useful debug information on device creation, defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to<br/>
		/// use, if a specific one is desired.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_CLIP_DISTANCE_BOOLEAN`: Enable Vulkan<br/>
		/// device feature shaderClipDistance. If disabled, clip distances are not<br/>
		/// supported in shader code: gl_ClipDistance[] built-ins of GLSL,<br/>
		/// SV_ClipDistance0/1 semantics of HLSL and [[clip_distance]] attribute of<br/>
		/// Metal. Disabling optional features allows the application to run on some<br/>
		/// older Android devices. Defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_DEPTH_CLAMPING_BOOLEAN`: Enable<br/>
		/// Vulkan device feature depthClamp. If disabled, there is no depth clamp<br/>
		/// support and enable_depth_clip in SDL_GPURasterizerState must always be<br/>
		/// set to true. Disabling optional features allows the application to run on<br/>
		/// some older Android devices. Defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_INDIRECT_DRAW_FIRST_INSTANCE_BOOLEAN`:<br/>
		/// Enable Vulkan device feature drawIndirectFirstInstance. If disabled, the<br/>
		/// argument first_instance of SDL_GPUIndirectDrawCommand must be set to<br/>
		/// zero. Disabling optional features allows the application to run on some<br/>
		/// older Android devices. Defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_FEATURE_ANISOTROPY_BOOLEAN`: Enable Vulkan<br/>
		/// device feature samplerAnisotropy. If disabled, enable_anisotropy of<br/>
		/// SDL_GPUSamplerCreateInfo must be set to false. Disabling optional<br/>
		/// features allows the application to run on some older Android devices.<br/>
		/// Defaults to true.<br/>
		/// These are the current shader format properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to<br/>
		/// provide shaders for an NDA platform.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to<br/>
		/// provide SPIR-V shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to<br/>
		/// provide DXBC shaders if applicable<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to<br/>
		/// provide DXIL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to<br/>
		/// provide MSL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to<br/>
		/// provide Metal shader libraries if applicable.<br/>
		/// With the D3D12 backend:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to<br/>
		/// use for all vertex semantics, default is "TEXCOORD".<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_ALLOW_FEWER_RESOURCE_SLOTS_BOOLEAN`: By<br/>
		/// default, Resourcing Binding Tier 2 is required for D3D12 support.<br/>
		/// However, an application can set this property to true to enable Tier 1<br/>
		/// support, if (and only if) the application uses 8 or fewer storage<br/>
		/// resources across all shader stages. As of writing, this property is<br/>
		/// useful for targeting Intel Haswell and Broadwell GPUs; other hardware<br/>
		/// either supports Tier 2 Resource Binding or does not support D3D12 in any<br/>
		/// capacity. Defaults to false.<br/>
		/// With the Vulkan backend:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_VULKAN_REQUIRE_HARDWARE_ACCELERATION_BOOLEAN`:<br/>
		/// By default, Vulkan device enumeration includes drivers of all types,<br/>
		/// including software renderers (for example, the Lavapipe Mesa driver).<br/>
		/// This can be useful if your application _requires_ SDL_GPU, but if you can<br/>
		/// provide your own fallback renderer (for example, an OpenGL renderer) this<br/>
		/// property can be set to true. Defaults to false.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_VULKAN_OPTIONS_POINTER`: a pointer to an<br/>
		/// SDL_GPUVulkanOptions structure to be processed during device creation.<br/>
		/// This allows configuring a variety of Vulkan-specific options such as<br/>
		/// increasing the API version and opting into extensions aside from the<br/>
		/// minimal set SDL requires.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDeviceWithProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevicePtr CreateGPUDeviceWithProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			SDLGPUDevicePtr ret = CreateGPUDeviceWithPropertiesNative(props);
			return ret;
		}

		/// <summary>
		/// Destroys a GPU context previously returned by SDL_CreateGPUDevice.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyGPUDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, void>)funcTable[855])(device);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[855])((nint)device);
			#endif
		}

		/// <summary>
		/// Destroys a GPU context previously returned by SDL_CreateGPUDevice.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device)
		{
			DestroyGPUDeviceNative((SDLGPUDevice*)device);
		}

		/// <summary>
		/// Destroys a GPU context previously returned by SDL_CreateGPUDevice.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				DestroyGPUDeviceNative((SDLGPUDevice*)pdevice);
			}
		}

		/// <summary>
		/// Get the number of GPU drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGPUDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGPUDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[856])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[856])();
			#endif
		}

		/// <summary>
		/// Get the number of GPU drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGPUDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGPUDrivers()
		{
			int ret = GetNumGPUDriversNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a built in GPU driver.<br/>
		/// The GPU drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",<br/>
		/// "metal" or "direct3d12". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGPUDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[857])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[857])(index);
			#endif
		}

		/// <summary>
		/// Get the name of a built in GPU driver.<br/>
		/// The GPU drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",<br/>
		/// "metal" or "direct3d12". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGPUDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = GetGPUDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Get the name of a built in GPU driver.<br/>
		/// The GPU drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",<br/>
		/// "metal" or "direct3d12". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGPUDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(GetGPUDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGPUDeviceDriverNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte*>)funcTable[858])(device);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[858])((nint)device);
			#endif
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGPUDeviceDriver([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device)
		{
			byte* ret = GetGPUDeviceDriverNative((SDLGPUDevice*)device);
			return ret;
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGPUDeviceDriverS([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device)
		{
			string ret = Utils.DecodeStringUTF8(GetGPUDeviceDriverNative((SDLGPUDevice*)device));
			return ret;
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGPUDeviceDriver([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte* ret = GetGPUDeviceDriverNative((SDLGPUDevice*)pdevice);
				return ret;
			}
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGPUDeviceDriverS([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				string ret = Utils.DecodeStringUTF8(GetGPUDeviceDriverNative((SDLGPUDevice*)pdevice));
				return ret;
			}
		}

		/// <summary>
		/// Returns the supported shader formats for this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUShaderFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGPUShaderFormatsNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, uint>)funcTable[859])(device);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[859])((nint)device);
			#endif
		}

		/// <summary>
		/// Returns the supported shader formats for this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUShaderFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")]
		public static uint GetGPUShaderFormats([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device)
		{
			uint ret = GetGPUShaderFormatsNative((SDLGPUDevice*)device);
			return ret;
		}

		/// <summary>
		/// Returns the supported shader formats for this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUShaderFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")]
		public static uint GetGPUShaderFormats([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				uint ret = GetGPUShaderFormatsNative((SDLGPUDevice*)pdevice);
				return ret;
			}
		}

		/// <summary>
		/// Get the properties associated with a GPU device.<br/>
		/// All properties are optional and may differ between GPU backends and SDL<br/>
		/// versions.<br/>
		/// The following properties are provided by SDL:<br/>
		/// `SDL_PROP_GPU_DEVICE_NAME_STRING`: Contains the name of the underlying<br/>
		/// device as reported by the system driver. This string has no standardized<br/>
		/// format, is highly inconsistent between hardware devices and drivers, and is<br/>
		/// able to change at any time. Do not attempt to parse this string as it is<br/>
		/// bound to fail at some point in the future when system drivers are updated,<br/>
		/// new hardware devices are introduced, or when SDL adds new GPU backends or<br/>
		/// modifies existing ones.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - GTX 970<br/>
		/// - GeForce GTX 970<br/>
		/// - NVIDIA GeForce GTX 970<br/>
		/// - Microsoft Direct3D12 (NVIDIA GeForce GTX 970)<br/>
		/// - NVIDIA Graphics Device<br/>
		/// - GeForce GPU<br/>
		/// - P106-100<br/>
		/// - AMD 15D8:C9<br/>
		/// - AMD Custom GPU 0405<br/>
		/// - AMD Radeon (TM) Graphics<br/>
		/// - ASUS Radeon RX 470 Series<br/>
		/// - Intel(R) Arc(tm) A380 Graphics (DG2)<br/>
		/// - Virtio-GPU Venus (NVIDIA TITAN V)<br/>
		/// - SwiftShader Device (LLVM 16.0.0)<br/>
		/// - llvmpipe (LLVM 15.0.4, 256 bits)<br/>
		/// - Microsoft Basic Render Driver<br/>
		/// - unknown device<br/>
		/// The above list shows that the same device can have different formats, the<br/>
		/// vendor name may or may not appear in the string, the included vendor name<br/>
		/// may not be the vendor of the chipset on the device, some manufacturers<br/>
		/// include pseudo-legal marks while others don't, some devices may not use a<br/>
		/// marketing name in the string, the device string may be wrapped by the name<br/>
		/// of a translation interface, the device may be emulated in software, or the<br/>
		/// string may contain generic text that does not identify the device at all.<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_NAME_STRING`: Contains the self-reported name<br/>
		/// of the underlying system driver.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - Intel Corporation<br/>
		/// - Intel open-source Mesa driver<br/>
		/// - Qualcomm Technologies Inc. Adreno Vulkan Driver<br/>
		/// - MoltenVK<br/>
		/// - Mali-G715<br/>
		/// - venus<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING`: Contains the self-reported<br/>
		/// version of the underlying system driver. This is a relatively short version<br/>
		/// string in an unspecified format. If SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING<br/>
		/// is available then that property should be preferred over this one as it may<br/>
		/// contain additional information that is useful for identifying the exact<br/>
		/// driver version used.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - 53.0.0<br/>
		/// - 0.405.2463<br/>
		/// - 32.0.15.6614<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING`: Contains the detailed version<br/>
		/// information of the underlying system driver as reported by the driver. This<br/>
		/// is an arbitrary string with no standardized format and it may contain<br/>
		/// newlines. This property should be preferred over<br/>
		/// SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING if it is available as it usually<br/>
		/// contains the same information but in a format that is easier to read.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - 101.6559<br/>
		/// - 1.2.11<br/>
		/// - Mesa 21.2.2 (LLVM 12.0.1)<br/>
		/// - Mesa 22.2.0-devel (git-f226222 2022-04-14 impish-oibaf-ppa)<br/>
		/// - v1.r53p0-00eac0.824c4f31403fb1fbf8ee1042422c2129<br/>
		/// This string has also been observed to be a multiline string (which has a<br/>
		/// trailing newline):<br/>
		/// ```<br/>
		/// Driver Build: 85da404, I46ff5fc46f, 1606794520<br/>
		/// Date: 11/30/20<br/>
		/// Compiler Version: EV031.31.04.01<br/>
		/// Driver Branch: promo490_3_Google<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetGPUDevicePropertiesNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, uint>)funcTable[860])(device);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[860])((nint)device);
			#endif
		}

		/// <summary>
		/// Get the properties associated with a GPU device.<br/>
		/// All properties are optional and may differ between GPU backends and SDL<br/>
		/// versions.<br/>
		/// The following properties are provided by SDL:<br/>
		/// `SDL_PROP_GPU_DEVICE_NAME_STRING`: Contains the name of the underlying<br/>
		/// device as reported by the system driver. This string has no standardized<br/>
		/// format, is highly inconsistent between hardware devices and drivers, and is<br/>
		/// able to change at any time. Do not attempt to parse this string as it is<br/>
		/// bound to fail at some point in the future when system drivers are updated,<br/>
		/// new hardware devices are introduced, or when SDL adds new GPU backends or<br/>
		/// modifies existing ones.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - GTX 970<br/>
		/// - GeForce GTX 970<br/>
		/// - NVIDIA GeForce GTX 970<br/>
		/// - Microsoft Direct3D12 (NVIDIA GeForce GTX 970)<br/>
		/// - NVIDIA Graphics Device<br/>
		/// - GeForce GPU<br/>
		/// - P106-100<br/>
		/// - AMD 15D8:C9<br/>
		/// - AMD Custom GPU 0405<br/>
		/// - AMD Radeon (TM) Graphics<br/>
		/// - ASUS Radeon RX 470 Series<br/>
		/// - Intel(R) Arc(tm) A380 Graphics (DG2)<br/>
		/// - Virtio-GPU Venus (NVIDIA TITAN V)<br/>
		/// - SwiftShader Device (LLVM 16.0.0)<br/>
		/// - llvmpipe (LLVM 15.0.4, 256 bits)<br/>
		/// - Microsoft Basic Render Driver<br/>
		/// - unknown device<br/>
		/// The above list shows that the same device can have different formats, the<br/>
		/// vendor name may or may not appear in the string, the included vendor name<br/>
		/// may not be the vendor of the chipset on the device, some manufacturers<br/>
		/// include pseudo-legal marks while others don't, some devices may not use a<br/>
		/// marketing name in the string, the device string may be wrapped by the name<br/>
		/// of a translation interface, the device may be emulated in software, or the<br/>
		/// string may contain generic text that does not identify the device at all.<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_NAME_STRING`: Contains the self-reported name<br/>
		/// of the underlying system driver.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - Intel Corporation<br/>
		/// - Intel open-source Mesa driver<br/>
		/// - Qualcomm Technologies Inc. Adreno Vulkan Driver<br/>
		/// - MoltenVK<br/>
		/// - Mali-G715<br/>
		/// - venus<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING`: Contains the self-reported<br/>
		/// version of the underlying system driver. This is a relatively short version<br/>
		/// string in an unspecified format. If SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING<br/>
		/// is available then that property should be preferred over this one as it may<br/>
		/// contain additional information that is useful for identifying the exact<br/>
		/// driver version used.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - 53.0.0<br/>
		/// - 0.405.2463<br/>
		/// - 32.0.15.6614<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING`: Contains the detailed version<br/>
		/// information of the underlying system driver as reported by the driver. This<br/>
		/// is an arbitrary string with no standardized format and it may contain<br/>
		/// newlines. This property should be preferred over<br/>
		/// SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING if it is available as it usually<br/>
		/// contains the same information but in a format that is easier to read.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - 101.6559<br/>
		/// - 1.2.11<br/>
		/// - Mesa 21.2.2 (LLVM 12.0.1)<br/>
		/// - Mesa 22.2.0-devel (git-f226222 2022-04-14 impish-oibaf-ppa)<br/>
		/// - v1.r53p0-00eac0.824c4f31403fb1fbf8ee1042422c2129<br/>
		/// This string has also been observed to be a multiline string (which has a<br/>
		/// trailing newline):<br/>
		/// ```<br/>
		/// Driver Build: 85da404, I46ff5fc46f, 1606794520<br/>
		/// Date: 11/30/20<br/>
		/// Compiler Version: EV031.31.04.01<br/>
		/// Driver Branch: promo490_3_Google<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetGPUDeviceProperties([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device)
		{
			uint ret = GetGPUDevicePropertiesNative((SDLGPUDevice*)device);
			return ret;
		}

		/// <summary>
		/// Get the properties associated with a GPU device.<br/>
		/// All properties are optional and may differ between GPU backends and SDL<br/>
		/// versions.<br/>
		/// The following properties are provided by SDL:<br/>
		/// `SDL_PROP_GPU_DEVICE_NAME_STRING`: Contains the name of the underlying<br/>
		/// device as reported by the system driver. This string has no standardized<br/>
		/// format, is highly inconsistent between hardware devices and drivers, and is<br/>
		/// able to change at any time. Do not attempt to parse this string as it is<br/>
		/// bound to fail at some point in the future when system drivers are updated,<br/>
		/// new hardware devices are introduced, or when SDL adds new GPU backends or<br/>
		/// modifies existing ones.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - GTX 970<br/>
		/// - GeForce GTX 970<br/>
		/// - NVIDIA GeForce GTX 970<br/>
		/// - Microsoft Direct3D12 (NVIDIA GeForce GTX 970)<br/>
		/// - NVIDIA Graphics Device<br/>
		/// - GeForce GPU<br/>
		/// - P106-100<br/>
		/// - AMD 15D8:C9<br/>
		/// - AMD Custom GPU 0405<br/>
		/// - AMD Radeon (TM) Graphics<br/>
		/// - ASUS Radeon RX 470 Series<br/>
		/// - Intel(R) Arc(tm) A380 Graphics (DG2)<br/>
		/// - Virtio-GPU Venus (NVIDIA TITAN V)<br/>
		/// - SwiftShader Device (LLVM 16.0.0)<br/>
		/// - llvmpipe (LLVM 15.0.4, 256 bits)<br/>
		/// - Microsoft Basic Render Driver<br/>
		/// - unknown device<br/>
		/// The above list shows that the same device can have different formats, the<br/>
		/// vendor name may or may not appear in the string, the included vendor name<br/>
		/// may not be the vendor of the chipset on the device, some manufacturers<br/>
		/// include pseudo-legal marks while others don't, some devices may not use a<br/>
		/// marketing name in the string, the device string may be wrapped by the name<br/>
		/// of a translation interface, the device may be emulated in software, or the<br/>
		/// string may contain generic text that does not identify the device at all.<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_NAME_STRING`: Contains the self-reported name<br/>
		/// of the underlying system driver.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - Intel Corporation<br/>
		/// - Intel open-source Mesa driver<br/>
		/// - Qualcomm Technologies Inc. Adreno Vulkan Driver<br/>
		/// - MoltenVK<br/>
		/// - Mali-G715<br/>
		/// - venus<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING`: Contains the self-reported<br/>
		/// version of the underlying system driver. This is a relatively short version<br/>
		/// string in an unspecified format. If SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING<br/>
		/// is available then that property should be preferred over this one as it may<br/>
		/// contain additional information that is useful for identifying the exact<br/>
		/// driver version used.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - 53.0.0<br/>
		/// - 0.405.2463<br/>
		/// - 32.0.15.6614<br/>
		/// `SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING`: Contains the detailed version<br/>
		/// information of the underlying system driver as reported by the driver. This<br/>
		/// is an arbitrary string with no standardized format and it may contain<br/>
		/// newlines. This property should be preferred over<br/>
		/// SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING if it is available as it usually<br/>
		/// contains the same information but in a format that is easier to read.<br/>
		/// Strings that have been found in the wild include:<br/>
		/// - 101.6559<br/>
		/// - 1.2.11<br/>
		/// - Mesa 21.2.2 (LLVM 12.0.1)<br/>
		/// - Mesa 22.2.0-devel (git-f226222 2022-04-14 impish-oibaf-ppa)<br/>
		/// - v1.r53p0-00eac0.824c4f31403fb1fbf8ee1042422c2129<br/>
		/// This string has also been observed to be a multiline string (which has a<br/>
		/// trailing newline):<br/>
		/// ```<br/>
		/// Driver Build: 85da404, I46ff5fc46f, 1606794520<br/>
		/// Date: 11/30/20<br/>
		/// Compiler Version: EV031.31.04.01<br/>
		/// Driver Branch: promo490_3_Google<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_PropertiesID")]
		public static uint GetGPUDeviceProperties([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				uint ret = GetGPUDevicePropertiesNative((SDLGPUDevice*)pdevice);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUComputePipeline* CreateGPUComputePipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUComputePipelineCreateInfo*, SDLGPUComputePipeline*>)funcTable[861])(device, createinfo);
			#else
			return (SDLGPUComputePipeline*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[861])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipelinePtr CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfoPtr createinfo)
		{
			SDLGPUComputePipelinePtr ret = CreateGPUComputePipelineNative((SDLGPUDevice*)device, (SDLGPUComputePipelineCreateInfo*)createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipelinePtr CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfoPtr createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUComputePipelinePtr ret = CreateGPUComputePipelineNative((SDLGPUDevice*)pdevice, (SDLGPUComputePipelineCreateInfo*)createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipelinePtr CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevicePtr device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] in SDLGPUComputePipelineCreateInfo createinfo)
		{
			fixed (SDLGPUComputePipelineCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUComputePipelinePtr ret = CreateGPUComputePipelineNative((SDLGPUDevice*)device, (SDLGPUComputePipelineCreateInfo*)pcreateinfo);
				return ret;
			}
		}
	}
}
