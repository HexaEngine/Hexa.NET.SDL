// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Set the blend mode used for drawing operations (Fill and Line).<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetRenderDrawBlendModeNative(SDLRenderer* renderer, SDLBlendMode blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBlendMode, byte>)funcTable[1091])(renderer, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLBlendMode, byte>)funcTable[1091])((nint)renderer, blendMode);
			#endif
		}

		/// <summary>
		/// Set the blend mode used for drawing operations (Fill and Line).<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderDrawBlendMode(SDLRenderer* renderer, SDLBlendMode blendMode)
		{
			byte ret = SetRenderDrawBlendModeNative(renderer, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Set the blend mode used for drawing operations (Fill and Line).<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetRenderDrawBlendMode(ref SDLRenderer renderer, SDLBlendMode blendMode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = SetRenderDrawBlendModeNative((SDLRenderer*)prenderer, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for drawing operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRenderDrawBlendModeNative(SDLRenderer* renderer, SDLBlendMode* blendMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLBlendMode*, byte>)funcTable[1092])(renderer, blendMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1092])((nint)renderer, (nint)blendMode);
			#endif
		}

		/// <summary>
		/// Get the blend mode used for drawing operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawBlendMode(SDLRenderer* renderer, SDLBlendMode* blendMode)
		{
			byte ret = GetRenderDrawBlendModeNative(renderer, blendMode);
			return ret != 0;
		}

		/// <summary>
		/// Get the blend mode used for drawing operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawBlendMode(ref SDLRenderer renderer, SDLBlendMode* blendMode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = GetRenderDrawBlendModeNative((SDLRenderer*)prenderer, blendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for drawing operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawBlendMode(SDLRenderer* renderer, ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				byte ret = GetRenderDrawBlendModeNative(renderer, (SDLBlendMode*)pblendMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the blend mode used for drawing operations.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GetRenderDrawBlendMode(ref SDLRenderer renderer, ref SDLBlendMode blendMode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					byte ret = GetRenderDrawBlendModeNative((SDLRenderer*)prenderer, (SDLBlendMode*)pblendMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Clear the current rendering target with the drawing color.<br/>
		/// This function clears the entire rendering target, ignoring the viewport and<br/>
		/// the clip rectangle. Note, that clearing will also set/fill all pixels of<br/>
		/// the rendering target to current renderer draw color, so make sure to invoke<br/>
		/// SDL_SetRenderDrawColor() when needed.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderClearNative(SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte>)funcTable[1093])(renderer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1093])((nint)renderer);
			#endif
		}

		/// <summary>
		/// Clear the current rendering target with the drawing color.<br/>
		/// This function clears the entire rendering target, ignoring the viewport and<br/>
		/// the clip rectangle. Note, that clearing will also set/fill all pixels of<br/>
		/// the rendering target to current renderer draw color, so make sure to invoke<br/>
		/// SDL_SetRenderDrawColor() when needed.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderClear(SDLRenderer* renderer)
		{
			byte ret = RenderClearNative(renderer);
			return ret != 0;
		}

		/// <summary>
		/// Clear the current rendering target with the drawing color.<br/>
		/// This function clears the entire rendering target, ignoring the viewport and<br/>
		/// the clip rectangle. Note, that clearing will also set/fill all pixels of<br/>
		/// the rendering target to current renderer draw color, so make sure to invoke<br/>
		/// SDL_SetRenderDrawColor() when needed.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderClear(ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderClearNative((SDLRenderer*)prenderer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderPointNative(SDLRenderer* renderer, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, byte>)funcTable[1094])(renderer, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, byte>)funcTable[1094])((nint)renderer, x, y);
			#endif
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderPoint(SDLRenderer* renderer, float x, float y)
		{
			byte ret = RenderPointNative(renderer, x, y);
			return ret != 0;
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderPoint(ref SDLRenderer renderer, float x, float y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderPointNative((SDLRenderer*)prenderer, x, y);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderPointsNative(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFPoint*, int, byte>)funcTable[1095])(renderer, points, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[1095])((nint)renderer, (nint)points, count);
			#endif
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderPoints(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			byte ret = RenderPointsNative(renderer, points, count);
			return ret != 0;
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderPoints(ref SDLRenderer renderer, SDLFPoint* points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderPointsNative((SDLRenderer*)prenderer, points, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderPoints(SDLRenderer* renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				byte ret = RenderPointsNative(renderer, (SDLFPoint*)ppoints, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderPoints(ref SDLRenderer renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					byte ret = RenderPointsNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderLineNative(SDLRenderer* renderer, float x1, float y1, float x2, float y2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, float, float, byte>)funcTable[1096])(renderer, x1, y1, x2, y2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, byte>)funcTable[1096])((nint)renderer, x1, y1, x2, y2);
			#endif
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderLine(SDLRenderer* renderer, float x1, float y1, float x2, float y2)
		{
			byte ret = RenderLineNative(renderer, x1, y1, x2, y2);
			return ret != 0;
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderLine(ref SDLRenderer renderer, float x1, float y1, float x2, float y2)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderLineNative((SDLRenderer*)prenderer, x1, y1, x2, y2);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderLinesNative(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFPoint*, int, byte>)funcTable[1097])(renderer, points, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[1097])((nint)renderer, (nint)points, count);
			#endif
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderLines(SDLRenderer* renderer, SDLFPoint* points, int count)
		{
			byte ret = RenderLinesNative(renderer, points, count);
			return ret != 0;
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderLines(ref SDLRenderer renderer, SDLFPoint* points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderLinesNative((SDLRenderer*)prenderer, points, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderLines(SDLRenderer* renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				byte ret = RenderLinesNative(renderer, (SDLFPoint*)ppoints, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderLines(ref SDLRenderer renderer, ref SDLFPoint points, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					byte ret = RenderLinesNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderRectNative(SDLRenderer* renderer, SDLFRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, byte>)funcTable[1098])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1098])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRect(SDLRenderer* renderer, SDLFRect* rect)
		{
			byte ret = RenderRectNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRect(ref SDLRenderer renderer, SDLFRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderRectNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRect(SDLRenderer* renderer, ref SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				byte ret = RenderRectNative(renderer, (SDLFRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRect(ref SDLRenderer renderer, ref SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					byte ret = RenderRectNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderRectsNative(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int, byte>)funcTable[1099])(renderer, rects, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[1099])((nint)renderer, (nint)rects, count);
			#endif
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRects(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			byte ret = RenderRectsNative(renderer, rects, count);
			return ret != 0;
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRects(ref SDLRenderer renderer, SDLFRect* rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderRectsNative((SDLRenderer*)prenderer, rects, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRects(SDLRenderer* renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				byte ret = RenderRectsNative(renderer, (SDLFRect*)prects, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderRects(ref SDLRenderer renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					byte ret = RenderRectsNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderFillRectNative(SDLRenderer* renderer, SDLFRect* rect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, byte>)funcTable[1100])(renderer, rect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1100])((nint)renderer, (nint)rect);
			#endif
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRect(SDLRenderer* renderer, SDLFRect* rect)
		{
			byte ret = RenderFillRectNative(renderer, rect);
			return ret != 0;
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRect(ref SDLRenderer renderer, SDLFRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderFillRectNative((SDLRenderer*)prenderer, rect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRect(SDLRenderer* renderer, ref SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				byte ret = RenderFillRectNative(renderer, (SDLFRect*)prect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRect(ref SDLRenderer renderer, ref SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					byte ret = RenderFillRectNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderFillRectsNative(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLFRect*, int, byte>)funcTable[1101])(renderer, rects, count);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[1101])((nint)renderer, (nint)rects, count);
			#endif
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRects(SDLRenderer* renderer, SDLFRect* rects, int count)
		{
			byte ret = RenderFillRectsNative(renderer, rects, count);
			return ret != 0;
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRects(ref SDLRenderer renderer, SDLFRect* rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderFillRectsNative((SDLRenderer*)prenderer, rects, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRects(SDLRenderer* renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				byte ret = RenderFillRectsNative(renderer, (SDLFRect*)prects, count);
				return ret != 0;
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderFillRects(ref SDLRenderer renderer, ref SDLFRect rects, int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					byte ret = RenderFillRectsNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderTextureNative(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLFRect*, SDLFRect*, byte>)funcTable[1102])(renderer, texture, srcrect, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, byte>)funcTable[1102])((nint)renderer, (nint)texture, (nint)srcrect, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect)
		{
			byte ret = RenderTextureNative(renderer, texture, srcrect, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderTextureNative((SDLRenderer*)prenderer, texture, srcrect, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = RenderTextureNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = RenderTextureNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				byte ret = RenderTextureNative(renderer, texture, (SDLFRect*)psrcrect, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						byte ret = RenderTextureNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				byte ret = RenderTextureNative(renderer, texture, srcrect, (SDLFRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureNative(renderer, texture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							byte ret = RenderTextureNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderTextureRotatedNative(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLFRect*, SDLFRect*, double, SDLFPoint*, SDLFlipMode, byte>)funcTable[1103])(renderer, texture, srcrect, dstrect, angle, center, flip);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, double, nint, SDLFlipMode, byte>)funcTable[1103])((nint)renderer, (nint)texture, (nint)srcrect, (nint)dstrect, angle, (nint)center, flip);
			#endif
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			byte ret = RenderTextureRotatedNative(renderer, texture, srcrect, dstrect, angle, center, flip);
			return ret != 0;
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, center, flip);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				byte ret = RenderTextureRotatedNative(renderer, texture, (SDLFRect*)psrcrect, dstrect, angle, center, flip);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, dstrect, angle, center, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, dstrect, angle, center, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, dstrect, angle, center, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				byte ret = RenderTextureRotatedNative(renderer, texture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureRotatedNative(renderer, texture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, SDLFPoint* center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLFPoint* pcenter = &center)
			{
				byte ret = RenderTextureRotatedNative(renderer, texture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					byte ret = RenderTextureRotatedNative(renderer, texture, (SDLFRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFRect* dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					byte ret = RenderTextureRotatedNative(renderer, texture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						byte ret = RenderTextureRotatedNative(renderer, texture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							byte ret = RenderTextureRotatedNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureRotated(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFRect dstrect, double angle, ref SDLFPoint center, SDLFlipMode flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							fixed (SDLFPoint* pcenter = &center)
							{
								byte ret = RenderTextureRotatedNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderTextureAffineNative(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLFRect*, SDLFPoint*, SDLFPoint*, SDLFPoint*, byte>)funcTable[1104])(renderer, texture, srcrect, origin, right, down);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint, byte>)funcTable[1104])((nint)renderer, (nint)texture, (nint)srcrect, (nint)origin, (nint)right, (nint)down);
			#endif
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			byte ret = RenderTextureAffineNative(renderer, texture, srcrect, origin, right, down);
			return ret != 0;
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, origin, right, down);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, origin, right, down);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, origin, right, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, origin, right, down);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, origin, right, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, right, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, right, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLFPoint* porigin = &origin)
			{
				byte ret = RenderTextureAffineNative(renderer, texture, srcrect, (SDLFPoint*)porigin, right, down);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFPoint*)porigin, right, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, right, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, right, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* porigin = &origin)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, down);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLFPoint* pright = &right)
			{
				byte ret = RenderTextureAffineNative(renderer, texture, srcrect, origin, (SDLFPoint*)pright, down);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* pright = &right)
				{
					byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, origin, (SDLFPoint*)pright, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* pright = &right)
				{
					byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, origin, (SDLFPoint*)pright, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* pright = &right)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, origin, (SDLFPoint*)pright, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* pright = &right)
				{
					byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pright = &right)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pright = &right)
					{
						byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* pright = &right)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, down);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLFPoint* porigin = &origin)
			{
				fixed (SDLFPoint* pright = &right)
				{
					byte ret = RenderTextureAffineNative(renderer, texture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pright = &right)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pright = &right)
					{
						byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pright = &right)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pright = &right)
					{
						byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pright = &right)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pright = &right)
						{
							byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, SDLFPoint* down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* porigin = &origin)
						{
							fixed (SDLFPoint* pright = &right)
							{
								byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, down);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLFPoint* pdown = &down)
			{
				byte ret = RenderTextureAffineNative(renderer, texture, srcrect, origin, right, (SDLFPoint*)pdown);
				return ret != 0;
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* pdown = &down)
				{
					byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, origin, right, (SDLFPoint*)pdown);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* pdown = &down)
				{
					byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, origin, right, (SDLFPoint*)pdown);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, origin, right, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* pdown = &down)
				{
					byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, origin, right, (SDLFPoint*)pdown);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, origin, right, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, right, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, right, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLFPoint* porigin = &origin)
			{
				fixed (SDLFPoint* pdown = &down)
				{
					byte ret = RenderTextureAffineNative(renderer, texture, srcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, SDLFPoint* right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* porigin = &origin)
						{
							fixed (SDLFPoint* pdown = &down)
							{
								byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, right, (SDLFPoint*)pdown);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLFPoint* pright = &right)
			{
				fixed (SDLFPoint* pdown = &down)
				{
					byte ret = RenderTextureAffineNative(renderer, texture, srcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* pright = &right)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* pright = &right)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* pright = &right)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* pright = &right)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pright = &right)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pright = &right)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, SDLFPoint* origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* pright = &right)
						{
							fixed (SDLFPoint* pdown = &down)
							{
								byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, origin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLFPoint* porigin = &origin)
			{
				fixed (SDLFPoint* pright = &right)
				{
					fixed (SDLFPoint* pdown = &down)
					{
						byte ret = RenderTextureAffineNative(renderer, texture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pright = &right)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pright = &right)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pright = &right)
						{
							fixed (SDLFPoint* pdown = &down)
							{
								byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* porigin = &origin)
				{
					fixed (SDLFPoint* pright = &right)
					{
						fixed (SDLFPoint* pdown = &down)
						{
							byte ret = RenderTextureAffineNative(renderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pright = &right)
						{
							fixed (SDLFPoint* pdown = &down)
							{
								byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* porigin = &origin)
					{
						fixed (SDLFPoint* pright = &right)
						{
							fixed (SDLFPoint* pdown = &down)
							{
								byte ret = RenderTextureAffineNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// affine transform, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureAffine(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, ref SDLFPoint origin, ref SDLFPoint right, ref SDLFPoint down)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* porigin = &origin)
						{
							fixed (SDLFPoint* pright = &right)
							{
								fixed (SDLFPoint* pdown = &down)
								{
									byte ret = RenderTextureAffineNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, (SDLFPoint*)porigin, (SDLFPoint*)pright, (SDLFPoint*)pdown);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderTextureTiledNative(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, float scale, SDLFRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLFRect*, float, SDLFRect*, byte>)funcTable[1105])(renderer, texture, srcrect, scale, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, float, nint, byte>)funcTable[1105])((nint)renderer, (nint)texture, (nint)srcrect, scale, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, float scale, SDLFRect* dstrect)
		{
			byte ret = RenderTextureTiledNative(renderer, texture, srcrect, scale, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, texture, srcrect, scale, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, float scale, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = RenderTextureTiledNative(renderer, (SDLTexture*)ptexture, srcrect, scale, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, scale, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, float scale, SDLFRect* dstrect)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				byte ret = RenderTextureTiledNative(renderer, texture, (SDLFRect*)psrcrect, scale, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, scale, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, float scale, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTextureTiledNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, scale, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, scale, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				byte ret = RenderTextureTiledNative(renderer, texture, srcrect, scale, (SDLFRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, texture, srcrect, scale, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureTiledNative(renderer, (SDLTexture*)ptexture, srcrect, scale, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, scale, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTextureTiledNative(renderer, texture, (SDLFRect*)psrcrect, scale, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, scale, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTextureTiledNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, scale, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Tile a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
		/// completely fill `dstrect`.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTextureTiled(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							byte ret = RenderTextureTiledNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, scale, (SDLFRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderTexture9GridNative(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLFRect*, float, float, float, float, float, SDLFRect*, byte>)funcTable[1106])(renderer, texture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, float, float, float, float, float, nint, byte>)funcTable[1106])((nint)renderer, (nint)texture, (nint)srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (nint)dstrect);
			#endif
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			byte ret = RenderTexture9GridNative(renderer, texture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
			return ret != 0;
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, texture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = RenderTexture9GridNative(renderer, (SDLTexture*)ptexture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				byte ret = RenderTexture9GridNative(renderer, texture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					byte ret = RenderTexture9GridNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, dstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, SDLTexture* texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				byte ret = RenderTexture9GridNative(renderer, texture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, SDLTexture* texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, texture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, ref SDLTexture texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTexture9GridNative(renderer, (SDLTexture*)ptexture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, ref SDLTexture texture, SDLFRect* srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, SDLTexture* texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLFRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					byte ret = RenderTexture9GridNative(renderer, texture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, SDLTexture* texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, texture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(SDLRenderer* renderer, ref SDLTexture texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						byte ret = RenderTexture9GridNative(renderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
		/// target at subpixel precision.<br/>
		/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
		/// corner sizes for each corner, and the sides and center making up the<br/>
		/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
		/// the corners of the destination rectangle. The sides and center are then<br/>
		/// stretched into place to cover the remaining destination rectangle.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderTexture9Grid(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLFRect srcrect, float leftWidth, float rightWidth, float topHeight, float bottomHeight, float scale, ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							byte ret = RenderTexture9GridNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLFRect*)psrcrect, leftWidth, rightWidth, topHeight, bottomHeight, scale, (SDLFRect*)pdstrect);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderGeometryNative(SDLRenderer* renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, SDLVertex*, int, int*, int, byte>)funcTable[1107])(renderer, texture, vertices, numVertices, indices, numIndices);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, byte>)funcTable[1107])((nint)renderer, (nint)texture, (nint)vertices, numVertices, (nint)indices, numIndices);
			#endif
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			byte ret = RenderGeometryNative(renderer, texture, vertices, numVertices, indices, numIndices);
			return ret != 0;
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, vertices, numVertices, indices, numIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, vertices, numVertices, indices, numIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, vertices, numVertices, indices, numIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				byte ret = RenderGeometryNative(renderer, texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					byte ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					byte ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, int* indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						byte ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (int* pindices = &indices)
			{
				byte ret = RenderGeometryNative(renderer, texture, vertices, numVertices, (int*)pindices, numIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pindices = &indices)
				{
					byte ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, vertices, numVertices, (int*)pindices, numIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pindices = &indices)
				{
					byte ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, vertices, numVertices, (int*)pindices, numIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, SDLVertex* vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (int* pindices = &indices)
					{
						byte ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, vertices, numVertices, (int*)pindices, numIndices);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				fixed (int* pindices = &indices)
				{
					byte ret = RenderGeometryNative(renderer, texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, SDLTexture* texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						byte ret = RenderGeometryNative((SDLRenderer*)prenderer, texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(SDLRenderer* renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						byte ret = RenderGeometryNative(renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometry(ref SDLRenderer renderer, ref SDLTexture texture, ref SDLVertex vertices, int numVertices, ref int indices, int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						fixed (int* pindices = &indices)
						{
							byte ret = RenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RenderGeometryRawNative(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLTexture*, float*, int, SDLFColor*, int, float*, int, int, void*, int, int, byte>)funcTable[1108])(renderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int, int, nint, int, int, byte>)funcTable[1108])((nint)renderer, (nint)texture, (nint)xy, xyStride, (nint)color, colorStride, (nint)uv, uvStride, numVertices, (nint)indices, numIndices, sizeIndices);
			#endif
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			byte ret = RenderGeometryRawNative(renderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
			return ret != 0;
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, float* xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, float* xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				byte ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					byte ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, ref float xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				byte ret = RenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, ref float xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					byte ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, ref float xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					byte ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, ref float xy, int xyStride, SDLFColor* color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						byte ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, float* xy, int xyStride, ref SDLFColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLFColor* pcolor = &color)
			{
				byte ret = RenderGeometryRawNative(renderer, texture, xy, xyStride, (SDLFColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret != 0;
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, float* xy, int xyStride, ref SDLFColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFColor* pcolor = &color)
				{
					byte ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, (SDLFColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(SDLRenderer* renderer, ref SDLTexture texture, float* xy, int xyStride, ref SDLFColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFColor* pcolor = &color)
				{
					byte ret = RenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLFColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(ref SDLRenderer renderer, ref SDLTexture texture, float* xy, int xyStride, ref SDLFColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFColor* pcolor = &color)
					{
						byte ret = RenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLFColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(SDLRenderer* renderer, SDLTexture* texture, ref float xy, int xyStride, ref SDLFColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLFColor* pcolor = &color)
				{
					byte ret = RenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, (SDLFColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool RenderGeometryRaw(ref SDLRenderer renderer, SDLTexture* texture, ref float xy, int xyStride, ref SDLFColor color, int colorStride, float* uv, int uvStride, int numVertices, void* indices, int numIndices, int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLFColor* pcolor = &color)
					{
						byte ret = RenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, (SDLFColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret != 0;
					}
				}
			}
		}
	}
}
