// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcNative(crcContext, inBuf, inLen, crc32);
			return ret != 0;
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, crc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				byte ret = TestCrc32CalcNative(crcContext, (byte*)pinBuf, inLen, crc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, crc32);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcNative(crcContext, inBuf, inLen, (uint*)pcrc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcNative(crcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// calculate a crc32 from a data block<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Calc")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Calc([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					fixed (uint* pcrc32 = &crc32)
					{
						byte ret = TestCrc32CalcNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcStartNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, uint*, byte>)funcTable[1268])(crcContext, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1268])((nint)crcContext, (nint)crc32);
			#endif
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcStartNative(crcContext, crc32);
			return ret != 0;
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcStartNative((SDLTestCrc32Context*)pcrcContext, crc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcStartNative(crcContext, (uint*)pcrc32);
				return ret != 0;
			}
		}

		/// <summary>
		/// Same routine broken down into three steps <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcStart")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcStart([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcStartNative((SDLTestCrc32Context*)pcrcContext, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcEndNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, uint*, byte>)funcTable[1269])(crcContext, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[1269])((nint)crcContext, (nint)crc32);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcEndNative(crcContext, crc32);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcEndNative((SDLTestCrc32Context*)pcrcContext, crc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcEndNative(crcContext, (uint*)pcrc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcEnd")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcEnd([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcEndNative((SDLTestCrc32Context*)pcrcContext, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32CalcBufferNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte*, uint, uint*, byte>)funcTable[1270])(crcContext, inBuf, inLen, crc32);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, byte>)funcTable[1270])((nint)crcContext, (nint)inBuf, inLen, (nint)crc32);
			#endif
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			byte ret = TestCrc32CalcBufferNative(crcContext, inBuf, inLen, crc32);
			return ret != 0;
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, crc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				byte ret = TestCrc32CalcBufferNative(crcContext, (byte*)pinBuf, inLen, crc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] uint* crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, crc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (uint* pcrc32 = &crc32)
			{
				byte ret = TestCrc32CalcBufferNative(crcContext, inBuf, inLen, (uint*)pcrc32);
				return ret != 0;
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, inBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				fixed (uint* pcrc32 = &crc32)
				{
					byte ret = TestCrc32CalcBufferNative(crcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
					return ret != 0;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDLTest_Crc32CalcBuffer")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32CalcBuffer([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen, [NativeName(NativeNameType.Param, "crc32")] [NativeName(NativeNameType.Type, "unsigned int *")] ref uint crc32)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					fixed (uint* pcrc32 = &crc32)
					{
						byte ret = TestCrc32CalcBufferNative((SDLTestCrc32Context*)pcrcContext, (byte*)pinBuf, inLen, (uint*)pcrc32);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// clean up CRC context<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Done")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestCrc32DoneNative([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCrc32Context*, byte>)funcTable[1271])(crcContext);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1271])((nint)crcContext);
			#endif
		}

		/// <summary>
		/// clean up CRC context<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Done")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Done([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] SDLTestCrc32Context* crcContext)
		{
			byte ret = TestCrc32DoneNative(crcContext);
			return ret != 0;
		}

		/// <summary>
		/// clean up CRC context<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Crc32Done")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestCrc32Done([NativeName(NativeNameType.Param, "crcContext")] [NativeName(NativeNameType.Type, "SDLTest_Crc32Context *")] ref SDLTestCrc32Context crcContext)
		{
			fixed (SDLTestCrc32Context* pcrcContext = &crcContext)
			{
				byte ret = TestCrc32DoneNative((SDLTestCrc32Context*)pcrcContext);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a string in the currently set font.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawCharacter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestDrawCharacterNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "Uint32")] uint c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, uint, byte>)funcTable[1272])(renderer, x, y, c);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, uint, byte>)funcTable[1272])((nint)renderer, x, y, c);
			#endif
		}

		/// <summary>
		/// Draw a string in the currently set font.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawCharacter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawCharacter([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "Uint32")] uint c)
		{
			byte ret = TestDrawCharacterNative(renderer, x, y, c);
			return ret != 0;
		}

		/// <summary>
		/// Draw a string in the currently set font.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawCharacter")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawCharacter([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "Uint32")] uint c)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = TestDrawCharacterNative((SDLRenderer*)prenderer, x, y, c);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestDrawStringNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] byte* s)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, float, float, byte*, byte>)funcTable[1273])(renderer, x, y, s);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, float, float, nint, byte>)funcTable[1273])((nint)renderer, x, y, (nint)s);
			#endif
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] byte* s)
		{
			byte ret = TestDrawStringNative(renderer, x, y, s);
			return ret != 0;
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] byte* s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, s);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] ref byte s)
		{
			fixed (byte* ps = &s)
			{
				byte ret = TestDrawStringNative(renderer, x, y, (byte*)ps);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s)
		{
			fixed (byte* ps = s)
			{
				byte ret = TestDrawStringNative(renderer, x, y, (byte*)ps);
				return ret != 0;
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] string s)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TestDrawStringNative(renderer, x, y, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] ref byte s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ps = &s)
				{
					byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, (byte*)ps);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ps = s)
				{
					byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, (byte*)ps);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Draw a UTF-8 string in the currently set font.<br/>
		/// The font currently only supports characters in the Basic Latin and Latin-1 Supplement sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DrawString")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TestDrawString([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "char const *")] string s)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (s != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(s);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(s, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = TestDrawStringNative((SDLRenderer*)prenderer, x, y, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowCreate")]
		[return: NativeName(NativeNameType.Type, "SDLTest_TextWindow *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTestTextWindow* TestTextWindowCreateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "float")] float w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, float, SDLTestTextWindow*>)funcTable[1274])(x, y, w, h);
			#else
			return (SDLTestTextWindow*)((delegate* unmanaged[Cdecl]<float, float, float, float, nint>)funcTable[1274])(x, y, w, h);
			#endif
		}

		/// <summary>
		/// Create a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowCreate")]
		[return: NativeName(NativeNameType.Type, "SDLTest_TextWindow *")]
		public static SDLTestTextWindow* TestTextWindowCreate([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "float")] float w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h)
		{
			SDLTestTextWindow* ret = TestTextWindowCreateNative(x, y, w, h);
			return ret;
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowDisplayNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, SDLRenderer*, void>)funcTable[1275])(textwin, renderer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1275])((nint)textwin, (nint)renderer);
			#endif
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer)
		{
			TestTextWindowDisplayNative(textwin, renderer);
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowDisplayNative((SDLTestTextWindow*)ptextwin, renderer);
			}
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				TestTextWindowDisplayNative(textwin, (SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Display a multi-line text output window<br/>
		/// This function should be called every frame to display the text<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDisplay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDisplay([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (SDLRenderer* prenderer = &renderer)
				{
					TestTextWindowDisplayNative((SDLTestTextWindow*)ptextwin, (SDLRenderer*)prenderer);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowAddTextNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, byte*, void>)funcTable[1276])(textwin, fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1276])((nint)textwin, (nint)fmt);
			#endif
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			TestTextWindowAddTextNative(textwin, fmt);
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, fmt);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TestTextWindowAddTextNative(textwin, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TestTextWindowAddTextNative(textwin, (byte*)pfmt);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestTextWindowAddTextNative(textwin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* pfmt = &fmt)
				{
					TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* pfmt = fmt)
				{
					TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, (byte*)pfmt);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddText")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddText([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestTextWindowAddTextNative((SDLTestTextWindow*)ptextwin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowAddTextWithLengthNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, byte*, nuint, void>)funcTable[1277])(textwin, text, len);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[1277])((nint)textwin, (nint)text, len);
			#endif
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			TestTextWindowAddTextWithLengthNative(textwin, text, len);
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, text, len);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (byte* ptext = &text)
			{
				TestTextWindowAddTextWithLengthNative(textwin, (byte*)ptext, len);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (byte* ptext = text)
			{
				TestTextWindowAddTextWithLengthNative(textwin, (byte*)ptext, len);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestTextWindowAddTextWithLengthNative(textwin, pStr0, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* ptext = &text)
				{
					TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, (byte*)ptext, len);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				fixed (byte* ptext = text)
				{
					TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, (byte*)ptext, len);
				}
			}
		}

		/// <summary>
		/// Add text to a multi-line text output window<br/>
		/// Adds UTF-8 text to the end of the current text. The newline character starts a<br/>
		/// new line of text. The backspace character deletes the last character or, if the<br/>
		/// line is empty, deletes the line and goes to the end of the previous line.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowAddTextWithLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowAddTextWithLength([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				TestTextWindowAddTextWithLengthNative((SDLTestTextWindow*)ptextwin, pStr0, len);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Clear the text in a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowClearNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, void>)funcTable[1278])(textwin);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1278])((nint)textwin);
			#endif
		}

		/// <summary>
		/// Clear the text in a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowClear([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin)
		{
			TestTextWindowClearNative(textwin);
		}

		/// <summary>
		/// Clear the text in a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowClear([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowClearNative((SDLTestTextWindow*)ptextwin);
			}
		}

		/// <summary>
		/// Free the storage associated with a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDestroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTextWindowDestroyNative([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTextWindow*, void>)funcTable[1279])(textwin);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1279])((nint)textwin);
			#endif
		}

		/// <summary>
		/// Free the storage associated with a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDestroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDestroy([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] SDLTestTextWindow* textwin)
		{
			TestTextWindowDestroyNative(textwin);
		}

		/// <summary>
		/// Free the storage associated with a multi-line text output window<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TextWindowDestroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTextWindowDestroy([NativeName(NativeNameType.Param, "textwin")] [NativeName(NativeNameType.Type, "SDLTest_TextWindow *")] ref SDLTestTextWindow textwin)
		{
			fixed (SDLTestTextWindow* ptextwin = &textwin)
			{
				TestTextWindowDestroyNative((SDLTestTextWindow*)ptextwin);
			}
		}

		/// <summary>
		/// Cleanup textures used by font drawing functions.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CleanupTextDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestCleanupTextDrawingNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1280])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1280])();
			#endif
		}

		/// <summary>
		/// Cleanup textures used by font drawing functions.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CleanupTextDrawing")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestCleanupTextDrawing()
		{
			TestCleanupTextDrawingNative();
		}

		/// <summary>
		/// Initializes the fuzzer for a test<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_FuzzerInit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestFuzzerInitNative([NativeName(NativeNameType.Param, "execKey")] [NativeName(NativeNameType.Type, "Uint64")] ulong execKey)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1281])(execKey);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[1281])(execKey);
			#endif
		}

		/// <summary>
		/// Initializes the fuzzer for a test<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_FuzzerInit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestFuzzerInit([NativeName(NativeNameType.Param, "execKey")] [NativeName(NativeNameType.Type, "Uint64")] ulong execKey)
		{
			TestFuzzerInitNative(execKey);
		}

		/// <summary>
		/// Returns a random Uint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestRandomUint8Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[1282])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[1282])();
			#endif
		}

		/// <summary>
		/// Returns a random Uint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte TestRandomUint8()
		{
			byte ret = TestRandomUint8Native();
			return ret;
		}

		/// <summary>
		/// Returns a random Sint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint8")]
		[return: NativeName(NativeNameType.Type, "Sint8")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte TestRandomSint8Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte>)funcTable[1283])();
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<sbyte>)funcTable[1283])();
			#endif
		}

		/// <summary>
		/// Returns a random Sint8<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint8")]
		[return: NativeName(NativeNameType.Type, "Sint8")]
		public static sbyte TestRandomSint8()
		{
			sbyte ret = TestRandomSint8Native();
			return ret;
		}

		/// <summary>
		/// Returns a random Uint16<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort TestRandomUint16Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort>)funcTable[1284])();
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort>)funcTable[1284])();
			#endif
		}

		/// <summary>
		/// Returns a random Uint16<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort TestRandomUint16()
		{
			ushort ret = TestRandomUint16Native();
			return ret;
		}

		/// <summary>
		/// Returns a random Sint16<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint16")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short TestRandomSint16Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short>)funcTable[1285])();
			#else
			return (short)((delegate* unmanaged[Cdecl]<short>)funcTable[1285])();
			#endif
		}

		/// <summary>
		/// Returns a random Sint16<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint16")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short TestRandomSint16()
		{
			short ret = TestRandomSint16Native();
			return ret;
		}

		/// <summary>
		/// Returns a random integer<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint32")]
		[return: NativeName(NativeNameType.Type, "Sint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestRandomSint32Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1286])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1286])();
			#endif
		}

		/// <summary>
		/// Returns a random integer<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint32")]
		[return: NativeName(NativeNameType.Type, "Sint32")]
		public static int TestRandomSint32()
		{
			int ret = TestRandomSint32Native();
			return ret;
		}

		/// <summary>
		/// Returns a random positive integer<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TestRandomUint32Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[1287])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[1287])();
			#endif
		}

		/// <summary>
		/// Returns a random positive integer<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint TestRandomUint32()
		{
			uint ret = TestRandomUint32Native();
			return ret;
		}

		/// <summary>
		/// Returns random Uint64.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong TestRandomUint64Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[1288])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[1288])();
			#endif
		}

		/// <summary>
		/// Returns random Uint64.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong TestRandomUint64()
		{
			ulong ret = TestRandomUint64Native();
			return ret;
		}

		/// <summary>
		/// Returns random Sint64.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint64")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long TestRandomSint64Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long>)funcTable[1289])();
			#else
			return (long)((delegate* unmanaged[Cdecl]<long>)funcTable[1289])();
			#endif
		}

		/// <summary>
		/// Returns random Sint64.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint64")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long TestRandomSint64()
		{
			long ret = TestRandomSint64Native();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUnitFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TestRandomUnitFloatNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[1290])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[1290])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUnitFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TestRandomUnitFloat()
		{
			float ret = TestRandomUnitFloatNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUnitDouble")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TestRandomUnitDoubleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)funcTable[1291])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)funcTable[1291])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUnitDouble")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double TestRandomUnitDouble()
		{
			double ret = TestRandomUnitDoubleNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TestRandomFloatNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)funcTable[1292])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)funcTable[1292])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomFloat")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float TestRandomFloat()
		{
			float ret = TestRandomFloatNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomDouble")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TestRandomDoubleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)funcTable[1293])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)funcTable[1293])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomDouble")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double TestRandomDouble()
		{
			double ret = TestRandomDoubleNative();
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint8BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint8BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint8BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint8BoundaryValue(0, 255, false) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint8BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestRandomUint8BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint8")] byte boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint8")] byte boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)funcTable[1294])(boundary1, boundary2, validDomain);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte, byte, byte, byte>)funcTable[1294])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint8BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint8BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint8BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint8BoundaryValue(0, 255, false) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint8BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte TestRandomUint8BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint8")] byte boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint8")] byte boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			byte ret = TestRandomUint8BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint16BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint16BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint16BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint16BoundaryValue(0, 0xFFFF, false) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint16BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort TestRandomUint16BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint16")] ushort boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint16")] ushort boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort, ushort, byte, ushort>)funcTable[1295])(boundary1, boundary2, validDomain);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort, ushort, byte, ushort>)funcTable[1295])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint16BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint16BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint16BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint16BoundaryValue(0, 0xFFFF, false) returns 0 (error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint16BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort TestRandomUint16BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint16")] ushort boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint16")] ushort boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			ushort ret = TestRandomUint16BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint32BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint32BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint32BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint32BoundaryValue(0, 0xFFFFFFFF, false) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint32BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TestRandomUint32BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint32")] uint boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint32")] uint boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, byte, uint>)funcTable[1296])(boundary1, boundary2, validDomain);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, byte, uint>)funcTable[1296])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint32BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint32BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint32BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint32BoundaryValue(0, 0xFFFFFFFF, false) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint32BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint TestRandomUint32BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint32")] uint boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint32")] uint boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			uint ret = TestRandomUint32BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Uint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint64BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint64BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint64BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint64BoundaryValue(0, 0xFFFFFFFFFFFFFFFF, false) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint64BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong TestRandomUint64BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint64")] ulong boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint64")] ulong boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, ulong, byte, ulong>)funcTable[1297])(boundary1, boundary2, validDomain);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong, ulong, byte, ulong>)funcTable[1297])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Uint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomUint64BoundaryValue(10, 20, true) returns 10, 11, 19 or 20<br/>
		/// RandomUint64BoundaryValue(1, 20, false) returns 0 or 21<br/>
		/// RandomUint64BoundaryValue(0, 99, false) returns 100<br/>
		/// RandomUint64BoundaryValue(0, 0xFFFFFFFFFFFFFFFF, false) returns 0 (with error set)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomUint64BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong TestRandomUint64BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Uint64")] ulong boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Uint64")] ulong boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			ulong ret = TestRandomUint64BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint8BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint8BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, 99, false) returns 100<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, SINT8_MAX, false) returns SINT8_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint8BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint8")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static sbyte TestRandomSint8BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint8")] sbyte boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint8")] sbyte boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<sbyte, sbyte, byte, sbyte>)funcTable[1298])(boundary1, boundary2, validDomain);
			#else
			return (sbyte)((delegate* unmanaged[Cdecl]<sbyte, sbyte, byte, sbyte>)funcTable[1298])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint8 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint8BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint8BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, 99, false) returns 100<br/>
		/// RandomSint8BoundaryValue(SINT8_MIN, SINT8_MAX, false) returns SINT8_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint8BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint8")]
		public static sbyte TestRandomSint8BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint8")] sbyte boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint8")] sbyte boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			sbyte ret = TestRandomSint8BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint16BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint16BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, 99, false) returns 100<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, SINT16_MAX, false) returns SINT16_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint16BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short TestRandomSint16BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint16")] short boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint16")] short boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<short, short, byte, short>)funcTable[1299])(boundary1, boundary2, validDomain);
			#else
			return (short)((delegate* unmanaged[Cdecl]<short, short, byte, short>)funcTable[1299])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint16 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint16BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint16BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, 99, false) returns 100<br/>
		/// RandomSint16BoundaryValue(SINT16_MIN, SINT16_MAX, false) returns SINT16_MIN (== error value) with error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint16BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short TestRandomSint16BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint16")] short boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint16")] short boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			short ret = TestRandomSint16BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint32BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint32BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, 99, false) returns 100<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, SINT32_MAX, false) returns SINT32_MIN (== error value)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint32BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestRandomSint32BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint32")] int boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint32")] int boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, byte, int>)funcTable[1300])(boundary1, boundary2, validDomain);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, byte, int>)funcTable[1300])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint32 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint32BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint32BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, 99, false) returns 100<br/>
		/// RandomSint32BoundaryValue(SINT32_MIN, SINT32_MAX, false) returns SINT32_MIN (== error value)<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint32BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint32")]
		public static int TestRandomSint32BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint32")] int boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint32")] int boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			int ret = TestRandomSint32BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns a random boundary value for Sint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint64BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint64BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, 99, false) returns 100<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, SINT64_MAX, false) returns SINT64_MIN (== error value) and error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint64BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static long TestRandomSint64BoundaryValueNative([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint64")] long boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint64")] long boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] byte validDomain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<long, long, byte, long>)funcTable[1301])(boundary1, boundary2, validDomain);
			#else
			return (long)((delegate* unmanaged[Cdecl]<long, long, byte, long>)funcTable[1301])(boundary1, boundary2, validDomain);
			#endif
		}

		/// <summary>
		/// Returns a random boundary value for Sint64 within the given boundaries.<br/>
		/// Boundaries are inclusive, see the usage examples below. If validDomain<br/>
		/// is true, the function will only return valid boundaries, otherwise non-valid<br/>
		/// boundaries are also possible.<br/>
		/// If boundary1 > boundary2, the values are swapped<br/>
		/// Usage examples:<br/>
		/// RandomSint64BoundaryValue(-10, 20, true) returns -11, -10, 19 or 20<br/>
		/// RandomSint64BoundaryValue(-100, -10, false) returns -101 or -9<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, 99, false) returns 100<br/>
		/// RandomSint64BoundaryValue(SINT64_MIN, SINT64_MAX, false) returns SINT64_MIN (== error value) and error set<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomSint64BoundaryValue")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long TestRandomSint64BoundaryValue([NativeName(NativeNameType.Param, "boundary1")] [NativeName(NativeNameType.Type, "Sint64")] long boundary1, [NativeName(NativeNameType.Param, "boundary2")] [NativeName(NativeNameType.Type, "Sint64")] long boundary2, [NativeName(NativeNameType.Param, "validDomain")] [NativeName(NativeNameType.Type, "bool")] bool validDomain)
		{
			long ret = TestRandomSint64BoundaryValueNative(boundary1, boundary2, validDomain ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Returns integer in range [min, max] (inclusive).<br/>
		/// Min and max values can be negative values.<br/>
		/// If Max in smaller than min, then the values are swapped.<br/>
		/// Min and max are the same value, that value will be returned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomIntegerInRange")]
		[return: NativeName(NativeNameType.Type, "Sint32")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestRandomIntegerInRangeNative([NativeName(NativeNameType.Param, "min")] [NativeName(NativeNameType.Type, "Sint32")] int min, [NativeName(NativeNameType.Param, "max")] [NativeName(NativeNameType.Type, "Sint32")] int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[1302])(min, max);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[1302])(min, max);
			#endif
		}

		/// <summary>
		/// Returns integer in range [min, max] (inclusive).<br/>
		/// Min and max values can be negative values.<br/>
		/// If Max in smaller than min, then the values are swapped.<br/>
		/// Min and max are the same value, that value will be returned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomIntegerInRange")]
		[return: NativeName(NativeNameType.Type, "Sint32")]
		public static int TestRandomIntegerInRange([NativeName(NativeNameType.Param, "min")] [NativeName(NativeNameType.Type, "Sint32")] int min, [NativeName(NativeNameType.Param, "max")] [NativeName(NativeNameType.Type, "Sint32")] int max)
		{
			int ret = TestRandomIntegerInRangeNative(min, max);
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The minimum length for<br/>
		/// the string is 1 character, maximum length for the string is 255<br/>
		/// characters and it can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiString")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestRandomAsciiStringNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[1303])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1303])();
			#endif
		}

		/// <summary>
		/// Generates random null-terminated string. The minimum length for<br/>
		/// the string is 1 character, maximum length for the string is 255<br/>
		/// characters and it can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiString")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TestRandomAsciiString()
		{
			byte* ret = TestRandomAsciiStringNative();
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The minimum length for<br/>
		/// the string is 1 character, maximum length for the string is 255<br/>
		/// characters and it can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiString")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TestRandomAsciiStringS()
		{
			string ret = Utils.DecodeStringUTF8(TestRandomAsciiStringNative());
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The maximum length for<br/>
		/// the string is defined by the maxLength parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiStringWithMaximumLength")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestRandomAsciiStringWithMaximumLengthNative([NativeName(NativeNameType.Param, "maxLength")] [NativeName(NativeNameType.Type, "int")] int maxLength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[1304])(maxLength);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[1304])(maxLength);
			#endif
		}

		/// <summary>
		/// Generates random null-terminated string. The maximum length for<br/>
		/// the string is defined by the maxLength parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiStringWithMaximumLength")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TestRandomAsciiStringWithMaximumLength([NativeName(NativeNameType.Param, "maxLength")] [NativeName(NativeNameType.Type, "int")] int maxLength)
		{
			byte* ret = TestRandomAsciiStringWithMaximumLengthNative(maxLength);
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The maximum length for<br/>
		/// the string is defined by the maxLength parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiStringWithMaximumLength")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TestRandomAsciiStringWithMaximumLengthS([NativeName(NativeNameType.Param, "maxLength")] [NativeName(NativeNameType.Type, "int")] int maxLength)
		{
			string ret = Utils.DecodeStringUTF8(TestRandomAsciiStringWithMaximumLengthNative(maxLength));
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The length for<br/>
		/// the string is defined by the size parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiStringOfSize")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestRandomAsciiStringOfSizeNative([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[1305])(size);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[1305])(size);
			#endif
		}

		/// <summary>
		/// Generates random null-terminated string. The length for<br/>
		/// the string is defined by the size parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiStringOfSize")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TestRandomAsciiStringOfSize([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			byte* ret = TestRandomAsciiStringOfSizeNative(size);
			return ret;
		}

		/// <summary>
		/// Generates random null-terminated string. The length for<br/>
		/// the string is defined by the size parameter.<br/>
		/// String can contain ASCII characters from 32 to 126.<br/>
		/// Note: Returned string needs to be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandomAsciiStringOfSize")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TestRandomAsciiStringOfSizeS([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			string ret = Utils.DecodeStringUTF8(TestRandomAsciiStringOfSizeNative(size));
			return ret;
		}

		/// <summary>
		/// Get the invocation count for the fuzzer since last ...FuzzerInit.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GetFuzzerInvocationCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestGetFuzzerInvocationCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[1306])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[1306])();
			#endif
		}

		/// <summary>
		/// Get the invocation count for the fuzzer since last ...FuzzerInit.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GetFuzzerInvocationCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestGetFuzzerInvocationCount()
		{
			int ret = TestGetFuzzerInvocationCountNative();
			return ret;
		}

		/// <summary>
		/// Generates a random run seed string for the harness. The generated seed<br/>
		/// will contain alphanumeric characters (0-9A-Z).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GenerateRunSeed")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* TestGenerateRunSeedNative([NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "char *")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, byte*>)funcTable[1307])(buffer, length);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[1307])((nint)buffer, length);
			#endif
		}

		/// <summary>
		/// Generates a random run seed string for the harness. The generated seed<br/>
		/// will contain alphanumeric characters (0-9A-Z).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GenerateRunSeed")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TestGenerateRunSeed([NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "char *")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* ret = TestGenerateRunSeedNative(buffer, length);
			return ret;
		}

		/// <summary>
		/// Generates a random run seed string for the harness. The generated seed<br/>
		/// will contain alphanumeric characters (0-9A-Z).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GenerateRunSeed")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TestGenerateRunSeedS([NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "char *")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			string ret = Utils.DecodeStringUTF8(TestGenerateRunSeedNative(buffer, length));
			return ret;
		}

		/// <summary>
		/// Generates a random run seed string for the harness. The generated seed<br/>
		/// will contain alphanumeric characters (0-9A-Z).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GenerateRunSeed")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TestGenerateRunSeed([NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "char *")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				byte* ret = TestGenerateRunSeedNative((byte*)pbuffer, length);
				return ret;
			}
		}

		/// <summary>
		/// Generates a random run seed string for the harness. The generated seed<br/>
		/// will contain alphanumeric characters (0-9A-Z).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GenerateRunSeed")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TestGenerateRunSeedS([NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "char *")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				string ret = Utils.DecodeStringUTF8(TestGenerateRunSeedNative((byte*)pbuffer, length));
				return ret;
			}
		}

		/// <summary>
		/// Generates a random run seed string for the harness. The generated seed<br/>
		/// will contain alphanumeric characters (0-9A-Z).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GenerateRunSeed")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* TestGenerateRunSeed([NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "char *")] ref string buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = TestGenerateRunSeedNative(pStr0, length);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Generates a random run seed string for the harness. The generated seed<br/>
		/// will contain alphanumeric characters (0-9A-Z).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_GenerateRunSeed")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string TestGenerateRunSeedS([NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "char *")] ref string buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "int")] int length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(TestGenerateRunSeedNative(pStr0, length));
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Create a new test suite runner, that will execute the given test suites.<br/>
		/// It will register the harness cli arguments to the common SDL state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CreateTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTestTestSuiteRunner* TestCreateTestSuiteRunnerNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "testSuites")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteReference *[-1]")] SDLTestTestSuiteReference** testSuites)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestCommonState*, SDLTestTestSuiteReference**, SDLTestTestSuiteRunner*>)funcTable[1308])(state, testSuites);
			#else
			return (SDLTestTestSuiteRunner*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[1308])((nint)state, (nint)testSuites);
			#endif
		}

		/// <summary>
		/// Create a new test suite runner, that will execute the given test suites.<br/>
		/// It will register the harness cli arguments to the common SDL state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CreateTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")]
		public static SDLTestTestSuiteRunner* TestCreateTestSuiteRunner([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] SDLTestCommonState* state, [NativeName(NativeNameType.Param, "testSuites")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteReference *[-1]")] SDLTestTestSuiteReference** testSuites)
		{
			SDLTestTestSuiteRunner* ret = TestCreateTestSuiteRunnerNative(state, testSuites);
			return ret;
		}

		/// <summary>
		/// Create a new test suite runner, that will execute the given test suites.<br/>
		/// It will register the harness cli arguments to the common SDL state.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_CreateTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")]
		public static SDLTestTestSuiteRunner* TestCreateTestSuiteRunner([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "SDLTest_CommonState *")] ref SDLTestCommonState state, [NativeName(NativeNameType.Param, "testSuites")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteReference *[-1]")] SDLTestTestSuiteReference** testSuites)
		{
			fixed (SDLTestCommonState* pstate = &state)
			{
				SDLTestTestSuiteRunner* ret = TestCreateTestSuiteRunnerNative((SDLTestCommonState*)pstate, testSuites);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a test suite runner.<br/>
		/// It will unregister the harness cli arguments to the common SDL state.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DestroyTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestDestroyTestSuiteRunnerNative([NativeName(NativeNameType.Param, "runner")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")] SDLTestTestSuiteRunner* runner)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestTestSuiteRunner*, void>)funcTable[1309])(runner);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1309])((nint)runner);
			#endif
		}

		/// <summary>
		/// Destroy a test suite runner.<br/>
		/// It will unregister the harness cli arguments to the common SDL state.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DestroyTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestDestroyTestSuiteRunner([NativeName(NativeNameType.Param, "runner")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")] SDLTestTestSuiteRunner* runner)
		{
			TestDestroyTestSuiteRunnerNative(runner);
		}

		/// <summary>
		/// Destroy a test suite runner.<br/>
		/// It will unregister the harness cli arguments to the common SDL state.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_DestroyTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestDestroyTestSuiteRunner([NativeName(NativeNameType.Param, "runner")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")] ref SDLTestTestSuiteRunner runner)
		{
			fixed (SDLTestTestSuiteRunner* prunner = &runner)
			{
				TestDestroyTestSuiteRunnerNative((SDLTestTestSuiteRunner*)prunner);
			}
		}

		/// <summary>
		/// Execute a test suite, using the configured run seed, execution key, filter, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_ExecuteTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TestExecuteTestSuiteRunnerNative([NativeName(NativeNameType.Param, "runner")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")] SDLTestTestSuiteRunner* runner)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLTestTestSuiteRunner*, int>)funcTable[1310])(runner);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[1310])((nint)runner);
			#endif
		}

		/// <summary>
		/// Execute a test suite, using the configured run seed, execution key, filter, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_ExecuteTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestExecuteTestSuiteRunner([NativeName(NativeNameType.Param, "runner")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")] SDLTestTestSuiteRunner* runner)
		{
			int ret = TestExecuteTestSuiteRunnerNative(runner);
			return ret;
		}

		/// <summary>
		/// Execute a test suite, using the configured run seed, execution key, filter, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_ExecuteTestSuiteRunner")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int TestExecuteTestSuiteRunner([NativeName(NativeNameType.Param, "runner")] [NativeName(NativeNameType.Type, "SDLTest_TestSuiteRunner *")] ref SDLTestTestSuiteRunner runner)
		{
			fixed (SDLTestTestSuiteRunner* prunner = &runner)
			{
				int ret = TestExecuteTestSuiteRunnerNative((SDLTestTestSuiteRunner*)prunner);
				return ret;
			}
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and INFO priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1311])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1311])((nint)fmt);
			#endif
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and INFO priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLog([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			TestLogNative(fmt);
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and INFO priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLog([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TestLogNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and INFO priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLog([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TestLogNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and INFO priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLog([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestLogNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Prints given prefix and buffer.<br/>
		/// Non-printible characters in the raw data are substituted by printible alternatives.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogEscapedString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogEscapedStringNative([NativeName(NativeNameType.Param, "prefix")] [NativeName(NativeNameType.Type, "char const *")] byte* prefix, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "void const *")] void* buffer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void*, nuint, void>)funcTable[1312])(prefix, buffer, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[1312])((nint)prefix, (nint)buffer, size);
			#endif
		}

		/// <summary>
		/// Prints given prefix and buffer.<br/>
		/// Non-printible characters in the raw data are substituted by printible alternatives.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogEscapedString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogEscapedString([NativeName(NativeNameType.Param, "prefix")] [NativeName(NativeNameType.Type, "char const *")] byte* prefix, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "void const *")] void* buffer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			TestLogEscapedStringNative(prefix, buffer, size);
		}

		/// <summary>
		/// Prints given prefix and buffer.<br/>
		/// Non-printible characters in the raw data are substituted by printible alternatives.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogEscapedString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogEscapedString([NativeName(NativeNameType.Param, "prefix")] [NativeName(NativeNameType.Type, "char const *")] ref byte prefix, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "void const *")] void* buffer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			fixed (byte* pprefix = &prefix)
			{
				TestLogEscapedStringNative((byte*)pprefix, buffer, size);
			}
		}

		/// <summary>
		/// Prints given prefix and buffer.<br/>
		/// Non-printible characters in the raw data are substituted by printible alternatives.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogEscapedString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogEscapedString([NativeName(NativeNameType.Param, "prefix")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> prefix, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "void const *")] void* buffer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			fixed (byte* pprefix = prefix)
			{
				TestLogEscapedStringNative((byte*)pprefix, buffer, size);
			}
		}

		/// <summary>
		/// Prints given prefix and buffer.<br/>
		/// Non-printible characters in the raw data are substituted by printible alternatives.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogEscapedString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogEscapedString([NativeName(NativeNameType.Param, "prefix")] [NativeName(NativeNameType.Type, "char const *")] string prefix, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "void const *")] void* buffer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestLogEscapedStringNative(pStr0, buffer, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and the ERROR priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogErrorNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[1313])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1313])((nint)fmt);
			#endif
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and the ERROR priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] byte* fmt)
		{
			TestLogErrorNative(fmt);
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and the ERROR priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TestLogErrorNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and the ERROR priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				TestLogErrorNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// Prints given message with a timestamp in the TEST category and the ERROR priority.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "char const *")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TestLogErrorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// initialize the context<br/>
		/// <br/>
		/// Note: The function initializes the message-digest context<br/>
		/// mdContext. Call before each new use of the context -<br/>
		/// all fields are set to zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestMd5InitNative([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] SDLTestMd5Context* mdContext)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestMd5Context*, void>)funcTable[1314])(mdContext);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1314])((nint)mdContext);
			#endif
		}

		/// <summary>
		/// initialize the context<br/>
		/// <br/>
		/// Note: The function initializes the message-digest context<br/>
		/// mdContext. Call before each new use of the context -<br/>
		/// all fields are set to zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Init([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] SDLTestMd5Context* mdContext)
		{
			TestMd5InitNative(mdContext);
		}

		/// <summary>
		/// initialize the context<br/>
		/// <br/>
		/// Note: The function initializes the message-digest context<br/>
		/// mdContext. Call before each new use of the context -<br/>
		/// all fields are set to zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Init([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] ref SDLTestMd5Context mdContext)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				TestMd5InitNative((SDLTestMd5Context*)pmdContext);
			}
		}

		/// <summary>
		/// update digest from variable length data<br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Update")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestMd5UpdateNative([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] SDLTestMd5Context* mdContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestMd5Context*, byte*, uint, void>)funcTable[1315])(mdContext, inBuf, inLen);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[1315])((nint)mdContext, (nint)inBuf, inLen);
			#endif
		}

		/// <summary>
		/// update digest from variable length data<br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Update")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Update([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] SDLTestMd5Context* mdContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen)
		{
			TestMd5UpdateNative(mdContext, inBuf, inLen);
		}

		/// <summary>
		/// update digest from variable length data<br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Update")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Update([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] ref SDLTestMd5Context mdContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				TestMd5UpdateNative((SDLTestMd5Context*)pmdContext, inBuf, inLen);
			}
		}

		/// <summary>
		/// update digest from variable length data<br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Update")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Update([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] SDLTestMd5Context* mdContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen)
		{
			fixed (byte* pinBuf = &inBuf)
			{
				TestMd5UpdateNative(mdContext, (byte*)pinBuf, inLen);
			}
		}

		/// <summary>
		/// update digest from variable length data<br/>
		/// <br/>
		/// Note: The function updates the message-digest context to account<br/>
		/// for the presence of each of the characters inBuf[0..inLen-1]<br/>
		/// in the message whose digest is being computed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Update")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Update([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] ref SDLTestMd5Context mdContext, [NativeName(NativeNameType.Param, "inBuf")] [NativeName(NativeNameType.Type, "unsigned char *")] ref byte inBuf, [NativeName(NativeNameType.Param, "inLen")] [NativeName(NativeNameType.Type, "unsigned int")] uint inLen)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				fixed (byte* pinBuf = &inBuf)
				{
					TestMd5UpdateNative((SDLTestMd5Context*)pmdContext, (byte*)pinBuf, inLen);
				}
			}
		}

		/// <summary>
		/// complete digest computation<br/>
		/// <br/>
		/// Note: The function terminates the message-digest computation and<br/>
		/// ends with the desired message digest in mdContext.digest[0..15].<br/>
		/// Always call before using the digest[] variable.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Final")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestMd5FinalNative([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] SDLTestMd5Context* mdContext)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLTestMd5Context*, void>)funcTable[1316])(mdContext);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1316])((nint)mdContext);
			#endif
		}

		/// <summary>
		/// complete digest computation<br/>
		/// <br/>
		/// Note: The function terminates the message-digest computation and<br/>
		/// ends with the desired message digest in mdContext.digest[0..15].<br/>
		/// Always call before using the digest[] variable.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Final")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Final([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] SDLTestMd5Context* mdContext)
		{
			TestMd5FinalNative(mdContext);
		}

		/// <summary>
		/// complete digest computation<br/>
		/// <br/>
		/// Note: The function terminates the message-digest computation and<br/>
		/// ends with the desired message digest in mdContext.digest[0..15].<br/>
		/// Always call before using the digest[] variable.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_Md5Final")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestMd5Final([NativeName(NativeNameType.Param, "mdContext")] [NativeName(NativeNameType.Type, "SDLTest_Md5Context *")] ref SDLTestMd5Context mdContext)
		{
			fixed (SDLTestMd5Context* pmdContext = &mdContext)
			{
				TestMd5FinalNative((SDLTestMd5Context*)pmdContext);
			}
		}

		/// <summary>
		/// Start tracking SDL memory allocations<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TrackAllocations")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestTrackAllocationsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1317])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1317])();
			#endif
		}

		/// <summary>
		/// Start tracking SDL memory allocations<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_TrackAllocations")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestTrackAllocations()
		{
			TestTrackAllocationsNative();
		}

		/// <summary>
		/// Fill allocations with random data<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandFillAllocations")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestRandFillAllocationsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1318])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1318])();
			#endif
		}

		/// <summary>
		/// Fill allocations with random data<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_RandFillAllocations")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestRandFillAllocations()
		{
			TestRandFillAllocationsNative();
		}

		/// <summary>
		/// Print a log of any outstanding allocations<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogAllocations")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TestLogAllocationsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1319])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1319])();
			#endif
		}

		/// <summary>
		/// Print a log of any outstanding allocations<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDLTest_LogAllocations")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TestLogAllocations()
		{
			TestLogAllocationsNative();
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// SDL keeps a counter of how many times this function has been successfully<br/>
		/// called, so it is safe to call this function multiple times, so long as it<br/>
		/// is eventually paired with an equivalent number of calls to<br/>
		/// SDL_Vulkan_UnloadLibrary. The `path` argument is ignored unless there is no<br/>
		/// library currently loaded, and and the library isn't actually unloaded until<br/>
		/// there have been an equivalent number of calls to SDL_Vulkan_UnloadLibrary.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte VulkanLoadLibraryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)funcTable[1320])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[1320])((nint)path);
			#endif
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// SDL keeps a counter of how many times this function has been successfully<br/>
		/// called, so it is safe to call this function multiple times, so long as it<br/>
		/// is eventually paired with an equivalent number of calls to<br/>
		/// SDL_Vulkan_UnloadLibrary. The `path` argument is ignored unless there is no<br/>
		/// library currently loaded, and and the library isn't actually unloaded until<br/>
		/// there have been an equivalent number of calls to SDL_Vulkan_UnloadLibrary.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path)
		{
			byte ret = VulkanLoadLibraryNative(path);
			return ret != 0;
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// SDL keeps a counter of how many times this function has been successfully<br/>
		/// called, so it is safe to call this function multiple times, so long as it<br/>
		/// is eventually paired with an equivalent number of calls to<br/>
		/// SDL_Vulkan_UnloadLibrary. The `path` argument is ignored unless there is no<br/>
		/// library currently loaded, and and the library isn't actually unloaded until<br/>
		/// there have been an equivalent number of calls to SDL_Vulkan_UnloadLibrary.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				byte ret = VulkanLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// SDL keeps a counter of how many times this function has been successfully<br/>
		/// called, so it is safe to call this function multiple times, so long as it<br/>
		/// is eventually paired with an equivalent number of calls to<br/>
		/// SDL_Vulkan_UnloadLibrary. The `path` argument is ignored unless there is no<br/>
		/// library currently loaded, and and the library isn't actually unloaded until<br/>
		/// there have been an equivalent number of calls to SDL_Vulkan_UnloadLibrary.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path)
		{
			fixed (byte* ppath = path)
			{
				byte ret = VulkanLoadLibraryNative((byte*)ppath);
				return ret != 0;
			}
		}

		/// <summary>
		/// Dynamically load the Vulkan loader library.<br/>
		/// This should be called after initializing the video driver, but before<br/>
		/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
		/// default library will be loaded upon creation of the first Vulkan window.<br/>
		/// SDL keeps a counter of how many times this function has been successfully<br/>
		/// called, so it is safe to call this function multiple times, so long as it<br/>
		/// is eventually paired with an equivalent number of calls to<br/>
		/// SDL_Vulkan_UnloadLibrary. The `path` argument is ignored unless there is no<br/>
		/// library currently loaded, and and the library isn't actually unloaded until<br/>
		/// there have been an equivalent number of calls to SDL_Vulkan_UnloadLibrary.<br/>
		/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
		/// of explicitly loading it at run time. This will work with SDL provided the<br/>
		/// application links to a dynamic library and both it and SDL use the same<br/>
		/// search path.<br/>
		/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
		/// Vulkan functions it uses from the dynamic library using<br/>
		/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
		/// to the same vulkan loader library the application linked to.<br/>
		/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
		/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
		/// process. This is because it is fairly common for Vulkan applications to<br/>
		/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
		/// library). If it is not found, on macOS, SDL will attempt to load<br/>
		/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
		/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
		/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
		/// dynamic framework or .dylib must ensure it is included in its application<br/>
		/// bundle.<br/>
		/// On non-Apple devices, application linking with a static libvulkan is not<br/>
		/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
		/// library version.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = VulkanLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get the address of the `vkGetInstanceProcAddr` function.<br/>
		/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
		/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
		/// The actual type of the returned function pointer is<br/>
		/// PFN_vkGetInstanceProcAddr, but that isn't available because the Vulkan<br/>
		/// headers are not included here. You should cast the return value of this<br/>
		/// function to that type, e.g.<br/>
		/// `vkGetInstanceProcAddr =<br/>
		/// (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();`<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_GetVkGetInstanceProcAddr")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> VulkanGetVkGetInstanceProcAddrNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<void>>)funcTable[1321])();
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint>)funcTable[1321])();
			#endif
		}

		/// <summary>
		/// Get the address of the `vkGetInstanceProcAddr` function.<br/>
		/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
		/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
		/// The actual type of the returned function pointer is<br/>
		/// PFN_vkGetInstanceProcAddr, but that isn't available because the Vulkan<br/>
		/// headers are not included here. You should cast the return value of this<br/>
		/// function to that type, e.g.<br/>
		/// `vkGetInstanceProcAddr =<br/>
		/// (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();`<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_GetVkGetInstanceProcAddr")]
		[return: NativeName(NativeNameType.Type, "SDL_FunctionPointer")]
		public static delegate*<void> VulkanGetVkGetInstanceProcAddr()
		{
			delegate*<void> ret = VulkanGetVkGetInstanceProcAddrNative();
			return ret;
		}

		/// <summary>
		/// Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary().<br/>
		/// SDL keeps a counter of how many times this function has been called, so it<br/>
		/// is safe to call this function multiple times, so long as it is paired with<br/>
		/// an equivalent number of calls to SDL_Vulkan_LoadLibrary. The library isn't<br/>
		/// actually unloaded until there have been an equivalent number of calls to<br/>
		/// SDL_Vulkan_UnloadLibrary.<br/>
		/// Once the library has actually been unloaded, if any Vulkan instances<br/>
		/// remain, they will likely crash the program. Clean up any existing Vulkan<br/>
		/// resources, and destroy appropriate windows, renderers and GPU devices<br/>
		/// before calling this function.<br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VulkanUnloadLibraryNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[1322])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[1322])();
			#endif
		}

		/// <summary>
		/// Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary().<br/>
		/// SDL keeps a counter of how many times this function has been called, so it<br/>
		/// is safe to call this function multiple times, so long as it is paired with<br/>
		/// an equivalent number of calls to SDL_Vulkan_LoadLibrary. The library isn't<br/>
		/// actually unloaded until there have been an equivalent number of calls to<br/>
		/// SDL_Vulkan_UnloadLibrary.<br/>
		/// Once the library has actually been unloaded, if any Vulkan instances<br/>
		/// remain, they will likely crash the program. Clean up any existing Vulkan<br/>
		/// resources, and destroy appropriate windows, renderers and GPU devices<br/>
		/// before calling this function.<br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VulkanUnloadLibrary()
		{
			VulkanUnloadLibraryNative();
		}

		/// <summary>
		/// Get the Vulkan instance extensions needed for vkCreateInstance.<br/>
		/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
		/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
		/// On return, the variable pointed to by `count` will be set to the number of<br/>
		/// elements returned, suitable for using with<br/>
		/// VkInstanceCreateInfo::enabledExtensionCount, and the returned array can be<br/>
		/// used with VkInstanceCreateInfo::ppEnabledExtensionNames, for calling<br/>
		/// Vulkan's vkCreateInstance API.<br/>
		/// You should not free the returned array; it is owned by SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_GetInstanceExtensions")]
		[return: NativeName(NativeNameType.Type, "char const * const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** VulkanGetInstanceExtensionsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, byte**>)funcTable[1323])(count);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[1323])((nint)count);
			#endif
		}

		/// <summary>
		/// Get the Vulkan instance extensions needed for vkCreateInstance.<br/>
		/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
		/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
		/// On return, the variable pointed to by `count` will be set to the number of<br/>
		/// elements returned, suitable for using with<br/>
		/// VkInstanceCreateInfo::enabledExtensionCount, and the returned array can be<br/>
		/// used with VkInstanceCreateInfo::ppEnabledExtensionNames, for calling<br/>
		/// Vulkan's vkCreateInstance API.<br/>
		/// You should not free the returned array; it is owned by SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_GetInstanceExtensions")]
		[return: NativeName(NativeNameType.Type, "char const * const *")]
		public static byte** VulkanGetInstanceExtensions([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* count)
		{
			byte** ret = VulkanGetInstanceExtensionsNative(count);
			return ret;
		}

		/// <summary>
		/// Get the Vulkan instance extensions needed for vkCreateInstance.<br/>
		/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
		/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
		/// On return, the variable pointed to by `count` will be set to the number of<br/>
		/// elements returned, suitable for using with<br/>
		/// VkInstanceCreateInfo::enabledExtensionCount, and the returned array can be<br/>
		/// used with VkInstanceCreateInfo::ppEnabledExtensionNames, for calling<br/>
		/// Vulkan's vkCreateInstance API.<br/>
		/// You should not free the returned array; it is owned by SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_GetInstanceExtensions")]
		[return: NativeName(NativeNameType.Type, "char const * const *")]
		public static byte** VulkanGetInstanceExtensions([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint count)
		{
			fixed (uint* pcount = &count)
			{
				byte** ret = VulkanGetInstanceExtensionsNative((uint*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte VulkanCreateSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] VkAllocationCallbacks* allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] VkSurfaceKHR* surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, VkInstance, VkAllocationCallbacks*, VkSurfaceKHR*, byte>)funcTable[1324])(window, instance, allocator, surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, VkInstance, nint, nint, byte>)funcTable[1324])((nint)window, instance, (nint)allocator, (nint)surface);
			#endif
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] VkAllocationCallbacks* allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] VkSurfaceKHR* surface)
		{
			byte ret = VulkanCreateSurfaceNative(window, instance, allocator, surface);
			return ret != 0;
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] VkAllocationCallbacks* allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] VkSurfaceKHR* surface)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = VulkanCreateSurfaceNative((SDLWindow*)pwindow, instance, allocator, surface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] ref VkAllocationCallbacks allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] VkSurfaceKHR* surface)
		{
			fixed (VkAllocationCallbacks* pallocator = &allocator)
			{
				byte ret = VulkanCreateSurfaceNative(window, instance, (VkAllocationCallbacks*)pallocator, surface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] ref VkAllocationCallbacks allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] VkSurfaceKHR* surface)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (VkAllocationCallbacks* pallocator = &allocator)
				{
					byte ret = VulkanCreateSurfaceNative((SDLWindow*)pwindow, instance, (VkAllocationCallbacks*)pallocator, surface);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] VkAllocationCallbacks* allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] ref VkSurfaceKHR surface)
		{
			fixed (VkSurfaceKHR* psurface = &surface)
			{
				byte ret = VulkanCreateSurfaceNative(window, instance, allocator, (VkSurfaceKHR*)psurface);
				return ret != 0;
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] VkAllocationCallbacks* allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] ref VkSurfaceKHR surface)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (VkSurfaceKHR* psurface = &surface)
				{
					byte ret = VulkanCreateSurfaceNative((SDLWindow*)pwindow, instance, allocator, (VkSurfaceKHR*)psurface);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] ref VkAllocationCallbacks allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] ref VkSurfaceKHR surface)
		{
			fixed (VkAllocationCallbacks* pallocator = &allocator)
			{
				fixed (VkSurfaceKHR* psurface = &surface)
				{
					byte ret = VulkanCreateSurfaceNative(window, instance, (VkAllocationCallbacks*)pallocator, (VkSurfaceKHR*)psurface);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a Vulkan rendering surface for a window.<br/>
		/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
		/// `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_CreateSurface")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanCreateSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] ref VkAllocationCallbacks allocator, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR *")] ref VkSurfaceKHR surface)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (VkAllocationCallbacks* pallocator = &allocator)
				{
					fixed (VkSurfaceKHR* psurface = &surface)
					{
						byte ret = VulkanCreateSurfaceNative((SDLWindow*)pwindow, instance, (VkAllocationCallbacks*)pallocator, (VkSurfaceKHR*)psurface);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Destroy the Vulkan rendering surface of a window.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Vulkan_CreateSurface<br/>
		/// was called after SDL_CreateWindow.<br/>
		/// The `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled and `surface` must have been<br/>
		/// created successfully by an SDL_Vulkan_CreateSurface() call.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VulkanDestroySurfaceNative([NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR")] VkSurfaceKHR surface, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] VkAllocationCallbacks* allocator)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<VkInstance, VkSurfaceKHR, VkAllocationCallbacks*, void>)funcTable[1325])(instance, surface, allocator);
			#else
			((delegate* unmanaged[Cdecl]<VkInstance, VkSurfaceKHR, nint, void>)funcTable[1325])(instance, surface, (nint)allocator);
			#endif
		}

		/// <summary>
		/// Destroy the Vulkan rendering surface of a window.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Vulkan_CreateSurface<br/>
		/// was called after SDL_CreateWindow.<br/>
		/// The `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled and `surface` must have been<br/>
		/// created successfully by an SDL_Vulkan_CreateSurface() call.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VulkanDestroySurface([NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR")] VkSurfaceKHR surface, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] VkAllocationCallbacks* allocator)
		{
			VulkanDestroySurfaceNative(instance, surface, allocator);
		}

		/// <summary>
		/// Destroy the Vulkan rendering surface of a window.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Vulkan_CreateSurface<br/>
		/// was called after SDL_CreateWindow.<br/>
		/// The `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled and `surface` must have been<br/>
		/// created successfully by an SDL_Vulkan_CreateSurface() call.<br/>
		/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
		/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_DestroySurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VulkanDestroySurface([NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "VkSurfaceKHR")] VkSurfaceKHR surface, [NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VkAllocationCallbacks const *")] ref VkAllocationCallbacks allocator)
		{
			fixed (VkAllocationCallbacks* pallocator = &allocator)
			{
				VulkanDestroySurfaceNative(instance, surface, (VkAllocationCallbacks*)pallocator);
			}
		}

		/// <summary>
		/// Query support for presentation via a given physical device and queue<br/>
		/// family.<br/>
		/// The `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_GetPresentationSupport")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte VulkanGetPresentationSupportNative([NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "queueFamilyIndex")] [NativeName(NativeNameType.Type, "Uint32")] uint queueFamilyIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<VkInstance, VkPhysicalDevice, uint, byte>)funcTable[1326])(instance, physicalDevice, queueFamilyIndex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<VkInstance, VkPhysicalDevice, uint, byte>)funcTable[1326])(instance, physicalDevice, queueFamilyIndex);
			#endif
		}

		/// <summary>
		/// Query support for presentation via a given physical device and queue<br/>
		/// family.<br/>
		/// The `instance` must have been created with extensions returned by<br/>
		/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Vulkan_GetPresentationSupport")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool VulkanGetPresentationSupport([NativeName(NativeNameType.Param, "instance")] [NativeName(NativeNameType.Type, "VkInstance")] VkInstance instance, [NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "queueFamilyIndex")] [NativeName(NativeNameType.Type, "Uint32")] uint queueFamilyIndex)
		{
			byte ret = VulkanGetPresentationSupportNative(instance, physicalDevice, queueFamilyIndex);
			return ret != 0;
		}

	}
}
