// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters '<br/>
		/// \<br/>
		/// *' (match everything) and '?' (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters '<br/>
		/// \<br/>
		/// *' and '?' never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] SDLGlobFlags flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppattern = pattern)
			{
				fixed (int* pcount = &count)
				{
					byte** ret = GlobDirectoryNative(path, (byte*)ppattern, flags, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters '<br/>
		/// \<br/>
		/// *' (match everything) and '?' (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters '<br/>
		/// \<br/>
		/// *' and '?' never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] byte* path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] SDLGlobFlags flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobDirectoryNative(path, pStr0, flags, (int*)pcount);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters '<br/>
		/// \<br/>
		/// *' (match everything) and '?' (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters '<br/>
		/// \<br/>
		/// *' and '?' never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ref byte path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ref byte pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] SDLGlobFlags flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = &path)
			{
				fixed (byte* ppattern = &pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobDirectoryNative((byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters '<br/>
		/// \<br/>
		/// *' (match everything) and '?' (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters '<br/>
		/// \<br/>
		/// *' and '?' never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] SDLGlobFlags flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (byte* ppath = path)
			{
				fixed (byte* ppattern = pattern)
				{
					fixed (int* pcount = &count)
					{
						byte** ret = GlobDirectoryNative((byte*)ppath, (byte*)ppattern, flags, (int*)pcount);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
		/// Files are filtered out if they don't match the string in `pattern`, which<br/>
		/// may contain wildcard characters '<br/>
		/// \<br/>
		/// *' (match everything) and '?' (match one<br/>
		/// character). If pattern is NULL, no filtering is done and all results are<br/>
		/// returned. Subdirectories are permitted, and are specified with a path<br/>
		/// separator of '/'. Wildcard characters '<br/>
		/// \<br/>
		/// *' and '?' never match a path<br/>
		/// separator.<br/>
		/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
		/// case-insensitive.<br/>
		/// The returned array is always NULL-terminated, for your iterating<br/>
		/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
		/// number of items in the array, not counting the NULL terminator.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GlobDirectory")]
		[return: NativeName(NativeNameType.Type, "char * *")]
		public static byte** GlobDirectory([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "char const *")] string path, [NativeName(NativeNameType.Param, "pattern")] [NativeName(NativeNameType.Type, "char const *")] string pattern, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "SDL_GlobFlags")] SDLGlobFlags flags, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (pattern != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(pattern, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (int* pcount = &count)
			{
				byte** ret = GlobDirectoryNative(pStr0, pStr1, flags, (int*)pcount);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get what the system believes is the "current working directory."<br/>
		/// For systems without a concept of a current working directory, this will<br/>
		/// still attempt to provide something reasonable.<br/>
		/// SDL does not provide a means to _change_ the current working directory; for<br/>
		/// platforms without this concept, this would cause surprises with file access<br/>
		/// outside of SDL.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDirectory")]
		[return: NativeName(NativeNameType.Type, "char *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCurrentDirectoryNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[830])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[830])();
			#endif
		}

		/// <summary>
		/// Get what the system believes is the "current working directory."<br/>
		/// For systems without a concept of a current working directory, this will<br/>
		/// still attempt to provide something reasonable.<br/>
		/// SDL does not provide a means to _change_ the current working directory; for<br/>
		/// platforms without this concept, this would cause surprises with file access<br/>
		/// outside of SDL.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDirectory")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static byte* GetCurrentDirectory()
		{
			byte* ret = GetCurrentDirectoryNative();
			return ret;
		}

		/// <summary>
		/// Get what the system believes is the "current working directory."<br/>
		/// For systems without a concept of a current working directory, this will<br/>
		/// still attempt to provide something reasonable.<br/>
		/// SDL does not provide a means to _change_ the current working directory; for<br/>
		/// platforms without this concept, this would cause surprises with file access<br/>
		/// outside of SDL.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDirectory")]
		[return: NativeName(NativeNameType.Type, "char *")]
		public static string GetCurrentDirectoryS()
		{
			string ret = Utils.DecodeStringUTF8(GetCurrentDirectoryNative());
			return ret;
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUSupportsShaderFormatsNative([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUShaderFormat, byte*, byte>)funcTable[831])(formatFlags, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLGPUShaderFormat, nint, byte>)funcTable[831])(formatFlags, (nint)name);
			#endif
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = GPUSupportsShaderFormatsNative(formatFlags, name);
			return ret != 0;
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = GPUSupportsShaderFormatsNative(formatFlags, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = GPUSupportsShaderFormatsNative(formatFlags, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsShaderFormats")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsShaderFormats([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = GPUSupportsShaderFormatsNative(formatFlags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUSupportsPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[832])(props);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[832])(props);
			#endif
		}

		/// <summary>
		/// Checks for GPU runtime support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GPUSupportsProperties")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GPUSupportsProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			byte ret = GPUSupportsPropertiesNative(props);
			return ret != 0;
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUDevice* CreateGPUDeviceNative([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] byte debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUShaderFormat, byte, byte*, SDLGPUDevice*>)funcTable[833])(formatFlags, debugMode, name);
			#else
			return (SDLGPUDevice*)((delegate* unmanaged[Cdecl]<SDLGPUShaderFormat, byte, nint, nint>)funcTable[833])(formatFlags, debugMode, (nint)name);
			#endif
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevice* CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			SDLGPUDevice* ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, name);
			return ret;
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevice* CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLGPUDevice* ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevice* CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLGPUDevice* ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevice* CreateGPUDevice([NativeName(NativeNameType.Param, "format_flags")] [NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")] SDLGPUShaderFormat formatFlags, [NativeName(NativeNameType.Param, "debug_mode")] [NativeName(NativeNameType.Type, "bool")] bool debugMode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGPUDevice* ret = CreateGPUDeviceNative(formatFlags, debugMode ? (byte)1 : (byte)0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode<br/>
		/// properties and validations, defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer<br/>
		/// energy efficiency over maximum GPU performance, defaults to false.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to<br/>
		/// use, if a specific one is desired.<br/>
		/// These are the current shader format properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to<br/>
		/// provide shaders for an NDA platform.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to<br/>
		/// provide SPIR-V shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to<br/>
		/// provide DXBC shaders if applicable<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to<br/>
		/// provide DXIL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to<br/>
		/// provide MSL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to<br/>
		/// provide Metal shader libraries if applicable.<br/>
		/// With the D3D12 renderer:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to<br/>
		/// use for all vertex semantics, default is "TEXCOORD".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDeviceWithProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUDevice* CreateGPUDeviceWithPropertiesNative([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLGPUDevice*>)funcTable[834])(props);
			#else
			return (SDLGPUDevice*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[834])(props);
			#endif
		}

		/// <summary>
		/// Creates a GPU context.<br/>
		/// These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode<br/>
		/// properties and validations, defaults to true.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer<br/>
		/// energy efficiency over maximum GPU performance, defaults to false.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to<br/>
		/// use, if a specific one is desired.<br/>
		/// These are the current shader format properties:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to<br/>
		/// provide shaders for an NDA platform.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to<br/>
		/// provide SPIR-V shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to<br/>
		/// provide DXBC shaders if applicable<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to<br/>
		/// provide DXIL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to<br/>
		/// provide MSL shaders if applicable.<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to<br/>
		/// provide Metal shader libraries if applicable.<br/>
		/// With the D3D12 renderer:<br/>
		/// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to<br/>
		/// use for all vertex semantics, default is "TEXCOORD".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUDeviceWithProperties")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUDevice *")]
		public static SDLGPUDevice* CreateGPUDeviceWithProperties([NativeName(NativeNameType.Param, "props")] [NativeName(NativeNameType.Type, "SDL_PropertiesID")] uint props)
		{
			SDLGPUDevice* ret = CreateGPUDeviceWithPropertiesNative(props);
			return ret;
		}

		/// <summary>
		/// Destroys a GPU context previously returned by SDL_CreateGPUDevice.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyGPUDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, void>)funcTable[835])(device);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[835])((nint)device);
			#endif
		}

		/// <summary>
		/// Destroys a GPU context previously returned by SDL_CreateGPUDevice.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			DestroyGPUDeviceNative(device);
		}

		/// <summary>
		/// Destroys a GPU context previously returned by SDL_CreateGPUDevice.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				DestroyGPUDeviceNative((SDLGPUDevice*)pdevice);
			}
		}

		/// <summary>
		/// Get the number of GPU drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGPUDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGPUDriversNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[836])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[836])();
			#endif
		}

		/// <summary>
		/// Get the number of GPU drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGPUDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGPUDrivers()
		{
			int ret = GetNumGPUDriversNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a built in GPU driver.<br/>
		/// The GPU drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",<br/>
		/// "metal" or "direct3d12". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGPUDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[837])(index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[837])(index);
			#endif
		}

		/// <summary>
		/// Get the name of a built in GPU driver.<br/>
		/// The GPU drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",<br/>
		/// "metal" or "direct3d12". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGPUDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = GetGPUDriverNative(index);
			return ret;
		}

		/// <summary>
		/// Get the name of a built in GPU driver.<br/>
		/// The GPU drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",<br/>
		/// "metal" or "direct3d12". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGPUDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(GetGPUDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGPUDeviceDriverNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte*>)funcTable[838])(device);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[838])((nint)device);
			#endif
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGPUDeviceDriver([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			byte* ret = GetGPUDeviceDriverNative(device);
			return ret;
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGPUDeviceDriverS([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			string ret = Utils.DecodeStringUTF8(GetGPUDeviceDriverNative(device));
			return ret;
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGPUDeviceDriver([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte* ret = GetGPUDeviceDriverNative((SDLGPUDevice*)pdevice);
				return ret;
			}
		}

		/// <summary>
		/// Returns the name of the backend used to create this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUDeviceDriver")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGPUDeviceDriverS([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				string ret = Utils.DecodeStringUTF8(GetGPUDeviceDriverNative((SDLGPUDevice*)pdevice));
				return ret;
			}
		}

		/// <summary>
		/// Returns the supported shader formats for this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUShaderFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUShaderFormat GetGPUShaderFormatsNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUShaderFormat>)funcTable[839])(device);
			#else
			return (SDLGPUShaderFormat)((delegate* unmanaged[Cdecl]<nint, SDLGPUShaderFormat>)funcTable[839])((nint)device);
			#endif
		}

		/// <summary>
		/// Returns the supported shader formats for this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUShaderFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")]
		public static SDLGPUShaderFormat GetGPUShaderFormats([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			SDLGPUShaderFormat ret = GetGPUShaderFormatsNative(device);
			return ret;
		}

		/// <summary>
		/// Returns the supported shader formats for this GPU context.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUShaderFormats")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShaderFormat")]
		public static SDLGPUShaderFormat GetGPUShaderFormats([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUShaderFormat ret = GetGPUShaderFormatsNative((SDLGPUDevice*)pdevice);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUComputePipeline* CreateGPUComputePipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUComputePipelineCreateInfo*, SDLGPUComputePipeline*>)funcTable[840])(device, createinfo);
			#else
			return (SDLGPUComputePipeline*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[840])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfo* createinfo)
		{
			SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] SDLGPUComputePipelineCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] ref SDLGPUComputePipelineCreateInfo createinfo)
		{
			fixed (SDLGPUComputePipelineCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative(device, (SDLGPUComputePipelineCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a compute workflow.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
		/// read-only storage buffers<br/>
		/// - 1: Read-write storage textures, followed by read-write storage buffers<br/>
		/// - 2: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-only storage buffers<br/>
		/// - (u[n], space1): Read-write storage textures, followed by read-write<br/>
		/// storage buffers<br/>
		/// - (b[n], space2): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[buffer]]: Uniform buffers, followed by read-only storage buffers,<br/>
		/// followed by read-write storage buffers<br/>
		/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
		/// followed by read-write storage textures<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")]
		public static SDLGPUComputePipeline* CreateGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipelineCreateInfo const *")] ref SDLGPUComputePipelineCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUComputePipelineCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUComputePipeline* ret = CreateGPUComputePipelineNative((SDLGPUDevice*)pdevice, (SDLGPUComputePipelineCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] SDLGPUGraphicsPipelineCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUGraphicsPipelineCreateInfo*, SDLGPUGraphicsPipeline*>)funcTable[841])(device, createinfo);
			#else
			return (SDLGPUGraphicsPipeline*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[841])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] SDLGPUGraphicsPipelineCreateInfo* createinfo)
		{
			SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] SDLGPUGraphicsPipelineCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] ref SDLGPUGraphicsPipelineCreateInfo createinfo)
		{
			fixed (SDLGPUGraphicsPipelineCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative(device, (SDLGPUGraphicsPipelineCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a pipeline object to be used in a graphics workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")]
		public static SDLGPUGraphicsPipeline* CreateGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipelineCreateInfo const *")] ref SDLGPUGraphicsPipelineCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUGraphicsPipelineCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUGraphicsPipeline* ret = CreateGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, (SDLGPUGraphicsPipelineCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUSampler* CreateGPUSamplerNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] SDLGPUSamplerCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUSamplerCreateInfo*, SDLGPUSampler*>)funcTable[842])(device, createinfo);
			#else
			return (SDLGPUSampler*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[842])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] SDLGPUSamplerCreateInfo* createinfo)
		{
			SDLGPUSampler* ret = CreateGPUSamplerNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] SDLGPUSamplerCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUSampler* ret = CreateGPUSamplerNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] ref SDLGPUSamplerCreateInfo createinfo)
		{
			fixed (SDLGPUSamplerCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUSampler* ret = CreateGPUSamplerNative(device, (SDLGPUSamplerCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a sampler object to be used when binding textures in a graphics<br/>
		/// workflow.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUSampler")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUSampler *")]
		public static SDLGPUSampler* CreateGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUSamplerCreateInfo const *")] ref SDLGPUSamplerCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUSamplerCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUSampler* ret = CreateGPUSamplerNative((SDLGPUDevice*)pdevice, (SDLGPUSamplerCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUGraphicsPipeline.<br/>
		/// Shader semantics other than system-value semantics do not matter in D3D12<br/>
		/// and for ease of use the SDL implementation assumes that non system-value<br/>
		/// semantics will all be TEXCOORD. If you are using HLSL as the shader source<br/>
		/// language, your vertex semantics should start at TEXCOORD0 and increment<br/>
		/// like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic<br/>
		/// prefix to something other than TEXCOORD you can use<br/>
		/// SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with<br/>
		/// SDL_CreateGPUDeviceWithProperties().<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUShader* CreateGPUShaderNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] SDLGPUShaderCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUShaderCreateInfo*, SDLGPUShader*>)funcTable[843])(device, createinfo);
			#else
			return (SDLGPUShader*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[843])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUGraphicsPipeline.<br/>
		/// Shader semantics other than system-value semantics do not matter in D3D12<br/>
		/// and for ease of use the SDL implementation assumes that non system-value<br/>
		/// semantics will all be TEXCOORD. If you are using HLSL as the shader source<br/>
		/// language, your vertex semantics should start at TEXCOORD0 and increment<br/>
		/// like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic<br/>
		/// prefix to something other than TEXCOORD you can use<br/>
		/// SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with<br/>
		/// SDL_CreateGPUDeviceWithProperties().<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] SDLGPUShaderCreateInfo* createinfo)
		{
			SDLGPUShader* ret = CreateGPUShaderNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUGraphicsPipeline.<br/>
		/// Shader semantics other than system-value semantics do not matter in D3D12<br/>
		/// and for ease of use the SDL implementation assumes that non system-value<br/>
		/// semantics will all be TEXCOORD. If you are using HLSL as the shader source<br/>
		/// language, your vertex semantics should start at TEXCOORD0 and increment<br/>
		/// like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic<br/>
		/// prefix to something other than TEXCOORD you can use<br/>
		/// SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with<br/>
		/// SDL_CreateGPUDeviceWithProperties().<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] SDLGPUShaderCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUShader* ret = CreateGPUShaderNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUGraphicsPipeline.<br/>
		/// Shader semantics other than system-value semantics do not matter in D3D12<br/>
		/// and for ease of use the SDL implementation assumes that non system-value<br/>
		/// semantics will all be TEXCOORD. If you are using HLSL as the shader source<br/>
		/// language, your vertex semantics should start at TEXCOORD0 and increment<br/>
		/// like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic<br/>
		/// prefix to something other than TEXCOORD you can use<br/>
		/// SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with<br/>
		/// SDL_CreateGPUDeviceWithProperties().<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] ref SDLGPUShaderCreateInfo createinfo)
		{
			fixed (SDLGPUShaderCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUShader* ret = CreateGPUShaderNative(device, (SDLGPUShaderCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a shader to be used when creating a graphics pipeline.<br/>
		/// Shader resource bindings must be authored to follow a particular order<br/>
		/// depending on the shader format.<br/>
		/// For SPIR-V shaders, use the following resource sets:<br/>
		/// For vertex shaders:<br/>
		/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 1: Uniform buffers<br/>
		/// For fragment shaders:<br/>
		/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
		/// buffers<br/>
		/// - 3: Uniform buffers<br/>
		/// For DXBC and DXIL shaders, use the following register order:<br/>
		/// For vertex shaders:<br/>
		/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space1): Uniform buffers<br/>
		/// For pixel shaders:<br/>
		/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
		/// by storage buffers<br/>
		/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
		/// textures<br/>
		/// - (b[n], space3): Uniform buffers<br/>
		/// For MSL/metallib, use the following order:<br/>
		/// - [[texture]]: Sampled textures, followed by storage textures<br/>
		/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
		/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
		/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
		/// Rather than manually authoring vertex buffer indices, use the<br/>
		/// [[stage_in]] attribute which will automatically use the vertex input<br/>
		/// information from the SDL_GPUGraphicsPipeline.<br/>
		/// Shader semantics other than system-value semantics do not matter in D3D12<br/>
		/// and for ease of use the SDL implementation assumes that non system-value<br/>
		/// semantics will all be TEXCOORD. If you are using HLSL as the shader source<br/>
		/// language, your vertex semantics should start at TEXCOORD0 and increment<br/>
		/// like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic<br/>
		/// prefix to something other than TEXCOORD you can use<br/>
		/// SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with<br/>
		/// SDL_CreateGPUDeviceWithProperties().<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUShader")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUShader *")]
		public static SDLGPUShader* CreateGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUShaderCreateInfo const *")] ref SDLGPUShaderCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUShaderCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUShader* ret = CreateGPUShaderNative((SDLGPUDevice*)pdevice, (SDLGPUShaderCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// There are optional properties that can be provided through<br/>
		/// SDL_GPUTextureCreateInfo's `props`. These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this red intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this green intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this blue intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this alpha intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)<br/>
		/// if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear<br/>
		/// the texture to a depth of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8`: (Direct3D 12<br/>
		/// only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,<br/>
		/// clear the texture to a stencil of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTexture* CreateGPUTextureNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] SDLGPUTextureCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureCreateInfo*, SDLGPUTexture*>)funcTable[844])(device, createinfo);
			#else
			return (SDLGPUTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[844])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// There are optional properties that can be provided through<br/>
		/// SDL_GPUTextureCreateInfo's `props`. These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this red intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this green intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this blue intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this alpha intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)<br/>
		/// if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear<br/>
		/// the texture to a depth of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8`: (Direct3D 12<br/>
		/// only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,<br/>
		/// clear the texture to a stencil of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] SDLGPUTextureCreateInfo* createinfo)
		{
			SDLGPUTexture* ret = CreateGPUTextureNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// There are optional properties that can be provided through<br/>
		/// SDL_GPUTextureCreateInfo's `props`. These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this red intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this green intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this blue intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this alpha intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)<br/>
		/// if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear<br/>
		/// the texture to a depth of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8`: (Direct3D 12<br/>
		/// only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,<br/>
		/// clear the texture to a stencil of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] SDLGPUTextureCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUTexture* ret = CreateGPUTextureNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// There are optional properties that can be provided through<br/>
		/// SDL_GPUTextureCreateInfo's `props`. These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this red intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this green intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this blue intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this alpha intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)<br/>
		/// if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear<br/>
		/// the texture to a depth of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8`: (Direct3D 12<br/>
		/// only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,<br/>
		/// clear the texture to a stencil of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] ref SDLGPUTextureCreateInfo createinfo)
		{
			fixed (SDLGPUTextureCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUTexture* ret = CreateGPUTextureNative(device, (SDLGPUTextureCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a texture object to be used in graphics or compute workflows.<br/>
		/// The contents of this texture are undefined until data is written to the<br/>
		/// texture.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
		/// If you request a sample count higher than the hardware supports, the<br/>
		/// implementation will automatically fall back to the highest available sample<br/>
		/// count.<br/>
		/// There are optional properties that can be provided through<br/>
		/// SDL_GPUTextureCreateInfo's `props`. These are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this red intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this green intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this blue intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if<br/>
		/// the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture<br/>
		/// to a color with this alpha intensity. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)<br/>
		/// if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear<br/>
		/// the texture to a depth of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_UINT8`: (Direct3D 12<br/>
		/// only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,<br/>
		/// clear the texture to a stencil of this value. Defaults to zero.<br/>
		/// - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed<br/>
		/// in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTexture *")]
		public static SDLGPUTexture* CreateGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTextureCreateInfo const *")] ref SDLGPUTextureCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTextureCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUTexture* ret = CreateGPUTextureNative((SDLGPUDevice*)pdevice, (SDLGPUTextureCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// If you use a STORAGE flag, the data in the buffer must respect std140<br/>
		/// layout conventions. In practical terms this means you must ensure that vec3<br/>
		/// and vec4 fields are 16-byte aligned.<br/>
		/// For better understanding of underlying concepts and memory management with<br/>
		/// SDL GPU API, you may refer<br/>
		/// [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)<br/>
		/// .<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUBuffer* CreateGPUBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] SDLGPUBufferCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUBufferCreateInfo*, SDLGPUBuffer*>)funcTable[845])(device, createinfo);
			#else
			return (SDLGPUBuffer*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[845])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// If you use a STORAGE flag, the data in the buffer must respect std140<br/>
		/// layout conventions. In practical terms this means you must ensure that vec3<br/>
		/// and vec4 fields are 16-byte aligned.<br/>
		/// For better understanding of underlying concepts and memory management with<br/>
		/// SDL GPU API, you may refer<br/>
		/// [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)<br/>
		/// .<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] SDLGPUBufferCreateInfo* createinfo)
		{
			SDLGPUBuffer* ret = CreateGPUBufferNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// If you use a STORAGE flag, the data in the buffer must respect std140<br/>
		/// layout conventions. In practical terms this means you must ensure that vec3<br/>
		/// and vec4 fields are 16-byte aligned.<br/>
		/// For better understanding of underlying concepts and memory management with<br/>
		/// SDL GPU API, you may refer<br/>
		/// [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)<br/>
		/// .<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] SDLGPUBufferCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUBuffer* ret = CreateGPUBufferNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// If you use a STORAGE flag, the data in the buffer must respect std140<br/>
		/// layout conventions. In practical terms this means you must ensure that vec3<br/>
		/// and vec4 fields are 16-byte aligned.<br/>
		/// For better understanding of underlying concepts and memory management with<br/>
		/// SDL GPU API, you may refer<br/>
		/// [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)<br/>
		/// .<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] ref SDLGPUBufferCreateInfo createinfo)
		{
			fixed (SDLGPUBufferCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUBuffer* ret = CreateGPUBufferNative(device, (SDLGPUBufferCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a buffer object to be used in graphics or compute workflows.<br/>
		/// The contents of this buffer are undefined until data is written to the<br/>
		/// buffer.<br/>
		/// Note that certain combinations of usage flags are invalid. For example, a<br/>
		/// buffer cannot have both the VERTEX and INDEX flags.<br/>
		/// If you use a STORAGE flag, the data in the buffer must respect std140<br/>
		/// layout conventions. In practical terms this means you must ensure that vec3<br/>
		/// and vec4 fields are 16-byte aligned.<br/>
		/// For better understanding of underlying concepts and memory management with<br/>
		/// SDL GPU API, you may refer<br/>
		/// [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)<br/>
		/// .<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in<br/>
		/// debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUBuffer *")]
		public static SDLGPUBuffer* CreateGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUBufferCreateInfo const *")] ref SDLGPUBufferCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBufferCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUBuffer* ret = CreateGPUBufferNative((SDLGPUDevice*)pdevice, (SDLGPUBufferCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// Download buffers can be particularly expensive to create, so it is good<br/>
		/// practice to reuse them if data will be downloaded regularly.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTransferBuffer* CreateGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] SDLGPUTransferBufferCreateInfo* createinfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBufferCreateInfo*, SDLGPUTransferBuffer*>)funcTable[846])(device, createinfo);
			#else
			return (SDLGPUTransferBuffer*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[846])((nint)device, (nint)createinfo);
			#endif
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// Download buffers can be particularly expensive to create, so it is good<br/>
		/// practice to reuse them if data will be downloaded regularly.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] SDLGPUTransferBufferCreateInfo* createinfo)
		{
			SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative(device, createinfo);
			return ret;
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// Download buffers can be particularly expensive to create, so it is good<br/>
		/// practice to reuse them if data will be downloaded regularly.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] SDLGPUTransferBufferCreateInfo* createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative((SDLGPUDevice*)pdevice, createinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// Download buffers can be particularly expensive to create, so it is good<br/>
		/// practice to reuse them if data will be downloaded regularly.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] ref SDLGPUTransferBufferCreateInfo createinfo)
		{
			fixed (SDLGPUTransferBufferCreateInfo* pcreateinfo = &createinfo)
			{
				SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative(device, (SDLGPUTransferBufferCreateInfo*)pcreateinfo);
				return ret;
			}
		}

		/// <summary>
		/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
		/// graphics resources.<br/>
		/// Download buffers can be particularly expensive to create, so it is good<br/>
		/// practice to reuse them if data will be downloaded regularly.<br/>
		/// There are optional properties that can be provided through `props`. These<br/>
		/// are the supported properties:<br/>
		/// - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be<br/>
		/// displayed in debugging tools.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")]
		public static SDLGPUTransferBuffer* CreateGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "createinfo")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferCreateInfo const *")] ref SDLGPUTransferBufferCreateInfo createinfo)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBufferCreateInfo* pcreateinfo = &createinfo)
				{
					SDLGPUTransferBuffer* ret = CreateGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBufferCreateInfo*)pcreateinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUBufferNameNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUBuffer*, byte*, void>)funcTable[847])(device, buffer, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[847])((nint)device, (nint)buffer, (nint)text);
			#endif
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			SetGPUBufferNameNative(device, buffer, text);
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, text);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetGPUBufferNameNative(device, buffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				SetGPUBufferNameNative(device, buffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetGPUBufferNameNative(device, buffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = text)
				{
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUBufferNameNative((SDLGPUDevice*)pdevice, buffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				fixed (byte* ptext = text)
				{
					SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUBufferNameNative(device, (SDLGPUBuffer*)pbuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					fixed (byte* ptext = &text)
					{
						SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					fixed (byte* ptext = text)
					{
						SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a buffer.<br/>
		/// You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// buffer is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBufferName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBufferName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (text != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(text);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SetGPUBufferNameNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUTextureNameNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTexture*, byte*, void>)funcTable[848])(device, texture, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[848])((nint)device, (nint)texture, (nint)text);
			#endif
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			SetGPUTextureNameNative(device, texture, text);
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, text);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, text);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetGPUTextureNameNative(device, texture, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				SetGPUTextureNameNative(device, texture, (byte*)ptext);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetGPUTextureNameNative(device, texture, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (byte* ptext = text)
				{
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUTextureNameNative((SDLGPUDevice*)pdevice, texture, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				fixed (byte* ptext = &text)
				{
					SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				fixed (byte* ptext = text)
				{
					SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetGPUTextureNameNative(device, (SDLGPUTexture*)ptexture, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					fixed (byte* ptext = &text)
					{
						SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					fixed (byte* ptext = text)
					{
						SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// Sets an arbitrary string constant to label a texture.<br/>
		/// You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with<br/>
		/// SDL_CreateGPUTexture instead of this function to avoid thread safety<br/>
		/// issues.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe, you must make sure the<br/>
		/// texture is not simultaneously used by any other thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUTextureName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUTextureName([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (text != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(text);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SetGPUTextureNameNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InsertGPUDebugLabelNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte*, void>)funcTable[849])(commandBuffer, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[849])((nint)commandBuffer, (nint)text);
			#endif
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			InsertGPUDebugLabelNative(commandBuffer, text);
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] byte* text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, text);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				InsertGPUDebugLabelNative(commandBuffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				InsertGPUDebugLabelNative(commandBuffer, (byte*)ptext);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertGPUDebugLabelNative(commandBuffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ref byte text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* ptext = &text)
				{
					InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* ptext = text)
				{
					InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// Inserts an arbitrary string label into the command buffer callstream.<br/>
		/// Useful for debugging.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InsertGPUDebugLabel")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void InsertGPUDebugLabel([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char const *")] string text)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertGPUDebugLabelNative((SDLGPUCommandBuffer*)pcommandBuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUDebugGroupNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte*, void>)funcTable[850])(commandBuffer, name);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[850])((nint)commandBuffer, (nint)name);
			#endif
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			PushGPUDebugGroupNative(commandBuffer, name);
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, name);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				PushGPUDebugGroupNative(commandBuffer, (byte*)pname);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				PushGPUDebugGroupNative(commandBuffer, (byte*)pname);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushGPUDebugGroupNative(commandBuffer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ref byte name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* pname = &name)
				{
					PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)pname);
				}
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (byte* pname = name)
				{
					PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, (byte*)pname);
				}
			}
		}

		/// <summary>
		/// Begins a debug group with an arbitary name.<br/>
		/// Used for denoting groups of calls when viewing the command buffer<br/>
		/// callstream in a graphics debugging tool.<br/>
		/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
		/// SDL_PopGPUDebugGroup.<br/>
		/// On some backends (e.g. Metal), pushing a debug group during a<br/>
		/// render/blit/compute pass will create a group that is scoped to the native<br/>
		/// pass rather than the command buffer. For best results, if you push a debug<br/>
		/// group during a pass, always pop it in the same pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PushGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Ends the most-recently pushed debug group.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PopGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopGPUDebugGroupNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, void>)funcTable[851])(commandBuffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[851])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Ends the most-recently pushed debug group.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PopGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PopGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			PopGPUDebugGroupNative(commandBuffer);
		}

		/// <summary>
		/// Ends the most-recently pushed debug group.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PopGPUDebugGroup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PopGPUDebugGroup([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PopGPUDebugGroupNative((SDLGPUCommandBuffer*)pcommandBuffer);
			}
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUTextureNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTexture*, void>)funcTable[852])(device, texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[852])((nint)device, (nint)texture);
			#endif
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			ReleaseGPUTextureNative(device, texture);
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUTextureNative((SDLGPUDevice*)pdevice, texture);
			}
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				ReleaseGPUTextureNative(device, (SDLGPUTexture*)ptexture);
			}
		}

		/// <summary>
		/// Frees the given texture as soon as it is safe to do so.<br/>
		/// You must not reference the texture after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTexture([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					ReleaseGPUTextureNative((SDLGPUDevice*)pdevice, (SDLGPUTexture*)ptexture);
				}
			}
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUSamplerNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] SDLGPUSampler* sampler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUSampler*, void>)funcTable[853])(device, sampler);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[853])((nint)device, (nint)sampler);
			#endif
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] SDLGPUSampler* sampler)
		{
			ReleaseGPUSamplerNative(device, sampler);
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] SDLGPUSampler* sampler)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUSamplerNative((SDLGPUDevice*)pdevice, sampler);
			}
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] ref SDLGPUSampler sampler)
		{
			fixed (SDLGPUSampler* psampler = &sampler)
			{
				ReleaseGPUSamplerNative(device, (SDLGPUSampler*)psampler);
			}
		}

		/// <summary>
		/// Frees the given sampler as soon as it is safe to do so.<br/>
		/// You must not reference the sampler after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUSampler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUSampler([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "sampler")] [NativeName(NativeNameType.Type, "SDL_GPUSampler *")] ref SDLGPUSampler sampler)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUSampler* psampler = &sampler)
				{
					ReleaseGPUSamplerNative((SDLGPUDevice*)pdevice, (SDLGPUSampler*)psampler);
				}
			}
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUBuffer*, void>)funcTable[854])(device, buffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[854])((nint)device, (nint)buffer);
			#endif
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer)
		{
			ReleaseGPUBufferNative(device, buffer);
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUBufferNative((SDLGPUDevice*)pdevice, buffer);
			}
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				ReleaseGPUBufferNative(device, (SDLGPUBuffer*)pbuffer);
			}
		}

		/// <summary>
		/// Frees the given buffer as soon as it is safe to do so.<br/>
		/// You must not reference the buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					ReleaseGPUBufferNative((SDLGPUDevice*)pdevice, (SDLGPUBuffer*)pbuffer);
				}
			}
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBuffer*, void>)funcTable[855])(device, transferBuffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[855])((nint)device, (nint)transferBuffer);
			#endif
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			ReleaseGPUTransferBufferNative(device, transferBuffer);
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUTransferBufferNative((SDLGPUDevice*)pdevice, transferBuffer);
			}
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
			{
				ReleaseGPUTransferBufferNative(device, (SDLGPUTransferBuffer*)ptransferBuffer);
			}
		}

		/// <summary>
		/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
		/// You must not reference the transfer buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
				{
					ReleaseGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBuffer*)ptransferBuffer);
				}
			}
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUComputePipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUComputePipeline*, void>)funcTable[856])(device, computePipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[856])((nint)device, (nint)computePipeline);
			#endif
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			ReleaseGPUComputePipelineNative(device, computePipeline);
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUComputePipelineNative((SDLGPUDevice*)pdevice, computePipeline);
			}
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
			{
				ReleaseGPUComputePipelineNative(device, (SDLGPUComputePipeline*)pcomputePipeline);
			}
		}

		/// <summary>
		/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the compute pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUComputePipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
				{
					ReleaseGPUComputePipelineNative((SDLGPUDevice*)pdevice, (SDLGPUComputePipeline*)pcomputePipeline);
				}
			}
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUShaderNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] SDLGPUShader* shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUShader*, void>)funcTable[857])(device, shader);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[857])((nint)device, (nint)shader);
			#endif
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] SDLGPUShader* shader)
		{
			ReleaseGPUShaderNative(device, shader);
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] SDLGPUShader* shader)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUShaderNative((SDLGPUDevice*)pdevice, shader);
			}
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] ref SDLGPUShader shader)
		{
			fixed (SDLGPUShader* pshader = &shader)
			{
				ReleaseGPUShaderNative(device, (SDLGPUShader*)pshader);
			}
		}

		/// <summary>
		/// Frees the given shader as soon as it is safe to do so.<br/>
		/// You must not reference the shader after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUShader")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUShader([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "SDL_GPUShader *")] ref SDLGPUShader shader)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUShader* pshader = &shader)
				{
					ReleaseGPUShaderNative((SDLGPUDevice*)pdevice, (SDLGPUShader*)pshader);
				}
			}
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUGraphicsPipelineNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUGraphicsPipeline*, void>)funcTable[858])(device, graphicsPipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[858])((nint)device, (nint)graphicsPipeline);
			#endif
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			ReleaseGPUGraphicsPipelineNative(device, graphicsPipeline);
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, graphicsPipeline);
			}
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
			{
				ReleaseGPUGraphicsPipelineNative(device, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
			}
		}

		/// <summary>
		/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
		/// You must not reference the graphics pipeline after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseGPUGraphicsPipeline([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
				{
					ReleaseGPUGraphicsPipelineNative((SDLGPUDevice*)pdevice, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
				}
			}
		}

		/// <summary>
		/// Acquire a command buffer.<br/>
		/// This command buffer is managed by the implementation and should not be<br/>
		/// freed by the user. The command buffer may only be used on the thread it was<br/>
		/// acquired on. The command buffer should be submitted on the thread it was<br/>
		/// acquired on.<br/>
		/// It is valid to acquire multiple command buffers on the same thread at once.<br/>
		/// In fact a common design pattern is to acquire two command buffers per frame<br/>
		/// where one is dedicated to render and compute passes and the other is<br/>
		/// dedicated to copy passes and other preparatory work such as generating<br/>
		/// mipmaps. Interleaving commands between the two command buffers reduces the<br/>
		/// total amount of passes overall which improves rendering performance.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUCommandBuffer* AcquireGPUCommandBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUCommandBuffer*>)funcTable[859])(device);
			#else
			return (SDLGPUCommandBuffer*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[859])((nint)device);
			#endif
		}

		/// <summary>
		/// Acquire a command buffer.<br/>
		/// This command buffer is managed by the implementation and should not be<br/>
		/// freed by the user. The command buffer may only be used on the thread it was<br/>
		/// acquired on. The command buffer should be submitted on the thread it was<br/>
		/// acquired on.<br/>
		/// It is valid to acquire multiple command buffers on the same thread at once.<br/>
		/// In fact a common design pattern is to acquire two command buffers per frame<br/>
		/// where one is dedicated to render and compute passes and the other is<br/>
		/// dedicated to copy passes and other preparatory work such as generating<br/>
		/// mipmaps. Interleaving commands between the two command buffers reduces the<br/>
		/// total amount of passes overall which improves rendering performance.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")]
		public static SDLGPUCommandBuffer* AcquireGPUCommandBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device)
		{
			SDLGPUCommandBuffer* ret = AcquireGPUCommandBufferNative(device);
			return ret;
		}

		/// <summary>
		/// Acquire a command buffer.<br/>
		/// This command buffer is managed by the implementation and should not be<br/>
		/// freed by the user. The command buffer may only be used on the thread it was<br/>
		/// acquired on. The command buffer should be submitted on the thread it was<br/>
		/// acquired on.<br/>
		/// It is valid to acquire multiple command buffers on the same thread at once.<br/>
		/// In fact a common design pattern is to acquire two command buffers per frame<br/>
		/// where one is dedicated to render and compute passes and the other is<br/>
		/// dedicated to copy passes and other preparatory work such as generating<br/>
		/// mipmaps. Interleaving commands between the two command buffers reduces the<br/>
		/// total amount of passes overall which improves rendering performance.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUCommandBuffer")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")]
		public static SDLGPUCommandBuffer* AcquireGPUCommandBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUCommandBuffer* ret = AcquireGPUCommandBufferNative((SDLGPUDevice*)pdevice);
				return ret;
			}
		}

		/// <summary>
		/// Pushes data to a vertex uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUVertexUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUVertexUniformDataNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, uint, void*, uint, void>)funcTable[860])(commandBuffer, slotIndex, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[860])((nint)commandBuffer, slotIndex, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Pushes data to a vertex uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUVertexUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUVertexUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			PushGPUVertexUniformDataNative(commandBuffer, slotIndex, data, length);
		}

		/// <summary>
		/// Pushes data to a vertex uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUVertexUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUVertexUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUVertexUniformDataNative((SDLGPUCommandBuffer*)pcommandBuffer, slotIndex, data, length);
			}
		}

		/// <summary>
		/// Pushes data to a fragment uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUFragmentUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUFragmentUniformDataNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, uint, void*, uint, void>)funcTable[861])(commandBuffer, slotIndex, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[861])((nint)commandBuffer, slotIndex, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Pushes data to a fragment uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUFragmentUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUFragmentUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			PushGPUFragmentUniformDataNative(commandBuffer, slotIndex, data, length);
		}

		/// <summary>
		/// Pushes data to a fragment uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUFragmentUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUFragmentUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUFragmentUniformDataNative((SDLGPUCommandBuffer*)pcommandBuffer, slotIndex, data, length);
			}
		}

		/// <summary>
		/// Pushes data to a uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUComputeUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGPUComputeUniformDataNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, uint, void*, uint, void>)funcTable[862])(commandBuffer, slotIndex, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[862])((nint)commandBuffer, slotIndex, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Pushes data to a uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUComputeUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUComputeUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			PushGPUComputeUniformDataNative(commandBuffer, slotIndex, data, length);
		}

		/// <summary>
		/// Pushes data to a uniform slot on the command buffer.<br/>
		/// Subsequent draw calls will use this uniform data.<br/>
		/// The data being pushed must respect std140 layout conventions. In practical<br/>
		/// terms this means you must ensure that vec3 and vec4 fields are 16-byte<br/>
		/// aligned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushGPUComputeUniformData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushGPUComputeUniformData([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "slot_index")] [NativeName(NativeNameType.Type, "Uint32")] uint slotIndex, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				PushGPUComputeUniformDataNative((SDLGPUCommandBuffer*)pcommandBuffer, slotIndex, data, length);
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPURenderPass* BeginGPURenderPassNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUColorTargetInfo*, uint, SDLGPUDepthStencilTargetInfo*, SDLGPURenderPass*>)funcTable[863])(commandBuffer, colorTargetInfos, numColorTargets, depthStencilTargetInfo);
			#else
			return (SDLGPURenderPass*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, nint>)funcTable[863])((nint)commandBuffer, (nint)colorTargetInfos, numColorTargets, (nint)depthStencilTargetInfo);
			#endif
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, colorTargetInfos, numColorTargets, depthStencilTargetInfo);
			return ret;
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, colorTargetInfos, numColorTargets, depthStencilTargetInfo);
				return ret;
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
			{
				SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, depthStencilTargetInfo);
				return ret;
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] SDLGPUDepthStencilTargetInfo* depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
				{
					SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, depthStencilTargetInfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
			{
				SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, colorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
				return ret;
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] SDLGPUColorTargetInfo* colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
				{
					SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, colorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
			{
				fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
				{
					SDLGPURenderPass* ret = BeginGPURenderPassNative(commandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a render pass on a command buffer.<br/>
		/// A render pass consists of a set of texture subresources (or depth slices in<br/>
		/// the 3D texture case) which will be rendered to during the render pass,<br/>
		/// along with corresponding clear values and load/store operations. All<br/>
		/// operations related to graphics pipelines must take place inside of a render<br/>
		/// pass. A default viewport and scissor state are automatically set when this<br/>
		/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
		/// copy pass until you have ended the render pass.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPURenderPass *")]
		public static SDLGPURenderPass* BeginGPURenderPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "color_target_infos")] [NativeName(NativeNameType.Type, "SDL_GPUColorTargetInfo const *")] ref SDLGPUColorTargetInfo colorTargetInfos, [NativeName(NativeNameType.Param, "num_color_targets")] [NativeName(NativeNameType.Type, "Uint32")] uint numColorTargets, [NativeName(NativeNameType.Param, "depth_stencil_target_info")] [NativeName(NativeNameType.Type, "SDL_GPUDepthStencilTargetInfo const *")] ref SDLGPUDepthStencilTargetInfo depthStencilTargetInfo)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUColorTargetInfo* pcolorTargetInfos = &colorTargetInfos)
				{
					fixed (SDLGPUDepthStencilTargetInfo* pdepthStencilTargetInfo = &depthStencilTargetInfo)
					{
						SDLGPURenderPass* ret = BeginGPURenderPassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUColorTargetInfo*)pcolorTargetInfos, numColorTargets, (SDLGPUDepthStencilTargetInfo*)pdepthStencilTargetInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUGraphicsPipelineNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUGraphicsPipeline*, void>)funcTable[864])(renderPass, graphicsPipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[864])((nint)renderPass, (nint)graphicsPipeline);
			#endif
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			BindGPUGraphicsPipelineNative(renderPass, graphicsPipeline);
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] SDLGPUGraphicsPipeline* graphicsPipeline)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUGraphicsPipelineNative((SDLGPURenderPass*)prenderPass, graphicsPipeline);
			}
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
			{
				BindGPUGraphicsPipelineNative(renderPass, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
			}
		}

		/// <summary>
		/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
		/// A graphics pipeline must be bound before making any draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUGraphicsPipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUGraphicsPipeline([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "graphics_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUGraphicsPipeline *")] ref SDLGPUGraphicsPipeline graphicsPipeline)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUGraphicsPipeline* pgraphicsPipeline = &graphicsPipeline)
				{
					BindGPUGraphicsPipelineNative((SDLGPURenderPass*)prenderPass, (SDLGPUGraphicsPipeline*)pgraphicsPipeline);
				}
			}
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUViewportNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] SDLGPUViewport* viewport)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUViewport*, void>)funcTable[865])(renderPass, viewport);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[865])((nint)renderPass, (nint)viewport);
			#endif
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] SDLGPUViewport* viewport)
		{
			SetGPUViewportNative(renderPass, viewport);
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] SDLGPUViewport* viewport)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUViewportNative((SDLGPURenderPass*)prenderPass, viewport);
			}
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] ref SDLGPUViewport viewport)
		{
			fixed (SDLGPUViewport* pviewport = &viewport)
			{
				SetGPUViewportNative(renderPass, (SDLGPUViewport*)pviewport);
			}
		}

		/// <summary>
		/// Sets the current viewport state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUViewport([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "SDL_GPUViewport const *")] ref SDLGPUViewport viewport)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUViewport* pviewport = &viewport)
				{
					SetGPUViewportNative((SDLGPURenderPass*)prenderPass, (SDLGPUViewport*)pviewport);
				}
			}
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUScissorNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* scissor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLRect*, void>)funcTable[866])(renderPass, scissor);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[866])((nint)renderPass, (nint)scissor);
			#endif
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* scissor)
		{
			SetGPUScissorNative(renderPass, scissor);
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] SDLRect* scissor)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUScissorNative((SDLGPURenderPass*)prenderPass, scissor);
			}
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect scissor)
		{
			fixed (SDLRect* pscissor = &scissor)
			{
				SetGPUScissorNative(renderPass, (SDLRect*)pscissor);
			}
		}

		/// <summary>
		/// Sets the current scissor state on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUScissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUScissor([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "scissor")] [NativeName(NativeNameType.Type, "SDL_Rect const *")] ref SDLRect scissor)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLRect* pscissor = &scissor)
				{
					SetGPUScissorNative((SDLGPURenderPass*)prenderPass, (SDLRect*)pscissor);
				}
			}
		}

		/// <summary>
		/// Sets the current blend constants on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBlendConstants")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUBlendConstantsNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "blend_constants")] [NativeName(NativeNameType.Type, "SDL_FColor")] SDLFColor blendConstants)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLFColor, void>)funcTable[867])(renderPass, blendConstants);
			#else
			((delegate* unmanaged[Cdecl]<nint, SDLFColor, void>)funcTable[867])((nint)renderPass, blendConstants);
			#endif
		}

		/// <summary>
		/// Sets the current blend constants on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBlendConstants")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBlendConstants([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "blend_constants")] [NativeName(NativeNameType.Type, "SDL_FColor")] SDLFColor blendConstants)
		{
			SetGPUBlendConstantsNative(renderPass, blendConstants);
		}

		/// <summary>
		/// Sets the current blend constants on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUBlendConstants")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUBlendConstants([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "blend_constants")] [NativeName(NativeNameType.Type, "SDL_FColor")] SDLFColor blendConstants)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUBlendConstantsNative((SDLGPURenderPass*)prenderPass, blendConstants);
			}
		}

		/// <summary>
		/// Sets the current stencil reference value on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUStencilReference")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGPUStencilReferenceNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "Uint8")] byte reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, byte, void>)funcTable[868])(renderPass, reference);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[868])((nint)renderPass, reference);
			#endif
		}

		/// <summary>
		/// Sets the current stencil reference value on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUStencilReference")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUStencilReference([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "Uint8")] byte reference)
		{
			SetGPUStencilReferenceNative(renderPass, reference);
		}

		/// <summary>
		/// Sets the current stencil reference value on a command buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUStencilReference")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGPUStencilReference([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "reference")] [NativeName(NativeNameType.Type, "Uint8")] byte reference)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				SetGPUStencilReferenceNative((SDLGPURenderPass*)prenderPass, reference);
			}
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexBuffersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUBufferBinding*, uint, void>)funcTable[869])(renderPass, firstSlot, bindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[869])((nint)renderPass, firstSlot, (nint)bindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexBuffersNative(renderPass, firstSlot, bindings, numBindings);
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, bindings, numBindings);
			}
		}

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBufferBinding* pbindings = &bindings)
			{
				BindGPUVertexBuffersNative(renderPass, firstSlot, (SDLGPUBufferBinding*)pbindings, numBindings);
			}
		}
	}
}
