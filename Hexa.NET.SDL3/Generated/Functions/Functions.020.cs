// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CopyGPUBufferToBuffer(ref SDLGPUCopyPass copyPass, SDLGPUBufferLocation* source, ref SDLGPUBufferLocation destination, uint size, bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* pdestination = &destination)
				{
					CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CopyGPUBufferToBuffer(SDLGPUCopyPass* copyPass, ref SDLGPUBufferLocation source, ref SDLGPUBufferLocation destination, uint size, bool cycle)
		{
			fixed (SDLGPUBufferLocation* psource = &source)
			{
				fixed (SDLGPUBufferLocation* pdestination = &destination)
				{
					CopyGPUBufferToBufferNative(copyPass, (SDLGPUBufferLocation*)psource, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CopyGPUBufferToBuffer(ref SDLGPUCopyPass copyPass, ref SDLGPUBufferLocation source, ref SDLGPUBufferLocation destination, uint size, bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* psource = &source)
				{
					fixed (SDLGPUBufferLocation* pdestination = &destination)
					{
						CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferLocation*)psource, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DownloadFromGPUTextureNative(SDLGPUCopyPass* copyPass, SDLGPUTextureRegion* source, SDLGPUTextureTransferInfo* destination)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTextureRegion*, SDLGPUTextureTransferInfo*, void>)funcTable[897])(copyPass, source, destination);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[897])((nint)copyPass, (nint)source, (nint)destination);
			#endif
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(SDLGPUCopyPass* copyPass, SDLGPUTextureRegion* source, SDLGPUTextureTransferInfo* destination)
		{
			DownloadFromGPUTextureNative(copyPass, source, destination);
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(ref SDLGPUCopyPass copyPass, SDLGPUTextureRegion* source, SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, destination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(SDLGPUCopyPass* copyPass, ref SDLGPUTextureRegion source, SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUTextureRegion* psource = &source)
			{
				DownloadFromGPUTextureNative(copyPass, (SDLGPUTextureRegion*)psource, destination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(ref SDLGPUCopyPass copyPass, ref SDLGPUTextureRegion source, SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* psource = &source)
				{
					DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureRegion*)psource, destination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(SDLGPUCopyPass* copyPass, SDLGPUTextureRegion* source, ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
			{
				DownloadFromGPUTextureNative(copyPass, source, (SDLGPUTextureTransferInfo*)pdestination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(ref SDLGPUCopyPass copyPass, SDLGPUTextureRegion* source, ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
				{
					DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTextureTransferInfo*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(SDLGPUCopyPass* copyPass, ref SDLGPUTextureRegion source, ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUTextureRegion* psource = &source)
			{
				fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
				{
					DownloadFromGPUTextureNative(copyPass, (SDLGPUTextureRegion*)psource, (SDLGPUTextureTransferInfo*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUTexture(ref SDLGPUCopyPass copyPass, ref SDLGPUTextureRegion source, ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* psource = &source)
				{
					fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
					{
						DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureRegion*)psource, (SDLGPUTextureTransferInfo*)pdestination);
					}
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DownloadFromGPUBufferNative(SDLGPUCopyPass* copyPass, SDLGPUBufferRegion* source, SDLGPUTransferBufferLocation* destination)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUBufferRegion*, SDLGPUTransferBufferLocation*, void>)funcTable[898])(copyPass, source, destination);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[898])((nint)copyPass, (nint)source, (nint)destination);
			#endif
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(SDLGPUCopyPass* copyPass, SDLGPUBufferRegion* source, SDLGPUTransferBufferLocation* destination)
		{
			DownloadFromGPUBufferNative(copyPass, source, destination);
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(ref SDLGPUCopyPass copyPass, SDLGPUBufferRegion* source, SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, destination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(SDLGPUCopyPass* copyPass, ref SDLGPUBufferRegion source, SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUBufferRegion* psource = &source)
			{
				DownloadFromGPUBufferNative(copyPass, (SDLGPUBufferRegion*)psource, destination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(ref SDLGPUCopyPass copyPass, ref SDLGPUBufferRegion source, SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* psource = &source)
				{
					DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferRegion*)psource, destination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(SDLGPUCopyPass* copyPass, SDLGPUBufferRegion* source, ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
			{
				DownloadFromGPUBufferNative(copyPass, source, (SDLGPUTransferBufferLocation*)pdestination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(ref SDLGPUCopyPass copyPass, SDLGPUBufferRegion* source, ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
				{
					DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTransferBufferLocation*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(SDLGPUCopyPass* copyPass, ref SDLGPUBufferRegion source, ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUBufferRegion* psource = &source)
			{
				fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
				{
					DownloadFromGPUBufferNative(copyPass, (SDLGPUBufferRegion*)psource, (SDLGPUTransferBufferLocation*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void DownloadFromGPUBuffer(ref SDLGPUCopyPass copyPass, ref SDLGPUBufferRegion source, ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* psource = &source)
				{
					fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
					{
						DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferRegion*)psource, (SDLGPUTransferBufferLocation*)pdestination);
					}
				}
			}
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGPUCopyPassNative(SDLGPUCopyPass* copyPass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, void>)funcTable[899])(copyPass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[899])((nint)copyPass);
			#endif
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void EndGPUCopyPass(SDLGPUCopyPass* copyPass)
		{
			EndGPUCopyPassNative(copyPass);
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void EndGPUCopyPass(ref SDLGPUCopyPass copyPass)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				EndGPUCopyPassNative((SDLGPUCopyPass*)pcopyPass);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapsForGPUTextureNative(SDLGPUCommandBuffer* commandBuffer, SDLGPUTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUTexture*, void>)funcTable[900])(commandBuffer, texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[900])((nint)commandBuffer, (nint)texture);
			#endif
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GenerateMipmapsForGPUTexture(SDLGPUCommandBuffer* commandBuffer, SDLGPUTexture* texture)
		{
			GenerateMipmapsForGPUTextureNative(commandBuffer, texture);
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GenerateMipmapsForGPUTexture(ref SDLGPUCommandBuffer commandBuffer, SDLGPUTexture* texture)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				GenerateMipmapsForGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, texture);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GenerateMipmapsForGPUTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLGPUTexture texture)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				GenerateMipmapsForGPUTextureNative(commandBuffer, (SDLGPUTexture*)ptexture);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void GenerateMipmapsForGPUTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLGPUTexture texture)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					GenerateMipmapsForGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUTexture*)ptexture);
				}
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitGPUTextureNative(SDLGPUCommandBuffer* commandBuffer, SDLGPUBlitInfo* info)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUBlitInfo*, void>)funcTable[901])(commandBuffer, info);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[901])((nint)commandBuffer, (nint)info);
			#endif
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void BlitGPUTexture(SDLGPUCommandBuffer* commandBuffer, SDLGPUBlitInfo* info)
		{
			BlitGPUTextureNative(commandBuffer, info);
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void BlitGPUTexture(ref SDLGPUCommandBuffer commandBuffer, SDLGPUBlitInfo* info)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				BlitGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, info);
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void BlitGPUTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLGPUBlitInfo info)
		{
			fixed (SDLGPUBlitInfo* pinfo = &info)
			{
				BlitGPUTextureNative(commandBuffer, (SDLGPUBlitInfo*)pinfo);
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void BlitGPUTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLGPUBlitInfo info)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUBlitInfo* pinfo = &info)
				{
					BlitGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUBlitInfo*)pinfo);
				}
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowSupportsGPUSwapchainCompositionNative(SDLGPUDevice* device, SDLWindow* window, SDLGPUSwapchainComposition swapchainComposition)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUSwapchainComposition, byte>)funcTable[902])(device, window, swapchainComposition);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUSwapchainComposition, byte>)funcTable[902])((nint)device, (nint)window, swapchainComposition);
			#endif
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUSwapchainComposition(SDLGPUDevice* device, SDLWindow* window, SDLGPUSwapchainComposition swapchainComposition)
		{
			byte ret = WindowSupportsGPUSwapchainCompositionNative(device, window, swapchainComposition);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUSwapchainComposition(ref SDLGPUDevice device, SDLWindow* window, SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WindowSupportsGPUSwapchainCompositionNative((SDLGPUDevice*)pdevice, window, swapchainComposition);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUSwapchainComposition(SDLGPUDevice* device, ref SDLWindow window, SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowSupportsGPUSwapchainCompositionNative(device, (SDLWindow*)pwindow, swapchainComposition);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUSwapchainComposition(ref SDLGPUDevice device, ref SDLWindow window, SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WindowSupportsGPUSwapchainCompositionNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, swapchainComposition);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowSupportsGPUPresentModeNative(SDLGPUDevice* device, SDLWindow* window, SDLGPUPresentMode presentMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUPresentMode, byte>)funcTable[903])(device, window, presentMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUPresentMode, byte>)funcTable[903])((nint)device, (nint)window, presentMode);
			#endif
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUPresentMode(SDLGPUDevice* device, SDLWindow* window, SDLGPUPresentMode presentMode)
		{
			byte ret = WindowSupportsGPUPresentModeNative(device, window, presentMode);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUPresentMode(ref SDLGPUDevice device, SDLWindow* window, SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WindowSupportsGPUPresentModeNative((SDLGPUDevice*)pdevice, window, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUPresentMode(SDLGPUDevice* device, ref SDLWindow window, SDLGPUPresentMode presentMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowSupportsGPUPresentModeNative(device, (SDLWindow*)pwindow, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WindowSupportsGPUPresentMode(ref SDLGPUDevice device, ref SDLWindow window, SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WindowSupportsGPUPresentModeNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, presentMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClaimWindowForGPUDeviceNative(SDLGPUDevice* device, SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, byte>)funcTable[904])(device, window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[904])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ClaimWindowForGPUDevice(SDLGPUDevice* device, SDLWindow* window)
		{
			byte ret = ClaimWindowForGPUDeviceNative(device, window);
			return ret != 0;
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ClaimWindowForGPUDevice(ref SDLGPUDevice device, SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = ClaimWindowForGPUDeviceNative((SDLGPUDevice*)pdevice, window);
				return ret != 0;
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ClaimWindowForGPUDevice(SDLGPUDevice* device, ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ClaimWindowForGPUDeviceNative(device, (SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool ClaimWindowForGPUDevice(ref SDLGPUDevice device, ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = ClaimWindowForGPUDeviceNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseWindowFromGPUDeviceNative(SDLGPUDevice* device, SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, void>)funcTable[905])(device, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[905])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseWindowFromGPUDevice(SDLGPUDevice* device, SDLWindow* window)
		{
			ReleaseWindowFromGPUDeviceNative(device, window);
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseWindowFromGPUDevice(ref SDLGPUDevice device, SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseWindowFromGPUDeviceNative((SDLGPUDevice*)pdevice, window);
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseWindowFromGPUDevice(SDLGPUDevice* device, ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ReleaseWindowFromGPUDeviceNative(device, (SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseWindowFromGPUDevice(ref SDLGPUDevice device, ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					ReleaseWindowFromGPUDeviceNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGPUSwapchainParametersNative(SDLGPUDevice* device, SDLWindow* window, SDLGPUSwapchainComposition swapchainComposition, SDLGPUPresentMode presentMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUSwapchainComposition, SDLGPUPresentMode, byte>)funcTable[906])(device, window, swapchainComposition, presentMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUSwapchainComposition, SDLGPUPresentMode, byte>)funcTable[906])((nint)device, (nint)window, swapchainComposition, presentMode);
			#endif
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGPUSwapchainParameters(SDLGPUDevice* device, SDLWindow* window, SDLGPUSwapchainComposition swapchainComposition, SDLGPUPresentMode presentMode)
		{
			byte ret = SetGPUSwapchainParametersNative(device, window, swapchainComposition, presentMode);
			return ret != 0;
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGPUSwapchainParameters(ref SDLGPUDevice device, SDLWindow* window, SDLGPUSwapchainComposition swapchainComposition, SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = SetGPUSwapchainParametersNative((SDLGPUDevice*)pdevice, window, swapchainComposition, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGPUSwapchainParameters(SDLGPUDevice* device, ref SDLWindow window, SDLGPUSwapchainComposition swapchainComposition, SDLGPUPresentMode presentMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetGPUSwapchainParametersNative(device, (SDLWindow*)pwindow, swapchainComposition, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGPUSwapchainParameters(ref SDLGPUDevice device, ref SDLWindow window, SDLGPUSwapchainComposition swapchainComposition, SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = SetGPUSwapchainParametersNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, swapchainComposition, presentMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Configures the maximum allowed number of frames in flight.<br/>
		/// The default value when the device is created is 2. This means that after<br/>
		/// you have submitted 2 frames for presentation, if the GPU has not finished<br/>
		/// working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the<br/>
		/// swapchain texture pointer with NULL, and<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() will block.<br/>
		/// Higher values increase throughput at the expense of visual latency. Lower<br/>
		/// values decrease visual latency at the expense of throughput.<br/>
		/// Note that calling this function will stall and flush the command queue to<br/>
		/// prevent synchronization issues.<br/>
		/// The minimum value of allowed frames in flight is 1, and the maximum is 3.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGPUAllowedFramesInFlightNative(SDLGPUDevice* device, uint allowedFramesInFlight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, uint, byte>)funcTable[907])(device, allowedFramesInFlight);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, byte>)funcTable[907])((nint)device, allowedFramesInFlight);
			#endif
		}

		/// <summary>
		/// Configures the maximum allowed number of frames in flight.<br/>
		/// The default value when the device is created is 2. This means that after<br/>
		/// you have submitted 2 frames for presentation, if the GPU has not finished<br/>
		/// working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the<br/>
		/// swapchain texture pointer with NULL, and<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() will block.<br/>
		/// Higher values increase throughput at the expense of visual latency. Lower<br/>
		/// values decrease visual latency at the expense of throughput.<br/>
		/// Note that calling this function will stall and flush the command queue to<br/>
		/// prevent synchronization issues.<br/>
		/// The minimum value of allowed frames in flight is 1, and the maximum is 3.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGPUAllowedFramesInFlight(SDLGPUDevice* device, uint allowedFramesInFlight)
		{
			byte ret = SetGPUAllowedFramesInFlightNative(device, allowedFramesInFlight);
			return ret != 0;
		}

		/// <summary>
		/// Configures the maximum allowed number of frames in flight.<br/>
		/// The default value when the device is created is 2. This means that after<br/>
		/// you have submitted 2 frames for presentation, if the GPU has not finished<br/>
		/// working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the<br/>
		/// swapchain texture pointer with NULL, and<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() will block.<br/>
		/// Higher values increase throughput at the expense of visual latency. Lower<br/>
		/// values decrease visual latency at the expense of throughput.<br/>
		/// Note that calling this function will stall and flush the command queue to<br/>
		/// prevent synchronization issues.<br/>
		/// The minimum value of allowed frames in flight is 1, and the maximum is 3.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SetGPUAllowedFramesInFlight(ref SDLGPUDevice device, uint allowedFramesInFlight)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = SetGPUAllowedFramesInFlightNative((SDLGPUDevice*)pdevice, allowedFramesInFlight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTextureFormat GetGPUSwapchainTextureFormatNative(SDLGPUDevice* device, SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUTextureFormat>)funcTable[908])(device, window);
			#else
			return (SDLGPUTextureFormat)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUTextureFormat>)funcTable[908])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat(SDLGPUDevice* device, SDLWindow* window)
		{
			SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative(device, window);
			return ret;
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat(ref SDLGPUDevice device, SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative((SDLGPUDevice*)pdevice, window);
				return ret;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat(SDLGPUDevice* device, ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative(device, (SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat(ref SDLGPUDevice device, ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AcquireGPUSwapchainTextureNative(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLWindow*, SDLGPUTexture**, uint*, uint*, byte>)funcTable[909])(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[909])((nint)commandBuffer, (nint)window, (nint)swapchainTexture, (nint)swapchainTextureWidth, (nint)swapchainTextureHeight);
			#endif
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			return ret != 0;
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool AcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
							{
								byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUSwapchainNative(SDLGPUDevice* device, SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, byte>)funcTable[910])(device, window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[910])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUSwapchain(SDLGPUDevice* device, SDLWindow* window)
		{
			byte ret = WaitForGPUSwapchainNative(device, window);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUSwapchain(ref SDLGPUDevice device, SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUSwapchainNative((SDLGPUDevice*)pdevice, window);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUSwapchain(SDLGPUDevice* device, ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WaitForGPUSwapchainNative(device, (SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUSwapchain(ref SDLGPUDevice device, ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WaitForGPUSwapchainNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitAndAcquireGPUSwapchainTextureNative(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLWindow*, SDLGPUTexture**, uint*, uint*, byte>)funcTable[911])(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[911])((nint)commandBuffer, (nint)window, (nint)swapchainTexture, (nint)swapchainTextureWidth, (nint)swapchainTextureHeight);
			#endif
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
			{
				byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, uint* swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, SDLGPUTexture** swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, SDLWindow* window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(SDLGPUCommandBuffer* commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
						{
							byte ret = WaitAndAcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Blocks the thread until a swapchain texture is available to be acquired,<br/>
		/// and then acquires it.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it. It is an error to call<br/>
		/// SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.<br/>
		/// This function can fill the swapchain texture handle with NULL in certain<br/>
		/// cases, for example if the window is minimized. This is not an error. You<br/>
		/// should always make sure to check whether the pointer is NULL before<br/>
		/// actually using it.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// The swapchain texture is write-only and cannot be used as a sampler or for<br/>
		/// another reading operation.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitAndAcquireGPUSwapchainTexture(ref SDLGPUCommandBuffer commandBuffer, ref SDLWindow window, ref SDLGPUTexture* swapchainTexture, ref uint swapchainTextureWidth, ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
							{
								byte ret = WaitAndAcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, (uint*)pswapchainTextureHeight);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SubmitGPUCommandBufferNative(SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte>)funcTable[912])(commandBuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[912])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SubmitGPUCommandBuffer(SDLGPUCommandBuffer* commandBuffer)
		{
			byte ret = SubmitGPUCommandBufferNative(commandBuffer);
			return ret != 0;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU.<br/>
		/// It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool SubmitGPUCommandBuffer(ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = SubmitGPUCommandBufferNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFenceNative(SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUFence*>)funcTable[913])(commandBuffer);
			#else
			return (SDLGPUFence*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[913])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFence(SDLGPUCommandBuffer* commandBuffer)
		{
			SDLGPUFence* ret = SubmitGPUCommandBufferAndAcquireFenceNative(commandBuffer);
			return ret;
		}

		/// <summary>
		/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
		/// acquires a fence associated with the command buffer.<br/>
		/// You must release this fence when it is no longer needed or it will cause a<br/>
		/// leak. It is invalid to use the command buffer after this is called.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// All commands in the submission are guaranteed to begin executing before any<br/>
		/// command in a subsequent submission begins executing.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLGPUFence* SubmitGPUCommandBufferAndAcquireFence(ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUFence* ret = SubmitGPUCommandBufferAndAcquireFenceNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret;
			}
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CancelGPUCommandBufferNative(SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, byte>)funcTable[914])(commandBuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[914])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CancelGPUCommandBuffer(SDLGPUCommandBuffer* commandBuffer)
		{
			byte ret = CancelGPUCommandBufferNative(commandBuffer);
			return ret != 0;
		}

		/// <summary>
		/// Cancels a command buffer.<br/>
		/// None of the enqueued commands are executed.<br/>
		/// It is an error to call this function after a swapchain texture has been<br/>
		/// acquired.<br/>
		/// This must be called from the thread the command buffer was acquired on.<br/>
		/// You must not reference the command buffer after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool CancelGPUCommandBuffer(ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = CancelGPUCommandBufferNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUIdleNative(SDLGPUDevice* device)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte>)funcTable[915])(device);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[915])((nint)device);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUIdle(SDLGPUDevice* device)
		{
			byte ret = WaitForGPUIdleNative(device);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the GPU is completely idle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUIdle(ref SDLGPUDevice device)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUIdleNative((SDLGPUDevice*)pdevice);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WaitForGPUFencesNative(SDLGPUDevice* device, byte waitAll, SDLGPUFence** fences, uint numFences)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, byte, SDLGPUFence**, uint, byte>)funcTable[916])(device, waitAll, fences, numFences);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, nint, uint, byte>)funcTable[916])((nint)device, waitAll, (nint)fences, numFences);
			#endif
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUFences(SDLGPUDevice* device, bool waitAll, SDLGPUFence** fences, uint numFences)
		{
			byte ret = WaitForGPUFencesNative(device, waitAll ? (byte)1 : (byte)0, fences, numFences);
			return ret != 0;
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUFences(ref SDLGPUDevice device, bool waitAll, SDLGPUFence** fences, uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, fences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUFences(SDLGPUDevice* device, bool waitAll, ref SDLGPUFence* fences, uint numFences)
		{
			fixed (SDLGPUFence** pfences = &fences)
			{
				byte ret = WaitForGPUFencesNative(device, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
				return ret != 0;
			}
		}

		/// <summary>
		/// Blocks the thread until the given fences are signaled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool WaitForGPUFences(ref SDLGPUDevice device, bool waitAll, ref SDLGPUFence* fences, uint numFences)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence** pfences = &fences)
				{
					byte ret = WaitForGPUFencesNative((SDLGPUDevice*)pdevice, waitAll ? (byte)1 : (byte)0, (SDLGPUFence**)pfences, numFences);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte QueryGPUFenceNative(SDLGPUDevice* device, SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, byte>)funcTable[917])(device, fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[917])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool QueryGPUFence(SDLGPUDevice* device, SDLGPUFence* fence)
		{
			byte ret = QueryGPUFenceNative(device, fence);
			return ret != 0;
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool QueryGPUFence(ref SDLGPUDevice device, SDLGPUFence* fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, fence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool QueryGPUFence(SDLGPUDevice* device, ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				byte ret = QueryGPUFenceNative(device, (SDLGPUFence*)pfence);
				return ret != 0;
			}
		}

		/// <summary>
		/// Checks the status of a fence.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool QueryGPUFence(ref SDLGPUDevice device, ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					byte ret = QueryGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseGPUFenceNative(SDLGPUDevice* device, SDLGPUFence* fence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUFence*, void>)funcTable[918])(device, fence);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[918])((nint)device, (nint)fence);
			#endif
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseGPUFence(SDLGPUDevice* device, SDLGPUFence* fence)
		{
			ReleaseGPUFenceNative(device, fence);
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseGPUFence(ref SDLGPUDevice device, SDLGPUFence* fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, fence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseGPUFence(SDLGPUDevice* device, ref SDLGPUFence fence)
		{
			fixed (SDLGPUFence* pfence = &fence)
			{
				ReleaseGPUFenceNative(device, (SDLGPUFence*)pfence);
			}
		}

		/// <summary>
		/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
		/// You must not reference the fence after calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void ReleaseGPUFence(ref SDLGPUDevice device, ref SDLGPUFence fence)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUFence* pfence = &fence)
				{
					ReleaseGPUFenceNative((SDLGPUDevice*)pdevice, (SDLGPUFence*)pfence);
				}
			}
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GPUTextureFormatTexelBlockSizeNative(SDLGPUTextureFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[919])(format);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint>)funcTable[919])(format);
			#endif
		}

		/// <summary>
		/// Obtains the texel block size for a texture format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GPUTextureFormatTexelBlockSize(SDLGPUTextureFormat format)
		{
			uint ret = GPUTextureFormatTexelBlockSizeNative(format);
			return ret;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsFormatNative(SDLGPUDevice* device, SDLGPUTextureFormat format, SDLGPUTextureType type, SDLGPUTextureUsageFlags usage)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUTextureType, SDLGPUTextureUsageFlags, byte>)funcTable[920])(device, format, type, usage);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUTextureType, SDLGPUTextureUsageFlags, byte>)funcTable[920])((nint)device, format, type, usage);
			#endif
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GPUTextureSupportsFormat(SDLGPUDevice* device, SDLGPUTextureFormat format, SDLGPUTextureType type, SDLGPUTextureUsageFlags usage)
		{
			byte ret = GPUTextureSupportsFormatNative(device, format, type, usage);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a texture format is supported for a given type and<br/>
		/// usage.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GPUTextureSupportsFormat(ref SDLGPUDevice device, SDLGPUTextureFormat format, SDLGPUTextureType type, SDLGPUTextureUsageFlags usage)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsFormatNative((SDLGPUDevice*)pdevice, format, type, usage);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GPUTextureSupportsSampleCountNative(SDLGPUDevice* device, SDLGPUTextureFormat format, SDLGPUSampleCount sampleCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[921])(device, format, sampleCount);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGPUTextureFormat, SDLGPUSampleCount, byte>)funcTable[921])((nint)device, format, sampleCount);
			#endif
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GPUTextureSupportsSampleCount(SDLGPUDevice* device, SDLGPUTextureFormat format, SDLGPUSampleCount sampleCount)
		{
			byte ret = GPUTextureSupportsSampleCountNative(device, format, sampleCount);
			return ret != 0;
		}

		/// <summary>
		/// Determines if a sample count for a texture format is supported.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool GPUTextureSupportsSampleCount(ref SDLGPUDevice device, SDLGPUTextureFormat format, SDLGPUSampleCount sampleCount)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = GPUTextureSupportsSampleCountNative((SDLGPUDevice*)pdevice, format, sampleCount);
				return ret != 0;
			}
		}

		/// <summary>
		/// Calculate the size in bytes of a texture format with dimensions.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalculateGPUTextureFormatSizeNative(SDLGPUTextureFormat format, uint width, uint height, uint depthOrLayerCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint, uint, uint, uint>)funcTable[922])(format, width, height, depthOrLayerCount);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SDLGPUTextureFormat, uint, uint, uint, uint>)funcTable[922])(format, width, height, depthOrLayerCount);
			#endif
		}

		/// <summary>
		/// Calculate the size in bytes of a texture format with dimensions.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint CalculateGPUTextureFormatSize(SDLGPUTextureFormat format, uint width, uint height, uint depthOrLayerCount)
		{
			uint ret = CalculateGPUTextureFormatSizeNative(format, width, height, depthOrLayerCount);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetHapticsNative(int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[923])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[923])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint* GetHaptics(int* count)
		{
			uint* ret = GetHapticsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected haptic devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint* GetHaptics(ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetHapticsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameForIDNative(uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[924])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[924])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetHapticNameForID(uint instanceId)
		{
			byte* ret = GetHapticNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any haptic devices are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetHapticNameForIDS(uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticNative(uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[925])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[925])(instanceId);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
		/// and SDL_SetHapticAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLHaptic* OpenHaptic(uint instanceId)
		{
			SDLHaptic* ret = OpenHapticNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* GetHapticFromIDNative(uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, SDLHaptic*>)funcTable[926])(instanceId);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[926])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLHaptic* GetHapticFromID(uint instanceId)
		{
			SDLHaptic* ret = GetHapticFromIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticIDNative(SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[927])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[927])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetHapticID(SDLHaptic* haptic)
		{
			uint ret = GetHapticIDNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetHapticID(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticIDNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHapticNameNative(SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, byte*>)funcTable[928])(haptic);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[928])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetHapticName(SDLHaptic* haptic)
		{
			byte* ret = GetHapticNameNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetHapticNameS(SDLHaptic* haptic)
		{
			string ret = Utils.DecodeStringUTF8(GetHapticNameNative(haptic));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetHapticName(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte* ret = GetHapticNameNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetHapticNameS(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				string ret = Utils.DecodeStringUTF8(GetHapticNameNative((SDLHaptic*)phaptic));
				return ret;
			}
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseHapticNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[929])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[929])();
			#endif
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool IsMouseHaptic()
		{
			byte ret = IsMouseHapticNative();
			return ret != 0;
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromMouseNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*>)funcTable[930])();
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint>)funcTable[930])();
			#endif
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLHaptic* OpenHapticFromMouse()
		{
			SDLHaptic* ret = OpenHapticFromMouseNative();
			return ret;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJoystickHapticNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, byte>)funcTable[931])(joystick);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[931])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool IsJoystickHaptic(SDLJoystick* joystick)
		{
			byte ret = IsJoystickHapticNative(joystick);
			return ret != 0;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool IsJoystickHaptic(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = IsJoystickHapticNative((SDLJoystick*)pjoystick);
				return ret != 0;
			}
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLHaptic* OpenHapticFromJoystickNative(SDLJoystick* joystick)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLJoystick*, SDLHaptic*>)funcTable[932])(joystick);
			#else
			return (SDLHaptic*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[932])((nint)joystick);
			#endif
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLHaptic* OpenHapticFromJoystick(SDLJoystick* joystick)
		{
			SDLHaptic* ret = OpenHapticFromJoystickNative(joystick);
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static SDLHaptic* OpenHapticFromJoystick(ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLHaptic* ret = OpenHapticFromJoystickNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseHapticNative(SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLHaptic*, void>)funcTable[933])(haptic);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[933])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseHaptic(SDLHaptic* haptic)
		{
			CloseHapticNative(haptic);
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void CloseHaptic(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				CloseHapticNative((SDLHaptic*)phaptic);
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsNative(SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[934])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[934])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetMaxHapticEffects(SDLHaptic* haptic)
		{
			int ret = GetMaxHapticEffectsNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetMaxHapticEffects(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMaxHapticEffectsPlayingNative(SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[935])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[935])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetMaxHapticEffectsPlaying(SDLHaptic* haptic)
		{
			int ret = GetMaxHapticEffectsPlayingNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetMaxHapticEffectsPlaying(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetMaxHapticEffectsPlayingNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHapticFeaturesNative(SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, uint>)funcTable[936])(haptic);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[936])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetHapticFeatures(SDLHaptic* haptic)
		{
			uint ret = GetHapticFeaturesNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetHapticFeatures(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = GetHapticFeaturesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumHapticAxesNative(SDLHaptic* haptic)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, int>)funcTable[937])(haptic);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[937])((nint)haptic);
			#endif
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumHapticAxes(SDLHaptic* haptic)
		{
			int ret = GetNumHapticAxesNative(haptic);
			return ret;
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetNumHapticAxes(ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = GetNumHapticAxesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HapticEffectSupportedNative(SDLHaptic* haptic, SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, byte>)funcTable[938])(haptic, effect);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[938])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HapticEffectSupported(SDLHaptic* haptic, SDLHapticEffect* effect)
		{
			byte ret = HapticEffectSupportedNative(haptic, effect);
			return ret != 0;
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HapticEffectSupported(ref SDLHaptic haptic, SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, effect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HapticEffectSupported(SDLHaptic* haptic, ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				byte ret = HapticEffectSupportedNative(haptic, (SDLHapticEffect*)peffect);
				return ret != 0;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static bool HapticEffectSupported(ref SDLHaptic haptic, ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					byte ret = HapticEffectSupportedNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CreateHapticEffectNative(SDLHaptic* haptic, SDLHapticEffect* effect)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLHaptic*, SDLHapticEffect*, int>)funcTable[939])(haptic, effect);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[939])((nint)haptic, (nint)effect);
			#endif
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int CreateHapticEffect(SDLHaptic* haptic, SDLHapticEffect* effect)
		{
			int ret = CreateHapticEffectNative(haptic, effect);
			return ret;
		}
	}
}
