// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "bindings")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding bindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBufferBinding* pbindings = &bindings)
				{
					BindGPUVertexBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUBufferBinding*)pbindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUIndexBufferNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUBufferBinding*, SDLGPUIndexElementSize, void>)funcTable[870])(renderPass, binding, indexElementSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUIndexElementSize, void>)funcTable[870])((nint)renderPass, (nint)binding, indexElementSize);
			#endif
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			BindGPUIndexBufferNative(renderPass, binding, indexElementSize);
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] SDLGPUBufferBinding* binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUIndexBufferNative((SDLGPURenderPass*)prenderPass, binding, indexElementSize);
			}
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			fixed (SDLGPUBufferBinding* pbinding = &binding)
			{
				BindGPUIndexBufferNative(renderPass, (SDLGPUBufferBinding*)pbinding, indexElementSize);
			}
		}

		/// <summary>
		/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
		/// calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUIndexBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUIndexBuffer([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "binding")] [NativeName(NativeNameType.Type, "SDL_GPUBufferBinding const *")] ref SDLGPUBufferBinding binding, [NativeName(NativeNameType.Param, "index_element_size")] [NativeName(NativeNameType.Type, "SDL_GPUIndexElementSize")] SDLGPUIndexElementSize indexElementSize)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBufferBinding* pbinding = &binding)
				{
					BindGPUIndexBufferNative((SDLGPURenderPass*)prenderPass, (SDLGPUBufferBinding*)pbinding, indexElementSize);
				}
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexSamplersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTextureSamplerBinding*, uint, void>)funcTable[871])(renderPass, firstSlot, textureSamplerBindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[871])((nint)renderPass, firstSlot, (nint)textureSamplerBindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexSamplersNative(renderPass, firstSlot, textureSamplerBindings, numBindings);
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, textureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
			{
				BindGPUVertexSamplersNative(renderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the vertex shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
				{
					BindGPUVertexSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexStorageTexturesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTexture**, uint, void>)funcTable[872])(renderPass, firstSlot, storageTextures, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[872])((nint)renderPass, firstSlot, (nint)storageTextures, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexStorageTexturesNative(renderPass, firstSlot, storageTextures, numBindings);
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, storageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
			{
				BindGPUVertexStorageTexturesNative(renderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the vertex shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
				{
					BindGPUVertexStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUVertexStorageBuffersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUBuffer**, uint, void>)funcTable[873])(renderPass, firstSlot, storageBuffers, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[873])((nint)renderPass, firstSlot, (nint)storageBuffers, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUVertexStorageBuffersNative(renderPass, firstSlot, storageBuffers, numBindings);
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUVertexStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, storageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
			{
				BindGPUVertexStorageBuffersNative(renderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the vertex shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUVertexStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUVertexStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
				{
					BindGPUVertexStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUFragmentSamplersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTextureSamplerBinding*, uint, void>)funcTable[874])(renderPass, firstSlot, textureSamplerBindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[874])((nint)renderPass, firstSlot, (nint)textureSamplerBindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUFragmentSamplersNative(renderPass, firstSlot, textureSamplerBindings, numBindings);
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUFragmentSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, textureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
			{
				BindGPUFragmentSamplersNative(renderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the fragment shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentSamplers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
				{
					BindGPUFragmentSamplersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUFragmentStorageTexturesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUTexture**, uint, void>)funcTable[875])(renderPass, firstSlot, storageTextures, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[875])((nint)renderPass, firstSlot, (nint)storageTextures, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUFragmentStorageTexturesNative(renderPass, firstSlot, storageTextures, numBindings);
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUFragmentStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, storageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
			{
				BindGPUFragmentStorageTexturesNative(renderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures for use on the fragment shader.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageTextures([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
				{
					BindGPUFragmentStorageTexturesNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUFragmentStorageBuffersNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, SDLGPUBuffer**, uint, void>)funcTable[876])(renderPass, firstSlot, storageBuffers, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[876])((nint)renderPass, firstSlot, (nint)storageBuffers, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUFragmentStorageBuffersNative(renderPass, firstSlot, storageBuffers, numBindings);
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				BindGPUFragmentStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, storageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
			{
				BindGPUFragmentStorageBuffersNative(renderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers for use on the fragment shader.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUFragmentStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUFragmentStorageBuffers([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
				{
					BindGPUFragmentStorageBuffersNative((SDLGPURenderPass*)prenderPass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
				}
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer and instancing<br/>
		/// enabled.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID); GPU APIs and shader languages do not define these<br/>
		/// built-in variables consistently, so if your shader depends on them, the<br/>
		/// only way to keep behavior consistent and portable is to always pass 0 for<br/>
		/// the correlating parameter in the draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUIndexedPrimitivesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "Uint32")] uint numIndices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_index")] [NativeName(NativeNameType.Type, "Uint32")] uint firstIndex, [NativeName(NativeNameType.Param, "vertex_offset")] [NativeName(NativeNameType.Type, "Sint32")] int vertexOffset, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, uint, uint, int, uint, void>)funcTable[877])(renderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, int, uint, void>)funcTable[877])((nint)renderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer and instancing<br/>
		/// enabled.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID); GPU APIs and shader languages do not define these<br/>
		/// built-in variables consistently, so if your shader depends on them, the<br/>
		/// only way to keep behavior consistent and portable is to always pass 0 for<br/>
		/// the correlating parameter in the draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "Uint32")] uint numIndices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_index")] [NativeName(NativeNameType.Type, "Uint32")] uint firstIndex, [NativeName(NativeNameType.Param, "vertex_offset")] [NativeName(NativeNameType.Type, "Sint32")] int vertexOffset, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			DrawGPUIndexedPrimitivesNative(renderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer and instancing<br/>
		/// enabled.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID); GPU APIs and shader languages do not define these<br/>
		/// built-in variables consistently, so if your shader depends on them, the<br/>
		/// only way to keep behavior consistent and portable is to always pass 0 for<br/>
		/// the correlating parameter in the draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "Uint32")] uint numIndices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_index")] [NativeName(NativeNameType.Type, "Uint32")] uint firstIndex, [NativeName(NativeNameType.Param, "vertex_offset")] [NativeName(NativeNameType.Type, "Sint32")] int vertexOffset, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUIndexedPrimitivesNative((SDLGPURenderPass*)prenderPass, numIndices, numInstances, firstIndex, vertexOffset, firstInstance);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID); GPU APIs and shader languages do not define these<br/>
		/// built-in variables consistently, so if your shader depends on them, the<br/>
		/// only way to keep behavior consistent and portable is to always pass 0 for<br/>
		/// the correlating parameter in the draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUPrimitivesNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "Uint32")] uint numVertices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_vertex")] [NativeName(NativeNameType.Type, "Uint32")] uint firstVertex, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, uint, uint, uint, uint, void>)funcTable[878])(renderPass, numVertices, numInstances, firstVertex, firstInstance);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, uint, void>)funcTable[878])((nint)renderPass, numVertices, numInstances, firstVertex, firstInstance);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID); GPU APIs and shader languages do not define these<br/>
		/// built-in variables consistently, so if your shader depends on them, the<br/>
		/// only way to keep behavior consistent and portable is to always pass 0 for<br/>
		/// the correlating parameter in the draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "Uint32")] uint numVertices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_vertex")] [NativeName(NativeNameType.Type, "Uint32")] uint firstVertex, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			DrawGPUPrimitivesNative(renderPass, numVertices, numInstances, firstVertex, firstInstance);
		}

		/// <summary>
		/// Draws data using bound graphics state.<br/>
		/// You must not call this function before binding a graphics pipeline.<br/>
		/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
		/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
		/// example, SV_VertexID); GPU APIs and shader languages do not define these<br/>
		/// built-in variables consistently, so if your shader depends on them, the<br/>
		/// only way to keep behavior consistent and portable is to always pass 0 for<br/>
		/// the correlating parameter in the draw calls.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitives")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitives([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "Uint32")] uint numVertices, [NativeName(NativeNameType.Param, "num_instances")] [NativeName(NativeNameType.Type, "Uint32")] uint numInstances, [NativeName(NativeNameType.Param, "first_vertex")] [NativeName(NativeNameType.Type, "Uint32")] uint firstVertex, [NativeName(NativeNameType.Param, "first_instance")] [NativeName(NativeNameType.Type, "Uint32")] uint firstInstance)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUPrimitivesNative((SDLGPURenderPass*)prenderPass, numVertices, numInstances, firstVertex, firstInstance);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUPrimitivesIndirectNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUBuffer*, uint, uint, void>)funcTable[879])(renderPass, buffer, offset, drawCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, void>)funcTable[879])((nint)renderPass, (nint)buffer, offset, drawCount);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			DrawGPUPrimitivesIndirectNative(renderPass, buffer, offset, drawCount);
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, buffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				DrawGPUPrimitivesIndirectNative(renderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state and with draw parameters set from a<br/>
		/// buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
		/// function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					DrawGPUPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
				}
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawGPUIndexedPrimitivesIndirectNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, SDLGPUBuffer*, uint, uint, void>)funcTable[880])(renderPass, buffer, offset, drawCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, void>)funcTable[880])((nint)renderPass, (nint)buffer, offset, drawCount);
			#endif
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			DrawGPUIndexedPrimitivesIndirectNative(renderPass, buffer, offset, drawCount);
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				DrawGPUIndexedPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, buffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				DrawGPUIndexedPrimitivesIndirectNative(renderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
			}
		}

		/// <summary>
		/// Draws data using bound graphics state with an index buffer enabled and with<br/>
		/// draw parameters set from a buffer.<br/>
		/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
		/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
		/// this function before binding a graphics pipeline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DrawGPUIndexedPrimitivesIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DrawGPUIndexedPrimitivesIndirect([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset, [NativeName(NativeNameType.Param, "draw_count")] [NativeName(NativeNameType.Type, "Uint32")] uint drawCount)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					DrawGPUIndexedPrimitivesIndirectNative((SDLGPURenderPass*)prenderPass, (SDLGPUBuffer*)pbuffer, offset, drawCount);
				}
			}
		}

		/// <summary>
		/// Ends the given render pass.<br/>
		/// All bound graphics state on the render pass command buffer is unset. The<br/>
		/// render pass handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGPURenderPassNative([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPURenderPass*, void>)funcTable[881])(renderPass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[881])((nint)renderPass);
			#endif
		}

		/// <summary>
		/// Ends the given render pass.<br/>
		/// All bound graphics state on the render pass command buffer is unset. The<br/>
		/// render pass handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPURenderPass([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] SDLGPURenderPass* renderPass)
		{
			EndGPURenderPassNative(renderPass);
		}

		/// <summary>
		/// Ends the given render pass.<br/>
		/// All bound graphics state on the render pass command buffer is unset. The<br/>
		/// render pass handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPURenderPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPURenderPass([NativeName(NativeNameType.Param, "render_pass")] [NativeName(NativeNameType.Type, "SDL_GPURenderPass *")] ref SDLGPURenderPass renderPass)
		{
			fixed (SDLGPURenderPass* prenderPass = &renderPass)
			{
				EndGPURenderPassNative((SDLGPURenderPass*)prenderPass);
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUComputePass* BeginGPUComputePassNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUStorageTextureReadWriteBinding*, uint, SDLGPUStorageBufferReadWriteBinding*, uint, SDLGPUComputePass*>)funcTable[882])(commandBuffer, storageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
			#else
			return (SDLGPUComputePass*)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, uint, nint>)funcTable[882])((nint)commandBuffer, (nint)storageTextureBindings, numStorageTextureBindings, (nint)storageBufferBindings, numStorageBufferBindings);
			#endif
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, storageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
			return ret;
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, storageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
				return ret;
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
			{
				SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
				return ret;
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] SDLGPUStorageBufferReadWriteBinding* storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
				{
					SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, storageBufferBindings, numStorageBufferBindings);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
			{
				SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, storageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
				return ret;
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] SDLGPUStorageTextureReadWriteBinding* storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
				{
					SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, storageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
			{
				fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
				{
					SDLGPUComputePass* ret = BeginGPUComputePassNative(commandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
					return ret;
				}
			}
		}

		/// <summary>
		/// Begins a compute pass on a command buffer.<br/>
		/// A compute pass is defined by a set of texture subresources and buffers that<br/>
		/// may be written to by compute pipelines. These textures and buffers must<br/>
		/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
		/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
		/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
		/// texture in the compute pass. All operations related to compute pipelines<br/>
		/// must take place inside of a compute pass. You must not begin another<br/>
		/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
		/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
		/// implicitly synchronized. This means you may cause data races by both<br/>
		/// reading and writing a resource region in a compute pass, or by writing<br/>
		/// multiple times to a resource region. If your compute work depends on<br/>
		/// reading the completed output from a previous dispatch, you MUST end the<br/>
		/// current compute pass and begin a new one before you can safely access the<br/>
		/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
		/// texture in the same compute pass is only supported by specific texture<br/>
		/// formats. Make sure you check the format support!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUComputePass *")]
		public static SDLGPUComputePass* BeginGPUComputePass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "storage_texture_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageTextureReadWriteBinding const *")] ref SDLGPUStorageTextureReadWriteBinding storageTextureBindings, [NativeName(NativeNameType.Param, "num_storage_texture_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageTextureBindings, [NativeName(NativeNameType.Param, "storage_buffer_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUStorageBufferReadWriteBinding const *")] ref SDLGPUStorageBufferReadWriteBinding storageBufferBindings, [NativeName(NativeNameType.Param, "num_storage_buffer_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numStorageBufferBindings)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUStorageTextureReadWriteBinding* pstorageTextureBindings = &storageTextureBindings)
				{
					fixed (SDLGPUStorageBufferReadWriteBinding* pstorageBufferBindings = &storageBufferBindings)
					{
						SDLGPUComputePass* ret = BeginGPUComputePassNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUStorageTextureReadWriteBinding*)pstorageTextureBindings, numStorageTextureBindings, (SDLGPUStorageBufferReadWriteBinding*)pstorageBufferBindings, numStorageBufferBindings);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputePipelineNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, SDLGPUComputePipeline*, void>)funcTable[883])(computePass, computePipeline);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[883])((nint)computePass, (nint)computePipeline);
			#endif
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			BindGPUComputePipelineNative(computePass, computePipeline);
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] SDLGPUComputePipeline* computePipeline)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputePipelineNative((SDLGPUComputePass*)pcomputePass, computePipeline);
			}
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
			{
				BindGPUComputePipelineNative(computePass, (SDLGPUComputePipeline*)pcomputePipeline);
			}
		}

		/// <summary>
		/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputePipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputePipeline([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "SDL_GPUComputePipeline *")] ref SDLGPUComputePipeline computePipeline)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUComputePipeline* pcomputePipeline = &computePipeline)
				{
					BindGPUComputePipelineNative((SDLGPUComputePass*)pcomputePass, (SDLGPUComputePipeline*)pcomputePipeline);
				}
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputeSamplersNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, SDLGPUTextureSamplerBinding*, uint, void>)funcTable[884])(computePass, firstSlot, textureSamplerBindings, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[884])((nint)computePass, firstSlot, (nint)textureSamplerBindings, numBindings);
			#endif
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUComputeSamplersNative(computePass, firstSlot, textureSamplerBindings, numBindings);
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] SDLGPUTextureSamplerBinding* textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputeSamplersNative((SDLGPUComputePass*)pcomputePass, firstSlot, textureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
			{
				BindGPUComputeSamplersNative(computePass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
			}
		}

		/// <summary>
		/// Binds texture-sampler pairs for use on the compute shader.<br/>
		/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeSamplers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeSamplers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "texture_sampler_bindings")] [NativeName(NativeNameType.Type, "SDL_GPUTextureSamplerBinding const *")] ref SDLGPUTextureSamplerBinding textureSamplerBindings, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUTextureSamplerBinding* ptextureSamplerBindings = &textureSamplerBindings)
				{
					BindGPUComputeSamplersNative((SDLGPUComputePass*)pcomputePass, firstSlot, (SDLGPUTextureSamplerBinding*)ptextureSamplerBindings, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputeStorageTexturesNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, SDLGPUTexture**, uint, void>)funcTable[885])(computePass, firstSlot, storageTextures, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[885])((nint)computePass, firstSlot, (nint)storageTextures, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUComputeStorageTexturesNative(computePass, firstSlot, storageTextures, numBindings);
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] SDLGPUTexture** storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputeStorageTexturesNative((SDLGPUComputePass*)pcomputePass, firstSlot, storageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
			{
				BindGPUComputeStorageTexturesNative(computePass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
			}
		}

		/// <summary>
		/// Binds storage textures as readonly for use on the compute pipeline.<br/>
		/// These textures must have been created with<br/>
		/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageTextures")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageTextures([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_textures")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * const *")] ref SDLGPUTexture* storageTextures, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUTexture** pstorageTextures = &storageTextures)
				{
					BindGPUComputeStorageTexturesNative((SDLGPUComputePass*)pcomputePass, firstSlot, (SDLGPUTexture**)pstorageTextures, numBindings);
				}
			}
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindGPUComputeStorageBuffersNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, SDLGPUBuffer**, uint, void>)funcTable[886])(computePass, firstSlot, storageBuffers, numBindings);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, nint, uint, void>)funcTable[886])((nint)computePass, firstSlot, (nint)storageBuffers, numBindings);
			#endif
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			BindGPUComputeStorageBuffersNative(computePass, firstSlot, storageBuffers, numBindings);
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] SDLGPUBuffer** storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				BindGPUComputeStorageBuffersNative((SDLGPUComputePass*)pcomputePass, firstSlot, storageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
			{
				BindGPUComputeStorageBuffersNative(computePass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
			}
		}

		/// <summary>
		/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
		/// These buffers must have been created with<br/>
		/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
		/// Be sure your shader is set up according to the requirements documented in<br/>
		/// SDL_CreateGPUShader().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BindGPUComputeStorageBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BindGPUComputeStorageBuffers([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "first_slot")] [NativeName(NativeNameType.Type, "Uint32")] uint firstSlot, [NativeName(NativeNameType.Param, "storage_buffers")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer * const *")] ref SDLGPUBuffer* storageBuffers, [NativeName(NativeNameType.Param, "num_bindings")] [NativeName(NativeNameType.Type, "Uint32")] uint numBindings)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUBuffer** pstorageBuffers = &storageBuffers)
				{
					BindGPUComputeStorageBuffersNative((SDLGPUComputePass*)pcomputePass, firstSlot, (SDLGPUBuffer**)pstorageBuffers, numBindings);
				}
			}
		}

		/// <summary>
		/// Dispatches compute work.<br/>
		/// You must not call this function before binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUCompute")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchGPUComputeNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "groupcount_x")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountX, [NativeName(NativeNameType.Param, "groupcount_y")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountY, [NativeName(NativeNameType.Param, "groupcount_z")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, uint, uint, uint, void>)funcTable[887])(computePass, groupcountX, groupcountY, groupcountZ);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, uint, void>)funcTable[887])((nint)computePass, groupcountX, groupcountY, groupcountZ);
			#endif
		}

		/// <summary>
		/// Dispatches compute work.<br/>
		/// You must not call this function before binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUCompute")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUCompute([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "groupcount_x")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountX, [NativeName(NativeNameType.Param, "groupcount_y")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountY, [NativeName(NativeNameType.Param, "groupcount_z")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountZ)
		{
			DispatchGPUComputeNative(computePass, groupcountX, groupcountY, groupcountZ);
		}

		/// <summary>
		/// Dispatches compute work.<br/>
		/// You must not call this function before binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUCompute")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUCompute([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "groupcount_x")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountX, [NativeName(NativeNameType.Param, "groupcount_y")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountY, [NativeName(NativeNameType.Param, "groupcount_z")] [NativeName(NativeNameType.Type, "Uint32")] uint groupcountZ)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				DispatchGPUComputeNative((SDLGPUComputePass*)pcomputePass, groupcountX, groupcountY, groupcountZ);
			}
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchGPUComputeIndirectNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, SDLGPUBuffer*, uint, void>)funcTable[888])(computePass, buffer, offset);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[888])((nint)computePass, (nint)buffer, offset);
			#endif
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			DispatchGPUComputeIndirectNative(computePass, buffer, offset);
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] SDLGPUBuffer* buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				DispatchGPUComputeIndirectNative((SDLGPUComputePass*)pcomputePass, buffer, offset);
			}
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			fixed (SDLGPUBuffer* pbuffer = &buffer)
			{
				DispatchGPUComputeIndirectNative(computePass, (SDLGPUBuffer*)pbuffer, offset);
			}
		}

		/// <summary>
		/// Dispatches compute work with parameters set from a buffer.<br/>
		/// The buffer layout should match the layout of<br/>
		/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
		/// binding a compute pipeline.<br/>
		/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
		/// the dispatches write to the same resource region as each other, there is no<br/>
		/// guarantee of which order the writes will occur. If the write order matters,<br/>
		/// you MUST end the compute pass and begin another one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DispatchGPUComputeIndirect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DispatchGPUComputeIndirect([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "SDL_GPUBuffer *")] ref SDLGPUBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Uint32")] uint offset)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				fixed (SDLGPUBuffer* pbuffer = &buffer)
				{
					DispatchGPUComputeIndirectNative((SDLGPUComputePass*)pcomputePass, (SDLGPUBuffer*)pbuffer, offset);
				}
			}
		}

		/// <summary>
		/// Ends the current compute pass.<br/>
		/// All bound compute state on the command buffer is unset. The compute pass<br/>
		/// handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGPUComputePassNative([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUComputePass*, void>)funcTable[889])(computePass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[889])((nint)computePass);
			#endif
		}

		/// <summary>
		/// Ends the current compute pass.<br/>
		/// All bound compute state on the command buffer is unset. The compute pass<br/>
		/// handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUComputePass([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] SDLGPUComputePass* computePass)
		{
			EndGPUComputePassNative(computePass);
		}

		/// <summary>
		/// Ends the current compute pass.<br/>
		/// All bound compute state on the command buffer is unset. The compute pass<br/>
		/// handle is now invalid.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUComputePass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUComputePass([NativeName(NativeNameType.Param, "compute_pass")] [NativeName(NativeNameType.Type, "SDL_GPUComputePass *")] ref SDLGPUComputePass computePass)
		{
			fixed (SDLGPUComputePass* pcomputePass = &computePass)
			{
				EndGPUComputePassNative((SDLGPUComputePass*)pcomputePass);
			}
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands. The<br/>
		/// memory is owned by the graphics driver - do NOT call SDL_free() on the<br/>
		/// returned pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBuffer*, byte, void*>)funcTable[890])(device, transferBuffer, cycle);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, byte, nint>)funcTable[890])((nint)device, (nint)transferBuffer, cycle);
			#endif
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands. The<br/>
		/// memory is owned by the graphics driver - do NOT call SDL_free() on the<br/>
		/// returned pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			void* ret = MapGPUTransferBufferNative(device, transferBuffer, cycle ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands. The<br/>
		/// memory is owned by the graphics driver - do NOT call SDL_free() on the<br/>
		/// returned pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				void* ret = MapGPUTransferBufferNative((SDLGPUDevice*)pdevice, transferBuffer, cycle ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands. The<br/>
		/// memory is owned by the graphics driver - do NOT call SDL_free() on the<br/>
		/// returned pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
			{
				void* ret = MapGPUTransferBufferNative(device, (SDLGPUTransferBuffer*)ptransferBuffer, cycle ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Maps a transfer buffer into application address space.<br/>
		/// You must unmap the transfer buffer before encoding upload commands. The<br/>
		/// memory is owned by the graphics driver - do NOT call SDL_free() on the<br/>
		/// returned pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* MapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
				{
					void* ret = MapGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBuffer*)ptransferBuffer, cycle ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnmapGPUTransferBufferNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLGPUTransferBuffer*, void>)funcTable[891])(device, transferBuffer);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[891])((nint)device, (nint)transferBuffer);
			#endif
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			UnmapGPUTransferBufferNative(device, transferBuffer);
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] SDLGPUTransferBuffer* transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				UnmapGPUTransferBufferNative((SDLGPUDevice*)pdevice, transferBuffer);
			}
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
			{
				UnmapGPUTransferBufferNative(device, (SDLGPUTransferBuffer*)ptransferBuffer);
			}
		}

		/// <summary>
		/// Unmaps a previously mapped transfer buffer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnmapGPUTransferBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapGPUTransferBuffer([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "transfer_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBuffer *")] ref SDLGPUTransferBuffer transferBuffer)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLGPUTransferBuffer* ptransferBuffer = &transferBuffer)
				{
					UnmapGPUTransferBufferNative((SDLGPUDevice*)pdevice, (SDLGPUTransferBuffer*)ptransferBuffer);
				}
			}
		}

		/// <summary>
		/// Begins a copy pass on a command buffer.<br/>
		/// All operations related to copying to or from buffers or textures take place<br/>
		/// inside a copy pass. You must not begin another copy pass, or a render pass<br/>
		/// or compute pass before ending the copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUCopyPass* BeginGPUCopyPassNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUCopyPass*>)funcTable[892])(commandBuffer);
			#else
			return (SDLGPUCopyPass*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[892])((nint)commandBuffer);
			#endif
		}

		/// <summary>
		/// Begins a copy pass on a command buffer.<br/>
		/// All operations related to copying to or from buffers or textures take place<br/>
		/// inside a copy pass. You must not begin another copy pass, or a render pass<br/>
		/// or compute pass before ending the copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")]
		public static SDLGPUCopyPass* BeginGPUCopyPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer)
		{
			SDLGPUCopyPass* ret = BeginGPUCopyPassNative(commandBuffer);
			return ret;
		}

		/// <summary>
		/// Begins a copy pass on a command buffer.<br/>
		/// All operations related to copying to or from buffers or textures take place<br/>
		/// inside a copy pass. You must not begin another copy pass, or a render pass<br/>
		/// or compute pass before ending the copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BeginGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")]
		public static SDLGPUCopyPass* BeginGPUCopyPass([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				SDLGPUCopyPass* ret = BeginGPUCopyPassNative((SDLGPUCommandBuffer*)pcommandBuffer);
				return ret;
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UploadToGPUTextureNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTextureTransferInfo*, SDLGPUTextureRegion*, byte, void>)funcTable[893])(copyPass, source, destination, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, void>)funcTable[893])((nint)copyPass, (nint)source, (nint)destination, cycle);
			#endif
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			UploadToGPUTextureNative(copyPass, source, destination, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureTransferInfo* psource = &source)
			{
				UploadToGPUTextureNative(copyPass, (SDLGPUTextureTransferInfo*)psource, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureTransferInfo* psource = &source)
				{
					UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureTransferInfo*)psource, destination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureRegion* pdestination = &destination)
			{
				UploadToGPUTextureNative(copyPass, source, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* pdestination = &destination)
				{
					UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureTransferInfo* psource = &source)
			{
				fixed (SDLGPUTextureRegion* pdestination = &destination)
				{
					UploadToGPUTextureNative(copyPass, (SDLGPUTextureTransferInfo*)psource, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a texture.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// You must align the data in the transfer buffer to a multiple of the texel<br/>
		/// size of the texture format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureTransferInfo* psource = &source)
				{
					fixed (SDLGPUTextureRegion* pdestination = &destination)
					{
						UploadToGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureTransferInfo*)psource, (SDLGPUTextureRegion*)pdestination, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UploadToGPUBufferNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTransferBufferLocation*, SDLGPUBufferRegion*, byte, void>)funcTable[894])(copyPass, source, destination, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, void>)funcTable[894])((nint)copyPass, (nint)source, (nint)destination, cycle);
			#endif
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			UploadToGPUBufferNative(copyPass, source, destination, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTransferBufferLocation* psource = &source)
			{
				UploadToGPUBufferNative(copyPass, (SDLGPUTransferBufferLocation*)psource, destination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTransferBufferLocation* psource = &source)
				{
					UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTransferBufferLocation*)psource, destination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferRegion* pdestination = &destination)
			{
				UploadToGPUBufferNative(copyPass, source, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* pdestination = &destination)
				{
					UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTransferBufferLocation* psource = &source)
			{
				fixed (SDLGPUBufferRegion* pdestination = &destination)
				{
					UploadToGPUBufferNative(copyPass, (SDLGPUTransferBufferLocation*)psource, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Uploads data from a transfer buffer to a buffer.<br/>
		/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
		/// finished in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UploadToGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UploadToGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion destination, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTransferBufferLocation* psource = &source)
				{
					fixed (SDLGPUBufferRegion* pdestination = &destination)
					{
						UploadToGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTransferBufferLocation*)psource, (SDLGPUBufferRegion*)pdestination, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyGPUTextureToTextureNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTextureLocation*, SDLGPUTextureLocation*, uint, uint, uint, byte, void>)funcTable[895])(copyPass, source, destination, w, h, d, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, uint, uint, byte, void>)funcTable[895])((nint)copyPass, (nint)source, (nint)destination, w, h, d, cycle);
			#endif
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			CopyGPUTextureToTextureNative(copyPass, source, destination, w, h, d, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, source, destination, w, h, d, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureLocation* psource = &source)
			{
				CopyGPUTextureToTextureNative(copyPass, (SDLGPUTextureLocation*)psource, destination, w, h, d, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureLocation* psource = &source)
				{
					CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureLocation*)psource, destination, w, h, d, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureLocation* pdestination = &destination)
			{
				CopyGPUTextureToTextureNative(copyPass, source, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] SDLGPUTextureLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureLocation* pdestination = &destination)
				{
					CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUTextureLocation* psource = &source)
			{
				fixed (SDLGPUTextureLocation* pdestination = &destination)
				{
					CopyGPUTextureToTextureNative(copyPass, (SDLGPUTextureLocation*)psource, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a texture-to-texture copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUTextureToTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUTextureToTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureLocation const *")] ref SDLGPUTextureLocation destination, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "Uint32")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "Uint32")] uint h, [NativeName(NativeNameType.Param, "d")] [NativeName(NativeNameType.Type, "Uint32")] uint d, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureLocation* psource = &source)
				{
					fixed (SDLGPUTextureLocation* pdestination = &destination)
					{
						CopyGPUTextureToTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureLocation*)psource, (SDLGPUTextureLocation*)pdestination, w, h, d, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyGPUBufferToBufferNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] byte cycle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUBufferLocation*, SDLGPUBufferLocation*, uint, byte, void>)funcTable[896])(copyPass, source, destination, size, cycle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, byte, void>)funcTable[896])((nint)copyPass, (nint)source, (nint)destination, size, cycle);
			#endif
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			CopyGPUBufferToBufferNative(copyPass, source, destination, size, cycle ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, source, destination, size, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferLocation* psource = &source)
			{
				CopyGPUBufferToBufferNative(copyPass, (SDLGPUBufferLocation*)psource, destination, size, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* psource = &source)
				{
					CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferLocation*)psource, destination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferLocation* pdestination = &destination)
			{
				CopyGPUBufferToBufferNative(copyPass, source, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] SDLGPUBufferLocation* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* pdestination = &destination)
				{
					CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUBufferLocation* psource = &source)
			{
				fixed (SDLGPUBufferLocation* pdestination = &destination)
				{
					CopyGPUBufferToBufferNative(copyPass, (SDLGPUBufferLocation*)psource, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// Performs a buffer-to-buffer copy.<br/>
		/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
		/// in subsequent commands.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CopyGPUBufferToBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CopyGPUBufferToBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUBufferLocation const *")] ref SDLGPUBufferLocation destination, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "Uint32")] uint size, [NativeName(NativeNameType.Param, "cycle")] [NativeName(NativeNameType.Type, "bool")] bool cycle)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferLocation* psource = &source)
				{
					fixed (SDLGPUBufferLocation* pdestination = &destination)
					{
						CopyGPUBufferToBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferLocation*)psource, (SDLGPUBufferLocation*)pdestination, size, cycle ? (byte)1 : (byte)0);
					}
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DownloadFromGPUTextureNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUTextureRegion*, SDLGPUTextureTransferInfo*, void>)funcTable[897])(copyPass, source, destination);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[897])((nint)copyPass, (nint)source, (nint)destination);
			#endif
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			DownloadFromGPUTextureNative(copyPass, source, destination);
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, destination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUTextureRegion* psource = &source)
			{
				DownloadFromGPUTextureNative(copyPass, (SDLGPUTextureRegion*)psource, destination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] SDLGPUTextureTransferInfo* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* psource = &source)
				{
					DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureRegion*)psource, destination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
			{
				DownloadFromGPUTextureNative(copyPass, source, (SDLGPUTextureTransferInfo*)pdestination);
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] SDLGPUTextureRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
				{
					DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTextureTransferInfo*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUTextureRegion* psource = &source)
			{
				fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
				{
					DownloadFromGPUTextureNative(copyPass, (SDLGPUTextureRegion*)psource, (SDLGPUTextureTransferInfo*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUTexture([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUTextureRegion const *")] ref SDLGPUTextureRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTextureTransferInfo const *")] ref SDLGPUTextureTransferInfo destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTextureRegion* psource = &source)
				{
					fixed (SDLGPUTextureTransferInfo* pdestination = &destination)
					{
						DownloadFromGPUTextureNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUTextureRegion*)psource, (SDLGPUTextureTransferInfo*)pdestination);
					}
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DownloadFromGPUBufferNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, SDLGPUBufferRegion*, SDLGPUTransferBufferLocation*, void>)funcTable[898])(copyPass, source, destination);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[898])((nint)copyPass, (nint)source, (nint)destination);
			#endif
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			DownloadFromGPUBufferNative(copyPass, source, destination);
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, destination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUBufferRegion* psource = &source)
			{
				DownloadFromGPUBufferNative(copyPass, (SDLGPUBufferRegion*)psource, destination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] SDLGPUTransferBufferLocation* destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* psource = &source)
				{
					DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferRegion*)psource, destination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
			{
				DownloadFromGPUBufferNative(copyPass, source, (SDLGPUTransferBufferLocation*)pdestination);
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] SDLGPUBufferRegion* source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
				{
					DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, source, (SDLGPUTransferBufferLocation*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUBufferRegion* psource = &source)
			{
				fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
				{
					DownloadFromGPUBufferNative(copyPass, (SDLGPUBufferRegion*)psource, (SDLGPUTransferBufferLocation*)pdestination);
				}
			}
		}

		/// <summary>
		/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
		/// This data is not guaranteed to be copied until the command buffer fence is<br/>
		/// signaled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DownloadFromGPUBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DownloadFromGPUBuffer([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "SDL_GPUBufferRegion const *")] ref SDLGPUBufferRegion source, [NativeName(NativeNameType.Param, "destination")] [NativeName(NativeNameType.Type, "SDL_GPUTransferBufferLocation const *")] ref SDLGPUTransferBufferLocation destination)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				fixed (SDLGPUBufferRegion* psource = &source)
				{
					fixed (SDLGPUTransferBufferLocation* pdestination = &destination)
					{
						DownloadFromGPUBufferNative((SDLGPUCopyPass*)pcopyPass, (SDLGPUBufferRegion*)psource, (SDLGPUTransferBufferLocation*)pdestination);
					}
				}
			}
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndGPUCopyPassNative([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCopyPass*, void>)funcTable[899])(copyPass);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[899])((nint)copyPass);
			#endif
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUCopyPass([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] SDLGPUCopyPass* copyPass)
		{
			EndGPUCopyPassNative(copyPass);
		}

		/// <summary>
		/// Ends the current copy pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EndGPUCopyPass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndGPUCopyPass([NativeName(NativeNameType.Param, "copy_pass")] [NativeName(NativeNameType.Type, "SDL_GPUCopyPass *")] ref SDLGPUCopyPass copyPass)
		{
			fixed (SDLGPUCopyPass* pcopyPass = &copyPass)
			{
				EndGPUCopyPassNative((SDLGPUCopyPass*)pcopyPass);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapsForGPUTextureNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUTexture*, void>)funcTable[900])(commandBuffer, texture);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[900])((nint)commandBuffer, (nint)texture);
			#endif
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			GenerateMipmapsForGPUTextureNative(commandBuffer, texture);
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] SDLGPUTexture* texture)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				GenerateMipmapsForGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, texture);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUTexture* ptexture = &texture)
			{
				GenerateMipmapsForGPUTextureNative(commandBuffer, (SDLGPUTexture*)ptexture);
			}
		}

		/// <summary>
		/// Generates mipmaps for the given texture.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GenerateMipmapsForGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GenerateMipmapsForGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture *")] ref SDLGPUTexture texture)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture* ptexture = &texture)
				{
					GenerateMipmapsForGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUTexture*)ptexture);
				}
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitGPUTextureNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] SDLGPUBlitInfo* info)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLGPUBlitInfo*, void>)funcTable[901])(commandBuffer, info);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[901])((nint)commandBuffer, (nint)info);
			#endif
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] SDLGPUBlitInfo* info)
		{
			BlitGPUTextureNative(commandBuffer, info);
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] SDLGPUBlitInfo* info)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				BlitGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, info);
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] ref SDLGPUBlitInfo info)
		{
			fixed (SDLGPUBlitInfo* pinfo = &info)
			{
				BlitGPUTextureNative(commandBuffer, (SDLGPUBlitInfo*)pinfo);
			}
		}

		/// <summary>
		/// Blits from a source texture region to a destination texture region.<br/>
		/// This function must not be called inside of any pass.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BlitGPUTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BlitGPUTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_GPUBlitInfo const *")] ref SDLGPUBlitInfo info)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUBlitInfo* pinfo = &info)
				{
					BlitGPUTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLGPUBlitInfo*)pinfo);
				}
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowSupportsGPUSwapchainCompositionNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUSwapchainComposition, byte>)funcTable[902])(device, window, swapchainComposition);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUSwapchainComposition, byte>)funcTable[902])((nint)device, (nint)window, swapchainComposition);
			#endif
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			byte ret = WindowSupportsGPUSwapchainCompositionNative(device, window, swapchainComposition);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WindowSupportsGPUSwapchainCompositionNative((SDLGPUDevice*)pdevice, window, swapchainComposition);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowSupportsGPUSwapchainCompositionNative(device, (SDLWindow*)pwindow, swapchainComposition);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a swapchain composition is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUSwapchainComposition")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUSwapchainComposition([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WindowSupportsGPUSwapchainCompositionNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, swapchainComposition);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte WindowSupportsGPUPresentModeNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUPresentMode, byte>)funcTable[903])(device, window, presentMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUPresentMode, byte>)funcTable[903])((nint)device, (nint)window, presentMode);
			#endif
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			byte ret = WindowSupportsGPUPresentModeNative(device, window, presentMode);
			return ret != 0;
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = WindowSupportsGPUPresentModeNative((SDLGPUDevice*)pdevice, window, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = WindowSupportsGPUPresentModeNative(device, (SDLWindow*)pwindow, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Determines whether a presentation mode is supported by the window.<br/>
		/// The window must be claimed before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WindowSupportsGPUPresentMode")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WindowSupportsGPUPresentMode([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = WindowSupportsGPUPresentModeNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, presentMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ClaimWindowForGPUDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, byte>)funcTable[904])(device, window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[904])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			byte ret = ClaimWindowForGPUDeviceNative(device, window);
			return ret != 0;
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = ClaimWindowForGPUDeviceNative((SDLGPUDevice*)pdevice, window);
				return ret != 0;
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = ClaimWindowForGPUDeviceNative(device, (SDLWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// Claims a window, creating a swapchain structure for it.<br/>
		/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
		/// the window. You should only call this function from the thread that created<br/>
		/// the window.<br/>
		/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
		/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
		/// window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClaimWindowForGPUDevice")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ClaimWindowForGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = ClaimWindowForGPUDeviceNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseWindowFromGPUDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, void>)funcTable[905])(device, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[905])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			ReleaseWindowFromGPUDeviceNative(device, window);
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				ReleaseWindowFromGPUDeviceNative((SDLGPUDevice*)pdevice, window);
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				ReleaseWindowFromGPUDeviceNative(device, (SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Unclaims a window, destroying its swapchain structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReleaseWindowFromGPUDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ReleaseWindowFromGPUDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					ReleaseWindowFromGPUDeviceNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGPUSwapchainParametersNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUSwapchainComposition, SDLGPUPresentMode, byte>)funcTable[906])(device, window, swapchainComposition, presentMode);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUSwapchainComposition, SDLGPUPresentMode, byte>)funcTable[906])((nint)device, (nint)window, swapchainComposition, presentMode);
			#endif
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			byte ret = SetGPUSwapchainParametersNative(device, window, swapchainComposition, presentMode);
			return ret != 0;
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = SetGPUSwapchainParametersNative((SDLGPUDevice*)pdevice, window, swapchainComposition, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = SetGPUSwapchainParametersNative(device, (SDLWindow*)pwindow, swapchainComposition, presentMode);
				return ret != 0;
			}
		}

		/// <summary>
		/// Changes the swapchain parameters for the given claimed window.<br/>
		/// This function will fail if the requested present mode or swapchain<br/>
		/// composition are unsupported by the device. Check if the parameters are<br/>
		/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
		/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
		/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
		/// supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUSwapchainParameters")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUSwapchainParameters([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_composition")] [NativeName(NativeNameType.Type, "SDL_GPUSwapchainComposition")] SDLGPUSwapchainComposition swapchainComposition, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "SDL_GPUPresentMode")] SDLGPUPresentMode presentMode)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = SetGPUSwapchainParametersNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow, swapchainComposition, presentMode);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Configures the maximum allowed number of frames in flight.<br/>
		/// The default value when the device is created is 2. This means that after<br/>
		/// you have submitted 2 frames for presentation, if the GPU has not finished<br/>
		/// working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the<br/>
		/// swapchain texture pointer with NULL, and<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() will block.<br/>
		/// Higher values increase throughput at the expense of visual latency. Lower<br/>
		/// values decrease visual latency at the expense of throughput.<br/>
		/// Note that calling this function will stall and flush the command queue to<br/>
		/// prevent synchronization issues.<br/>
		/// The minimum value of allowed frames in flight is 1, and the maximum is 3.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUAllowedFramesInFlight")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGPUAllowedFramesInFlightNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "allowed_frames_in_flight")] [NativeName(NativeNameType.Type, "Uint32")] uint allowedFramesInFlight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, uint, byte>)funcTable[907])(device, allowedFramesInFlight);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, uint, byte>)funcTable[907])((nint)device, allowedFramesInFlight);
			#endif
		}

		/// <summary>
		/// Configures the maximum allowed number of frames in flight.<br/>
		/// The default value when the device is created is 2. This means that after<br/>
		/// you have submitted 2 frames for presentation, if the GPU has not finished<br/>
		/// working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the<br/>
		/// swapchain texture pointer with NULL, and<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() will block.<br/>
		/// Higher values increase throughput at the expense of visual latency. Lower<br/>
		/// values decrease visual latency at the expense of throughput.<br/>
		/// Note that calling this function will stall and flush the command queue to<br/>
		/// prevent synchronization issues.<br/>
		/// The minimum value of allowed frames in flight is 1, and the maximum is 3.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUAllowedFramesInFlight")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUAllowedFramesInFlight([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "allowed_frames_in_flight")] [NativeName(NativeNameType.Type, "Uint32")] uint allowedFramesInFlight)
		{
			byte ret = SetGPUAllowedFramesInFlightNative(device, allowedFramesInFlight);
			return ret != 0;
		}

		/// <summary>
		/// Configures the maximum allowed number of frames in flight.<br/>
		/// The default value when the device is created is 2. This means that after<br/>
		/// you have submitted 2 frames for presentation, if the GPU has not finished<br/>
		/// working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the<br/>
		/// swapchain texture pointer with NULL, and<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() will block.<br/>
		/// Higher values increase throughput at the expense of visual latency. Lower<br/>
		/// values decrease visual latency at the expense of throughput.<br/>
		/// Note that calling this function will stall and flush the command queue to<br/>
		/// prevent synchronization issues.<br/>
		/// The minimum value of allowed frames in flight is 1, and the maximum is 3.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGPUAllowedFramesInFlight")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGPUAllowedFramesInFlight([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "allowed_frames_in_flight")] [NativeName(NativeNameType.Type, "Uint32")] uint allowedFramesInFlight)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				byte ret = SetGPUAllowedFramesInFlightNative((SDLGPUDevice*)pdevice, allowedFramesInFlight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGPUTextureFormat GetGPUSwapchainTextureFormatNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUDevice*, SDLWindow*, SDLGPUTextureFormat>)funcTable[908])(device, window);
			#else
			return (SDLGPUTextureFormat)((delegate* unmanaged[Cdecl]<nint, nint, SDLGPUTextureFormat>)funcTable[908])((nint)device, (nint)window);
			#endif
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative(device, window);
			return ret;
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative((SDLGPUDevice*)pdevice, window);
				return ret;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] SDLGPUDevice* device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative(device, (SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Obtains the texture format of the swapchain for the given window.<br/>
		/// Note that this format can change if the swapchain parameters change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGPUSwapchainTextureFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_GPUTextureFormat")]
		public static SDLGPUTextureFormat GetGPUSwapchainTextureFormat([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "SDL_GPUDevice *")] ref SDLGPUDevice device, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLGPUDevice* pdevice = &device)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					SDLGPUTextureFormat ret = GetGPUSwapchainTextureFormatNative((SDLGPUDevice*)pdevice, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AcquireGPUSwapchainTextureNative([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGPUCommandBuffer*, SDLWindow*, SDLGPUTexture**, uint*, uint*, byte>)funcTable[909])(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[909])((nint)commandBuffer, (nint)window, (nint)swapchainTexture, (nint)swapchainTextureWidth, (nint)swapchainTextureHeight);
			#endif
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
			return ret != 0;
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
					{
						fixed (uint* pswapchainTextureWidth = &swapchainTextureWidth)
						{
							byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, (uint*)pswapchainTextureWidth, swapchainTextureHeight);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
			{
				byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
				return ret != 0;
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] SDLGPUTexture** swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, (SDLWindow*)pwindow, swapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
			{
				fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
				{
					byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] ref SDLGPUCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLGPUCommandBuffer* pcommandBuffer = &commandBuffer)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative((SDLGPUCommandBuffer*)pcommandBuffer, window, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Acquire a texture to use in presentation.<br/>
		/// When a swapchain texture is acquired on a command buffer, it will<br/>
		/// automatically be submitted for presentation when the command buffer is<br/>
		/// submitted. The swapchain texture should only be referenced by the command<br/>
		/// buffer used to acquire it.<br/>
		/// This function will fill the swapchain texture handle with NULL if too many<br/>
		/// frames are in flight. This is not an error.<br/>
		/// If you use this function, it is possible to create a situation where many<br/>
		/// command buffers are allocated while the rendering context waits for the GPU<br/>
		/// to catch up, which will cause memory usage to grow. You should use<br/>
		/// SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing<br/>
		/// with timing.<br/>
		/// The swapchain texture is managed by the implementation and must not be<br/>
		/// freed by the user. You MUST NOT call this function from any thread other<br/>
		/// than the one that created the window.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called from the thread that<br/>
		/// created the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AcquireGPUSwapchainTexture")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AcquireGPUSwapchainTexture([NativeName(NativeNameType.Param, "command_buffer")] [NativeName(NativeNameType.Type, "SDL_GPUCommandBuffer *")] SDLGPUCommandBuffer* commandBuffer, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window, [NativeName(NativeNameType.Param, "swapchain_texture")] [NativeName(NativeNameType.Type, "SDL_GPUTexture * *")] ref SDLGPUTexture* swapchainTexture, [NativeName(NativeNameType.Param, "swapchain_texture_width")] [NativeName(NativeNameType.Type, "Uint32 *")] uint* swapchainTextureWidth, [NativeName(NativeNameType.Param, "swapchain_texture_height")] [NativeName(NativeNameType.Type, "Uint32 *")] ref uint swapchainTextureHeight)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLGPUTexture** pswapchainTexture = &swapchainTexture)
				{
					fixed (uint* pswapchainTextureHeight = &swapchainTextureHeight)
					{
						byte ret = AcquireGPUSwapchainTextureNative(commandBuffer, (SDLWindow*)pwindow, (SDLGPUTexture**)pswapchainTexture, swapchainTextureWidth, (uint*)pswapchainTextureHeight);
						return ret != 0;
					}
				}
			}
		}
	}
}
