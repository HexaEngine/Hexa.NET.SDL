// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.SDL3
{
	public unsafe partial class SDL
	{

		/// <summary>
		/// Get the instance ID of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int GetGamepadID([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			int ret = GetGamepadIDNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int GetGamepadID([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetGamepadIDNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadNameNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte*>)funcTable[720])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[720])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadName([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			byte* ret = GetGamepadNameNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadNameS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadNameNative((SDLGamepad*)gamepad));
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadName([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadNameNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadNameS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadNameNative((SDLGamepad*)pgamepad));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadPathNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte*>)funcTable[721])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[721])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadPath([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			byte* ret = GetGamepadPathNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadPathS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadPathNative((SDLGamepad*)gamepad));
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadPath([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadPathNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPath")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadPathS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadPathNative((SDLGamepad*)pgamepad));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetGamepadTypeNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadType>)funcTable[722])(gamepad);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<nint, SDLGamepadType>)funcTable[722])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the type of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetGamepadType([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			SDLGamepadType ret = GetGamepadTypeNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetGamepadType([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadType ret = GetGamepadTypeNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened gamepad, ignoring any mapping override.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRealGamepadType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetRealGamepadTypeNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadType>)funcTable[723])(gamepad);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<nint, SDLGamepadType>)funcTable[723])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the type of an opened gamepad, ignoring any mapping override.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRealGamepadType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetRealGamepadType([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			SDLGamepadType ret = GetRealGamepadTypeNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the type of an opened gamepad, ignoring any mapping override.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRealGamepadType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetRealGamepadType([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadType ret = GetRealGamepadTypeNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened gamepad.<br/>
		/// For XInput gamepads this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadPlayerIndexNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int>)funcTable[724])(gamepad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[724])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the player index of an opened gamepad.<br/>
		/// For XInput gamepads this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadPlayerIndex([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			int ret = GetGamepadPlayerIndexNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the player index of an opened gamepad.<br/>
		/// For XInput gamepads this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadPlayerIndex([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetGamepadPlayerIndexNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGamepadPlayerIndexNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, byte>)funcTable[725])(gamepad, playerIndex);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[725])((nint)gamepad, playerIndex);
			#endif
		}

		/// <summary>
		/// Set the player index of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGamepadPlayerIndex([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			byte ret = SetGamepadPlayerIndexNative((SDLGamepad*)gamepad, playerIndex);
			return ret != 0;
		}

		/// <summary>
		/// Set the player index of an opened gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGamepadPlayerIndex([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SetGamepadPlayerIndexNative((SDLGamepad*)pgamepad, playerIndex);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened gamepad, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadVendorNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[726])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[726])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the USB vendor ID of an opened gamepad, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadVendor([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			ushort ret = GetGamepadVendorNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of an opened gamepad, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadVendor([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadVendorNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened gamepad, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadProductNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[727])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[727])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the USB product ID of an opened gamepad, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadProduct([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			ushort ret = GetGamepadProductNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of an opened gamepad, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadProduct([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadProductNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened gamepad, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadProductVersionNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[728])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[728])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the product version of an opened gamepad, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadProductVersion([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			ushort ret = GetGamepadProductVersionNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the product version of an opened gamepad, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadProductVersion([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadProductVersionNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened gamepad, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetGamepadFirmwareVersionNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort>)funcTable[729])(gamepad);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[729])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the firmware version of an opened gamepad, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadFirmwareVersion([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			ushort ret = GetGamepadFirmwareVersionNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the firmware version of an opened gamepad, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort GetGamepadFirmwareVersion([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ushort ret = GetGamepadFirmwareVersionNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadSerialNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte*>)funcTable[730])(gamepad);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[730])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadSerial([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			byte* ret = GetGamepadSerialNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadSerialS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadSerialNative((SDLGamepad*)gamepad));
			return ret;
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadSerial([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadSerialNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened gamepad, if available.<br/>
		/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSerial")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadSerialS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadSerialNative((SDLGamepad*)pgamepad));
				return ret;
			}
		}

		/// <summary>
		/// Get the Steam Input handle of an opened gamepad, if available.<br/>
		/// Returns an InputHandle_t for the gamepad that can be used with Steam Input<br/>
		/// API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSteamHandle")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetGamepadSteamHandleNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ulong>)funcTable[731])(gamepad);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong>)funcTable[731])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the Steam Input handle of an opened gamepad, if available.<br/>
		/// Returns an InputHandle_t for the gamepad that can be used with Steam Input<br/>
		/// API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSteamHandle")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetGamepadSteamHandle([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			ulong ret = GetGamepadSteamHandleNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the Steam Input handle of an opened gamepad, if available.<br/>
		/// Returns an InputHandle_t for the gamepad that can be used with Steam Input<br/>
		/// API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSteamHandle")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong GetGamepadSteamHandle([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				ulong ret = GetGamepadSteamHandleNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the connection state of a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadConnectionState")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickConnectionState")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystickConnectionState GetGamepadConnectionStateNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLJoystickConnectionState>)funcTable[732])(gamepad);
			#else
			return (SDLJoystickConnectionState)((delegate* unmanaged[Cdecl]<nint, SDLJoystickConnectionState>)funcTable[732])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the connection state of a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadConnectionState")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickConnectionState")]
		public static SDLJoystickConnectionState GetGamepadConnectionState([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			SDLJoystickConnectionState ret = GetGamepadConnectionStateNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the connection state of a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadConnectionState")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickConnectionState")]
		public static SDLJoystickConnectionState GetGamepadConnectionState([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLJoystickConnectionState ret = GetGamepadConnectionStateNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLPowerState GetGamepadPowerInfoNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int*, SDLPowerState>)funcTable[733])(gamepad, percent);
			#else
			return (SDLPowerState)((delegate* unmanaged[Cdecl]<nint, nint, SDLPowerState>)funcTable[733])((nint)gamepad, (nint)percent);
			#endif
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetGamepadPowerInfo([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			SDLPowerState ret = GetGamepadPowerInfoNative((SDLGamepad*)gamepad, percent);
			return ret;
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetGamepadPowerInfo([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] int* percent)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLPowerState ret = GetGamepadPowerInfoNative((SDLGamepad*)pgamepad, percent);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetGamepadPowerInfo([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = GetGamepadPowerInfoNative((SDLGamepad*)gamepad, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>
		/// Get the battery state of a gamepad.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState GetGamepadPowerInfo([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int *")] ref int percent)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = GetGamepadPowerInfoNative((SDLGamepad*)pgamepad, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Check if a gamepad has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadConnected")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadConnectedNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte>)funcTable[734])(gamepad);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[734])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Check if a gamepad has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadConnected")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadConnected([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			byte ret = GamepadConnectedNative((SDLGamepad*)gamepad);
			return ret != 0;
		}

		/// <summary>
		/// Check if a gamepad has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadConnected")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadConnected([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadConnectedNative((SDLGamepad*)pgamepad);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the underlying joystick from a gamepad.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful<br/>
		/// for getting a joystick's position at any given time, even if it hasn't<br/>
		/// moved (moving it would produce an event, which would have the axis' value).<br/>
		/// The pointer returned is owned by the SDL_Gamepad. You should not call<br/>
		/// SDL_CloseJoystick() on it, for example, since doing so will likely cause<br/>
		/// SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLJoystick* GetGamepadJoystickNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLJoystick*>)funcTable[735])(gamepad);
			#else
			return (SDLJoystick*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[735])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the underlying joystick from a gamepad.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful<br/>
		/// for getting a joystick's position at any given time, even if it hasn't<br/>
		/// moved (moving it would produce an event, which would have the axis' value).<br/>
		/// The pointer returned is owned by the SDL_Gamepad. You should not call<br/>
		/// SDL_CloseJoystick() on it, for example, since doing so will likely cause<br/>
		/// SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystickPtr GetGamepadJoystick([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			SDLJoystickPtr ret = GetGamepadJoystickNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the underlying joystick from a gamepad.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful<br/>
		/// for getting a joystick's position at any given time, even if it hasn't<br/>
		/// moved (moving it would produce an event, which would have the axis' value).<br/>
		/// The pointer returned is owned by the SDL_Gamepad. You should not call<br/>
		/// SDL_CloseJoystick() on it, for example, since doing so will likely cause<br/>
		/// SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick *")]
		public static SDLJoystickPtr GetGamepadJoystick([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLJoystickPtr ret = GetGamepadJoystickNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Set the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGamepadEventsEnabledNative([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[736])(enabled);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[736])(enabled);
			#endif
		}

		/// <summary>
		/// Set the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetGamepadEventsEnabled([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			SetGamepadEventsEnabledNative(enabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Query the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadEventsEnabledNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[737])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[737])();
			#endif
		}

		/// <summary>
		/// Query the state of gamepad event processing.<br/>
		/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
		/// and check the state of the gamepad when you want gamepad information.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadEventsEnabled()
		{
			byte ret = GamepadEventsEnabledNative();
			return ret != 0;
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadBindings")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadBinding * *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadBinding** GetGamepadBindingsNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int*, SDLGamepadBinding**>)funcTable[738])(gamepad, count);
			#else
			return (SDLGamepadBinding**)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[738])((nint)gamepad, (nint)count);
			#endif
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadBindings")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadBinding * *")]
		public static SDLGamepadBindingPtrPtr GetGamepadBindings([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			SDLGamepadBindingPtrPtr ret = GetGamepadBindingsNative((SDLGamepad*)gamepad, count);
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadBindings")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadBinding * *")]
		public static SDLGamepadBindingPtrPtr GetGamepadBindings([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadBindingPtrPtr ret = GetGamepadBindingsNative((SDLGamepad*)pgamepad, count);
				return ret;
			}
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadBindings")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadBinding * *")]
		public static SDLGamepadBindingPtrPtr GetGamepadBindings([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				SDLGamepadBindingPtrPtr ret = GetGamepadBindingsNative((SDLGamepad*)gamepad, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the SDL joystick layer bindings for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadBindings")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadBinding * *")]
		public static SDLGamepadBindingPtrPtr GetGamepadBindings([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (int* pcount = &count)
				{
					SDLGamepadBindingPtrPtr ret = GetGamepadBindingsNative((SDLGamepad*)pgamepad, (int*)pcount);
					return ret;
				}
			}
		}

		/// <summary>
		/// Manually pump gamepad updates if not using the loop.<br/>
		/// This function is called automatically by the event loop if events are<br/>
		/// enabled. Under such circumstances, it will not be necessary to call this<br/>
		/// function.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateGamepads")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateGamepadsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[739])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[739])();
			#endif
		}

		/// <summary>
		/// Manually pump gamepad updates if not using the loop.<br/>
		/// This function is called automatically by the event loop if events are<br/>
		/// enabled. Under such circumstances, it will not be necessary to call this<br/>
		/// function.<br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateGamepads")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UpdateGamepads()
		{
			UpdateGamepadsNative();
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTypeFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadType GetGamepadTypeFromStringNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGamepadType>)funcTable[740])(str);
			#else
			return (SDLGamepadType)((delegate* unmanaged[Cdecl]<nint, SDLGamepadType>)funcTable[740])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTypeFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetGamepadTypeFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			SDLGamepadType ret = GetGamepadTypeFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTypeFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetGamepadTypeFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] in byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGamepadType ret = GetGamepadTypeFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTypeFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetGamepadTypeFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGamepadType ret = GetGamepadTypeFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadType enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTypeFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadType")]
		public static SDLGamepadType GetGamepadTypeFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGamepadType ret = GetGamepadTypeFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadType enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForType")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadStringForTypeNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GamepadType")] SDLGamepadType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadType, byte*>)funcTable[741])(type);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGamepadType, nint>)funcTable[741])(type);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GamepadType enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForType")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadStringForType([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GamepadType")] SDLGamepadType type)
		{
			byte* ret = GetGamepadStringForTypeNative(type);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadType enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForType")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadStringForTypeS([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GamepadType")] SDLGamepadType type)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadStringForTypeNative(type));
			return ret;
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadAxis")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadAxis GetGamepadAxisFromStringNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGamepadAxis>)funcTable[742])(str);
			#else
			return (SDLGamepadAxis)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis>)funcTable[742])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadAxis")]
		public static SDLGamepadAxis GetGamepadAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			SDLGamepadAxis ret = GetGamepadAxisFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadAxis")]
		public static SDLGamepadAxis GetGamepadAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] in byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGamepadAxis ret = GetGamepadAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadAxis")]
		public static SDLGamepadAxis GetGamepadAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGamepadAxis ret = GetGamepadAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into SDL_GamepadAxis enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadAxis")]
		public static SDLGamepadAxis GetGamepadAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGamepadAxis ret = GetGamepadAxisFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadAxis enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadStringForAxisNative([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadAxis, byte*>)funcTable[743])(axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGamepadAxis, nint>)funcTable[743])(axis);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GamepadAxis enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadStringForAxis([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			byte* ret = GetGamepadStringForAxisNative(axis);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadAxis enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadStringForAxisS([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadStringForAxisNative(axis));
			return ret;
		}

		/// <summary>
		/// Query whether a gamepad has a given axis.<br/>
		/// This merely reports whether the gamepad's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasAxis")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadHasAxisNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadAxis, byte>)funcTable[744])(gamepad, axis);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis, byte>)funcTable[744])((nint)gamepad, axis);
			#endif
		}

		/// <summary>
		/// Query whether a gamepad has a given axis.<br/>
		/// This merely reports whether the gamepad's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasAxis")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadHasAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			byte ret = GamepadHasAxisNative((SDLGamepad*)gamepad, axis);
			return ret != 0;
		}

		/// <summary>
		/// Query whether a gamepad has a given axis.<br/>
		/// This merely reports whether the gamepad's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasAxis")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadHasAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadHasAxisNative((SDLGamepad*)pgamepad, axis);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of an axis control on a gamepad.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.<br/>
		/// Note that for invalid gamepads or axes, this will return 0. Zero is also a<br/>
		/// valid value in normal operation; usually it means a centered axis.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static short GetGamepadAxisNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadAxis, short>)funcTable[745])(gamepad, axis);
			#else
			return (short)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis, short>)funcTable[745])((nint)gamepad, axis);
			#endif
		}

		/// <summary>
		/// Get the current state of an axis control on a gamepad.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.<br/>
		/// Note that for invalid gamepads or axes, this will return 0. Zero is also a<br/>
		/// valid value in normal operation; usually it means a centered axis.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short GetGamepadAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			short ret = GetGamepadAxisNative((SDLGamepad*)gamepad, axis);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a gamepad.<br/>
		/// The axis indices start at index 0.<br/>
		/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
		/// 32767 (down/right).<br/>
		/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
		/// return a negative value. Note that this differs from the value reported by<br/>
		/// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.<br/>
		/// Note that for invalid gamepads or axes, this will return 0. Zero is also a<br/>
		/// valid value in normal operation; usually it means a centered axis.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short GetGamepadAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				short ret = GetGamepadAxisNative((SDLGamepad*)pgamepad, axis);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButton")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButton GetGamepadButtonFromStringNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLGamepadButton>)funcTable[746])(str);
			#else
			return (SDLGamepadButton)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton>)funcTable[746])((nint)str);
			#endif
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButton")]
		public static SDLGamepadButton GetGamepadButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] byte* str)
		{
			SDLGamepadButton ret = GetGamepadButtonFromStringNative(str);
			return ret;
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButton")]
		public static SDLGamepadButton GetGamepadButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] in byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGamepadButton ret = GetGamepadButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButton")]
		public static SDLGamepadButton GetGamepadButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SDLGamepadButton ret = GetGamepadButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GamepadButton enum.<br/>
		/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
		/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
		/// You do not normally need to call this function unless you are parsing<br/>
		/// SDL_Gamepad mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButton")]
		public static SDLGamepadButton GetGamepadButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char const *")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGamepadButton ret = GetGamepadButtonFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadButton enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadStringForButtonNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadButton, byte*>)funcTable[747])(button);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLGamepadButton, nint>)funcTable[747])(button);
			#endif
		}

		/// <summary>
		/// Convert from an SDL_GamepadButton enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadStringForButton([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			byte* ret = GetGamepadStringForButtonNative(button);
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GamepadButton enum to a string.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadStringForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadStringForButtonS([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadStringForButtonNative(button));
			return ret;
		}

		/// <summary>
		/// Query whether a gamepad has a given button.<br/>
		/// This merely reports whether the gamepad's mapping defined this button, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadHasButtonNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, byte>)funcTable[748])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, byte>)funcTable[748])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Query whether a gamepad has a given button.<br/>
		/// This merely reports whether the gamepad's mapping defined this button, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadHasButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			byte ret = GamepadHasButtonNative((SDLGamepad*)gamepad, button);
			return ret != 0;
		}

		/// <summary>
		/// Query whether a gamepad has a given button.<br/>
		/// This merely reports whether the gamepad's mapping defined this button, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadHasButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadHasButtonNative((SDLGamepad*)pgamepad, button);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetGamepadButtonNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, byte>)funcTable[749])(gamepad, button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, byte>)funcTable[749])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			byte ret = GetGamepadButtonNative((SDLGamepad*)gamepad, button);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GetGamepadButtonNative((SDLGamepad*)pgamepad, button);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabelForType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButtonLabel GetGamepadButtonLabelForTypeNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GamepadType")] SDLGamepadType type, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepadType, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[750])(type, button);
			#else
			return (SDLGamepadButtonLabel)((delegate* unmanaged[Cdecl]<SDLGamepadType, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[750])(type, button);
			#endif
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabelForType")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		public static SDLGamepadButtonLabel GetGamepadButtonLabelForType([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_GamepadType")] SDLGamepadType type, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			SDLGamepadButtonLabel ret = GetGamepadButtonLabelForTypeNative(type, button);
			return ret;
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabel")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLGamepadButtonLabel GetGamepadButtonLabelNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[751])(gamepad, button);
			#else
			return (SDLGamepadButtonLabel)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, SDLGamepadButtonLabel>)funcTable[751])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabel")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		public static SDLGamepadButtonLabel GetGamepadButtonLabel([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			SDLGamepadButtonLabel ret = GetGamepadButtonLabelNative((SDLGamepad*)gamepad, button);
			return ret;
		}

		/// <summary>
		/// Get the label of a button on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadButtonLabel")]
		[return: NativeName(NativeNameType.Type, "SDL_GamepadButtonLabel")]
		public static SDLGamepadButtonLabel GetGamepadButtonLabel([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				SDLGamepadButtonLabel ret = GetGamepadButtonLabelNative((SDLGamepad*)pgamepad, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGamepadTouchpadsNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int>)funcTable[752])(gamepad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[752])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpads([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			int ret = GetNumGamepadTouchpadsNative((SDLGamepad*)gamepad);
			return ret;
		}

		/// <summary>
		/// Get the number of touchpads on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpads([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetNumGamepadTouchpadsNative((SDLGamepad*)pgamepad);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetNumGamepadTouchpadFingersNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, int>)funcTable[753])(gamepad, touchpad);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[753])((nint)gamepad, touchpad);
			#endif
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpadFingers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			int ret = GetNumGamepadTouchpadFingersNative((SDLGamepad*)gamepad, touchpad);
			return ret;
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumGamepadTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetNumGamepadTouchpadFingers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				int ret = GetNumGamepadTouchpadFingersNative((SDLGamepad*)pgamepad, touchpad);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetGamepadTouchpadFingerNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, int, int, bool*, float*, float*, float*, byte>)funcTable[754])(gamepad, touchpad, finger, down, x, y, pressure);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, nint, nint, byte>)funcTable[754])((nint)gamepad, touchpad, finger, (nint)down, (nint)x, (nint)y, (nint)pressure);
			#endif
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, x, y, pressure);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, x, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, y, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (float* px = &x)
			{
				byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, (float*)px, y, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, y, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, (float*)px, y, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, y, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (float* py = &y)
			{
				byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, x, (float*)py, pressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* py = &y)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, (float*)py, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* py = &y)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, x, (float*)py, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* py = &y)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, (float*)py, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, (float*)px, (float*)py, pressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, (float*)py, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, pressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] float* pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, pressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* ppressure = &pressure)
			{
				byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, x, y, (float*)ppressure);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, y, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, x, y, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, y, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, (float*)px, y, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, y, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, (float*)px, y, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, y, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* py = &y)
			{
				fixed (float* ppressure = &pressure)
				{
					byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, x, (float*)py, (float*)ppressure);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, x, (float*)py, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, x, (float*)py, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, x, (float*)py, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, down, (float*)px, (float*)py, (float*)ppressure);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] bool* down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, down, (float*)px, (float*)py, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (bool* pdown = &down)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)gamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, (float*)ppressure);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadTouchpadFinger([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "down")] [NativeName(NativeNameType.Type, "bool *")] ref bool down, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float *")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float *")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float *")] ref float pressure)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (bool* pdown = &down)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							fixed (float* ppressure = &pressure)
							{
								byte ret = GetGamepadTouchpadFingerNative((SDLGamepad*)pgamepad, touchpad, finger, (bool*)pdown, (float*)px, (float*)py, (float*)ppressure);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasSensor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadHasSensorNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, byte>)funcTable[755])(gamepad, type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, byte>)funcTable[755])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasSensor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadHasSensor([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			byte ret = GamepadHasSensorNative((SDLGamepad*)gamepad, type);
			return ret != 0;
		}

		/// <summary>
		/// Return whether a gamepad has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadHasSensor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadHasSensor([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadHasSensorNative((SDLGamepad*)pgamepad, type);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGamepadSensorEnabledNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] byte enabled)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, byte, byte>)funcTable[756])(gamepad, type, enabled);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, byte, byte>)funcTable[756])((nint)gamepad, type, enabled);
			#endif
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			byte ret = SetGamepadSensorEnabledNative((SDLGamepad*)gamepad, type, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Set whether data reporting for a gamepad sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "bool")] bool enabled)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SetGamepadSensorEnabledNative((SDLGamepad*)pgamepad, type, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GamepadSensorEnabledNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, byte>)funcTable[757])(gamepad, type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, byte>)funcTable[757])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			byte ret = GamepadSensorEnabledNative((SDLGamepad*)gamepad, type);
			return ret != 0;
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a gamepad.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GamepadSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GamepadSensorEnabled([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GamepadSensorEnabledNative((SDLGamepad*)pgamepad, type);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetGamepadSensorDataRateNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, float>)funcTable[758])(gamepad, type);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, float>)funcTable[758])((nint)gamepad, type);
			#endif
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGamepadSensorDataRate([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			float ret = GetGamepadSensorDataRateNative((SDLGamepad*)gamepad, type);
			return ret;
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetGamepadSensorDataRate([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				float ret = GetGamepadSensorDataRateNative((SDLGamepad*)pgamepad, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See the remarks in SDL_SensorType for details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetGamepadSensorDataNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLSensorType, float*, int, byte>)funcTable[759])(gamepad, type, data, numValues);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, SDLSensorType, nint, int, byte>)funcTable[759])((nint)gamepad, type, (nint)data, numValues);
			#endif
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See the remarks in SDL_SensorType for details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			byte ret = GetGamepadSensorDataNative((SDLGamepad*)gamepad, type, data, numValues);
			return ret != 0;
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See the remarks in SDL_SensorType for details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = GetGamepadSensorDataNative((SDLGamepad*)pgamepad, type, data, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See the remarks in SDL_SensorType for details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				byte ret = GetGamepadSensorDataNative((SDLGamepad*)gamepad, type, (float*)pdata, numValues);
				return ret != 0;
			}
		}

		/// <summary>
		/// Get the current state of a gamepad sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See the remarks in SDL_SensorType for details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadSensorData")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool GetGamepadSensorData([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float *")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				fixed (float* pdata = &data)
				{
					byte ret = GetGamepadSensorDataNative((SDLGamepad*)pgamepad, type, (float*)pdata, numValues);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepad")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RumbleGamepadNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort, ushort, uint, byte>)funcTable[760])(gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, byte>)funcTable[760])((nint)gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepad")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RumbleGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			byte ret = RumbleGamepadNative((SDLGamepad*)gamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret != 0;
		}

		/// <summary>
		/// Start a rumble effect on a gamepad.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepad")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RumbleGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = RumbleGamepadNative((SDLGamepad*)pgamepad, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret != 0;
			}
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepadTriggers")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte RumbleGamepadTriggersNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, ushort, ushort, uint, byte>)funcTable[761])(gamepad, leftRumble, rightRumble, durationMs);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ushort, ushort, uint, byte>)funcTable[761])((nint)gamepad, leftRumble, rightRumble, durationMs);
			#endif
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepadTriggers")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RumbleGamepadTriggers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			byte ret = RumbleGamepadTriggersNative((SDLGamepad*)gamepad, leftRumble, rightRumble, durationMs);
			return ret != 0;
		}

		/// <summary>
		/// Start a rumble effect in the gamepad's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
		/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
		/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
		/// This function requires you to process SDL events or call<br/>
		/// SDL_UpdateJoysticks() to update rumble state.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RumbleGamepadTriggers")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RumbleGamepadTriggers([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = RumbleGamepadTriggersNative((SDLGamepad*)pgamepad, leftRumble, rightRumble, durationMs);
				return ret != 0;
			}
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadLED")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetGamepadLEDNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, byte, byte, byte, byte>)funcTable[762])(gamepad, red, green, blue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte>)funcTable[762])((nint)gamepad, red, green, blue);
			#endif
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadLED")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGamepadLED([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			byte ret = SetGamepadLEDNative((SDLGamepad*)gamepad, red, green, blue);
			return ret != 0;
		}

		/// <summary>
		/// Update a gamepad's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
		/// used as the LED brightness.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetGamepadLED")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetGamepadLED([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SetGamepadLEDNative((SDLGamepad*)pgamepad, red, green, blue);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SendGamepadEffectNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, void*, int, byte>)funcTable[763])(gamepad, data, size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[763])((nint)gamepad, (nint)data, size);
			#endif
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendGamepadEffect([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			byte ret = SendGamepadEffectNative((SDLGamepad*)gamepad, data, size);
			return ret != 0;
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendGamepadEffect([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SendGamepadEffectNative((SDLGamepad*)pgamepad, data, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendGamepadEffect([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] nint data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			byte ret = SendGamepadEffectNative((SDLGamepad*)gamepad, (void*)data, size);
			return ret != 0;
		}

		/// <summary>
		/// Send a gamepad specific effect packet.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SendGamepadEffect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SendGamepadEffect([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void const *")] nint data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte ret = SendGamepadEffectNative((SDLGamepad*)pgamepad, (void*)data, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// Close a gamepad previously opened with SDL_OpenGamepad().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseGamepad")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CloseGamepadNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SDLGamepad*, void>)funcTable[764])(gamepad);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[764])((nint)gamepad);
			#endif
		}

		/// <summary>
		/// Close a gamepad previously opened with SDL_OpenGamepad().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseGamepad")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad)
		{
			CloseGamepadNative((SDLGamepad*)gamepad);
		}

		/// <summary>
		/// Close a gamepad previously opened with SDL_OpenGamepad().<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseGamepad")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CloseGamepad([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				CloseGamepadNative((SDLGamepad*)pgamepad);
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadAppleSFSymbolsNameForButtonNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadButton, byte*>)funcTable[765])(gamepad, button);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, SDLGamepadButton, nint>)funcTable[765])((nint)gamepad, button);
			#endif
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			byte* ret = GetGamepadAppleSFSymbolsNameForButtonNative((SDLGamepad*)gamepad, button);
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForButtonNative((SDLGamepad*)gamepad, button));
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadAppleSFSymbolsNameForButtonNative((SDLGamepad*)pgamepad, button);
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GamepadButton")] SDLGamepadButton button)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForButtonNative((SDLGamepad*)pgamepad, button));
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadAppleSFSymbolsNameForAxisNative([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepad* gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLGamepad*, SDLGamepadAxis, byte*>)funcTable[766])(gamepad, axis);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, SDLGamepadAxis, nint>)funcTable[766])((nint)gamepad, axis);
			#endif
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			byte* ret = GetGamepadAppleSFSymbolsNameForAxisNative((SDLGamepad*)gamepad, axis);
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] SDLGamepadPtr gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForAxisNative((SDLGamepad*)gamepad, axis));
			return ret;
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetGamepadAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				byte* ret = GetGamepadAppleSFSymbolsNameForAxisNative((SDLGamepad*)pgamepad, axis);
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetGamepadAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamepad")] [NativeName(NativeNameType.Type, "SDL_Gamepad *")] ref SDLGamepad gamepad, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GamepadAxis")] SDLGamepadAxis axis)
		{
			fixed (SDLGamepad* pgamepad = &gamepad)
			{
				string ret = Utils.DecodeStringUTF8(GetGamepadAppleSFSymbolsNameForAxisNative((SDLGamepad*)pgamepad, axis));
				return ret;
			}
		}

		/// <summary>
		/// Return whether a keyboard is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasKeyboard")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasKeyboardNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[767])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[767])();
			#endif
		}

		/// <summary>
		/// Return whether a keyboard is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasKeyboard")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool HasKeyboard()
		{
			byte ret = HasKeyboardNative();
			return ret != 0;
		}

		/// <summary>
		/// Get a list of currently connected keyboards.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// keyboard functionality, including some mice, KVM switches, motherboard<br/>
		/// power buttons, etc. You should wait for input from a device before you<br/>
		/// consider it actively in use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboards")]
		[return: NativeName(NativeNameType.Type, "SDL_KeyboardID *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetKeyboardsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, uint*>)funcTable[768])(count);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[768])((nint)count);
			#endif
		}

		/// <summary>
		/// Get a list of currently connected keyboards.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// keyboard functionality, including some mice, KVM switches, motherboard<br/>
		/// power buttons, etc. You should wait for input from a device before you<br/>
		/// consider it actively in use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboards")]
		[return: NativeName(NativeNameType.Type, "SDL_KeyboardID *")]
		public static uint* GetKeyboards([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] int* count)
		{
			uint* ret = GetKeyboardsNative(count);
			return ret;
		}

		/// <summary>
		/// Get a list of currently connected keyboards.<br/>
		/// Note that this will include any device or virtual driver that includes<br/>
		/// keyboard functionality, including some mice, KVM switches, motherboard<br/>
		/// power buttons, etc. You should wait for input from a device before you<br/>
		/// consider it actively in use.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboards")]
		[return: NativeName(NativeNameType.Type, "SDL_KeyboardID *")]
		public static uint* GetKeyboards([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int *")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				uint* ret = GetKeyboardsNative((int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// Get the name of a keyboard.<br/>
		/// This function returns "" if the keyboard doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyboardNameForIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_KeyboardID")] uint instanceId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*>)funcTable[769])(instanceId);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[769])(instanceId);
			#endif
		}

		/// <summary>
		/// Get the name of a keyboard.<br/>
		/// This function returns "" if the keyboard doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetKeyboardNameForID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_KeyboardID")] uint instanceId)
		{
			byte* ret = GetKeyboardNameForIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the name of a keyboard.<br/>
		/// This function returns "" if the keyboard doesn't have a name.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardNameForID")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetKeyboardNameForIDS([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_KeyboardID")] uint instanceId)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyboardNameForIDNative(instanceId));
			return ret;
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLWindow* GetKeyboardFocusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*>)funcTable[770])();
			#else
			return (SDLWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[770])();
			#endif
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window *")]
		public static SDLWindowPtr GetKeyboardFocus()
		{
			SDLWindowPtr ret = GetKeyboardFocusNative();
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of true means that the key is pressed and a<br/>
		/// value of false means that it is not. Indexes into this array are obtained<br/>
		/// by using SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "bool const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool* GetKeyboardStateNative([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] int* numkeys)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, bool*>)funcTable[771])(numkeys);
			#else
			return (bool*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[771])((nint)numkeys);
			#endif
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of true means that the key is pressed and a<br/>
		/// value of false means that it is not. Indexes into this array are obtained<br/>
		/// by using SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "bool const *")]
		public static bool* GetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] int* numkeys)
		{
			bool* ret = GetKeyboardStateNative(numkeys);
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of true means that the key is pressed and a<br/>
		/// value of false means that it is not. Indexes into this array are obtained<br/>
		/// by using SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "bool const *")]
		public static bool* GetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int *")] ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				bool* ret = GetKeyboardStateNative((int*)pnumkeys);
				return ret;
			}
		}

		/// <summary>
		/// Clear the state of the keyboard.<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetKeyboardNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[772])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[772])();
			#endif
		}

		/// <summary>
		/// Clear the state of the keyboard.<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetKeyboard()
		{
			ResetKeyboardNative();
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetModStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort>)funcTable[773])();
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<ushort>)funcTable[773])();
			#endif
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		public static ushort GetModState()
		{
			ushort ret = GetModStateNative();
			return ret;
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetModStateNative([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] ushort modstate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort, void>)funcTable[774])(modstate);
			#else
			((delegate* unmanaged[Cdecl]<ushort, void>)funcTable[774])(modstate);
			#endif
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// It is safe to call this function from any thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetModState([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] ushort modstate)
		{
			SetModStateNative(modstate);
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// If you want to get the keycode as it would be delivered in key events,<br/>
		/// including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should<br/>
		/// pass `key_event` as true. Otherwise this function simply translates the<br/>
		/// scancode based on the given modifier state.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromScancodeNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] ushort modstate, [NativeName(NativeNameType.Param, "key_event")] [NativeName(NativeNameType.Type, "bool")] byte keyEvent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, ushort, byte, int>)funcTable[775])(scancode, modstate, keyEvent);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SDLScancode, ushort, byte, int>)funcTable[775])(scancode, modstate, keyEvent);
			#endif
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// If you want to get the keycode as it would be delivered in key events,<br/>
		/// including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should<br/>
		/// pass `key_event` as true. Otherwise this function simply translates the<br/>
		/// scancode based on the given modifier state.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromScancode([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] ushort modstate, [NativeName(NativeNameType.Param, "key_event")] [NativeName(NativeNameType.Type, "bool")] bool keyEvent)
		{
			int ret = GetKeyFromScancodeNative(scancode, modstate, keyEvent ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// Note that there may be multiple scancode+modifier states that can generate<br/>
		/// this keycode, this will just return the first one found.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromKeyNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod *")] ushort* modstate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ushort*, SDLScancode>)funcTable[776])(key, modstate);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<int, nint, SDLScancode>)funcTable[776])(key, (nint)modstate);
			#endif
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// Note that there may be multiple scancode+modifier states that can generate<br/>
		/// this keycode, this will just return the first one found.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromKey([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod *")] ushort* modstate)
		{
			SDLScancode ret = GetScancodeFromKeyNative(key, modstate);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// Note that there may be multiple scancode+modifier states that can generate<br/>
		/// this keycode, this will just return the first one found.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromKey([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key, [NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod *")] ref ushort modstate)
		{
			fixed (ushort* pmodstate = &modstate)
			{
				SDLScancode ret = GetScancodeFromKeyNative(key, (ushort*)pmodstate);
				return ret;
			}
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SetScancodeNameNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, byte*, byte>)funcTable[777])(scancode, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SDLScancode, nint, byte>)funcTable[777])(scancode, (nint)name);
			#endif
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			byte ret = SetScancodeNameNative(scancode, name);
			return ret != 0;
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = SetScancodeNameNative(scancode, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = SetScancodeNameNative(scancode, (byte*)pname);
				return ret != 0;
			}
		}

		/// <summary>
		/// Set a human-readable name for a scancode.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetScancodeName")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetScancodeNameNative(scancode, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetScancodeNameNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLScancode, byte*>)funcTable[778])(scancode);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SDLScancode, nint>)funcTable[778])(scancode);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			byte* ret = GetScancodeNameNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetScancodeNameS([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			string ret = Utils.DecodeStringUTF8(GetScancodeNameNative(scancode));
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLScancode GetScancodeFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLScancode>)funcTable[779])(name);
			#else
			return (SDLScancode)((delegate* unmanaged[Cdecl]<nint, SDLScancode>)funcTable[779])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			SDLScancode ret = GetScancodeFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				SDLScancode ret = GetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode GetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLScancode ret = GetScancodeFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// If the key doesn't have a name, this function returns an empty string ("").<br/>
		/// Letters will be presented in their uppercase form, if applicable.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyNameNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[780])(key);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[780])(key);
			#endif
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// If the key doesn't have a name, this function returns an empty string ("").<br/>
		/// Letters will be presented in their uppercase form, if applicable.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetKeyName([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// If the key doesn't have a name, this function returns an empty string ("").<br/>
		/// Letters will be presented in their uppercase form, if applicable.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetKeyNameS([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[781])(name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[781])((nint)name);
			#endif
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] byte* name)
		{
			int ret = GetKeyFromNameNative(name);
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] in byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				int ret = GetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// This function is not thread safe.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int GetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char const *")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetKeyFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard and/or<br/>
		/// activates an IME, which can prevent some key press events from being passed<br/>
		/// through.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte StartTextInputNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLWindow*, byte>)funcTable[782])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[782])((nint)window);
			#endif
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard and/or<br/>
		/// activates an IME, which can prevent some key press events from being passed<br/>
		/// through.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StartTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] SDLWindowPtr window)
		{
			byte ret = StartTextInputNative((SDLWindow*)window);
			return ret != 0;
		}

		/// <summary>
		/// Start accepting Unicode text input events in a window.<br/>
		/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
		/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
		/// function paired with SDL_StopTextInput().<br/>
		/// Text input events are not received by default.<br/>
		/// On some platforms using this function shows the screen keyboard and/or<br/>
		/// activates an IME, which can prevent some key press events from being passed<br/>
		/// through.<br/>
		/// <br/>
		/// <br/>
		/// This function should only be called on the main thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool StartTextInput([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window *")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte ret = StartTextInputNative((SDLWindow*)pwindow);
				return ret != 0;
			}
		}
	}
}
